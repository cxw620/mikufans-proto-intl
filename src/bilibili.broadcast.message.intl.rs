// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Animation {
    ///
    #[prost(string, tag = "1")]
    pub resource_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub file_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub animation_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub width: i64,
    ///
    #[prost(int64, tag = "5")]
    pub height: i64,
    ///
    #[prost(int64, tag = "6")]
    pub r#type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsg {
    ///
    #[prost(enumeration = "AudioCmdType", tag = "1")]
    pub cmd: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub extra: ::core::option::Option<AudioCmdMsgExtra>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtra {
    ///
    #[prost(message, optional, tag = "1")]
    pub invitation_mic: ::core::option::Option<AudioCmdMsgExtraForInvitationMic>,
    ///
    #[prost(message, optional, tag = "2")]
    pub reject_mic: ::core::option::Option<AudioCmdMsgExtraForRejectMic>,
    ///
    #[prost(message, optional, tag = "3")]
    pub audio_room_info: ::core::option::Option<AudioCmdMsgExtraForRoomInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub audio_room_apply_count: ::core::option::Option<
        AudioCmdMsgExtraForRoomApplyCount,
    >,
    ///
    #[prost(message, optional, tag = "5")]
    pub audio_room_seat_info: ::core::option::Option<AudioCmdMsgExtraForRoomSeatsInfo>,
    ///
    #[prost(message, optional, tag = "6")]
    pub set_seat_mute: ::core::option::Option<AudioCmdMsgExtraForSetSeatMute>,
    ///
    #[prost(message, optional, tag = "7")]
    pub update_rtc_token: ::core::option::Option<AudioCmdMsgExtraForUpdateRtcToken>,
    ///
    #[prost(message, optional, tag = "8")]
    pub contribution: ::core::option::Option<AudioCmdMsgExtraForContribution>,
    ///
    #[prost(message, optional, tag = "9")]
    pub blacklist: ::core::option::Option<AudioCmdMsgExtraForBlacklist>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForBlacklist {
    ///
    #[prost(bool, tag = "1")]
    pub state: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForContribution {
    ///
    #[prost(string, tag = "1")]
    pub contribution: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForInvitationMic {
    ///
    #[prost(int64, tag = "1")]
    pub duration: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForRejectMic {
    ///
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForRoomApplyCount {
    ///
    #[prost(int64, tag = "1")]
    pub count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForRoomInfo {
    ///
    #[prost(int64, tag = "1")]
    pub room_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub channel_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub music: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub bg: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "9")]
    pub need_apply: bool,
    ///
    #[prost(int64, tag = "10")]
    pub create_time: i64,
    ///
    #[prost(int64, tag = "11")]
    pub seat_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForRoomSeatsInfo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub room_seats: ::prost::alloc::vec::Vec<AuditRoomSeatInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForSetSeatMute {
    ///
    #[prost(bool, tag = "1")]
    pub mute: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioCmdMsgExtraForUpdateRtcToken {
    ///
    #[prost(string, tag = "1")]
    pub rtc_token: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioLevelUpMsg {
    ///
    #[prost(string, tag = "1")]
    pub user_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub user_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub level: i64,
    ///
    #[prost(string, tag = "4")]
    pub left_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub right_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub room_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioRoomSeatUser {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub mute_audio: bool,
    ///
    #[prost(string, tag = "5")]
    pub send_gift_num: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub receive_gift_num: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub connect_status: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuditRoomSeatInfo {
    ///
    #[prost(int64, tag = "1")]
    pub seat_index: i64,
    ///
    #[prost(bool, tag = "2")]
    pub mute_audio: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub user: ::core::option::Option<AudioRoomSeatUser>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Author {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub rank: i32,
    ///
    #[prost(string, tag = "4")]
    pub avatar: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockInfo {
    ///
    #[prost(string, tag = "1")]
    pub notice: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub end_time: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Combo {
    ///
    #[prost(message, optional, tag = "1")]
    pub author: ::core::option::Option<Author>,
    ///
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub treasure: ::core::option::Option<Treasure>,
    ///
    #[prost(message, optional, tag = "4")]
    pub style: ::core::option::Option<ComboStyle>,
    ///
    #[prost(string, tag = "5")]
    pub combo_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, repeated, tag = "6")]
    pub target_mids: ::prost::alloc::vec::Vec<i64>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComboStyle {
    ///
    #[prost(string, tag = "1")]
    pub bg_color_start: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub bg_color_end: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub gift_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub name_color: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub gift_num_size: i32,
    ///
    #[prost(int64, tag = "6")]
    pub duration: i64,
    ///
    #[prost(int64, tag = "7")]
    pub period: i64,
    ///
    #[prost(string, tag = "8")]
    pub bg_color_center: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub gift_num_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmEventReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<DmItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmEventReplyI18n {
    ///
    #[prost(map = "string, message", tag = "1")]
    pub items_i18_n: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        DmEventReply,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmItem {
    ///
    #[prost(enumeration = "DmType", tag = "1")]
    pub cmd: i32,
    ///
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<Author>,
    ///
    #[prost(int64, tag = "4")]
    pub room_i_d: i64,
    ///
    #[prost(int64, tag = "5")]
    pub delay: i64,
    ///
    #[prost(int64, tag = "6")]
    pub c_time: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub reply_to: ::core::option::Option<Author>,
    ///
    #[prost(message, optional, tag = "8")]
    pub style: ::core::option::Option<Style>,
    ///
    #[prost(message, optional, tag = "9")]
    pub sticker: ::core::option::Option<Sticker>,
    ///
    #[prost(message, optional, tag = "10")]
    pub top_user: ::core::option::Option<TopUser>,
    ///
    #[prost(message, repeated, tag = "11")]
    pub message_list: ::prost::alloc::vec::Vec<MessageItem>,
    ///
    #[prost(message, repeated, tag = "12")]
    pub combos: ::prost::alloc::vec::Vec<Combo>,
    ///
    #[prost(string, tag = "13")]
    pub msg_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub live_key: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "15")]
    pub popup_info: ::core::option::Option<PopupInfo>,
    ///
    #[prost(message, optional, tag = "16")]
    pub block_info: ::core::option::Option<BlockInfo>,
    ///
    #[prost(message, optional, tag = "17")]
    pub likes: ::core::option::Option<Likes>,
    ///
    #[prost(message, optional, tag = "18")]
    pub recharge_bar_info: ::core::option::Option<RechargeBarInfo>,
    ///
    #[prost(message, optional, tag = "19")]
    pub audio_cmd_msg: ::core::option::Option<AudioCmdMsg>,
    ///
    #[prost(message, optional, tag = "20")]
    pub global_gift_broadcast: ::core::option::Option<GlobalGiftBroadcastMsg>,
    ///
    #[prost(message, optional, tag = "21")]
    pub audio_level_up_msg: ::core::option::Option<AudioLevelUpMsg>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalGiftBroadcastMsg {
    ///
    #[prost(string, tag = "1")]
    pub giver_avatar: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub giver_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub giver_id: i64,
    ///
    #[prost(string, tag = "4")]
    pub receiver_avatar: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub receiver_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub receiver_id: i64,
    ///
    #[prost(string, tag = "7")]
    pub action_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub treasure_number: i64,
    ///
    #[prost(string, tag = "9")]
    pub treasure_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub treasure_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "11")]
    pub room_id: i64,
    ///
    #[prost(string, tag = "12")]
    pub left_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub right_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub bg_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Likes {
    ///
    #[prost(int64, tag = "1")]
    pub number: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageItem {
    ///
    #[prost(enumeration = "MessageItemType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub bold: bool,
    ///
    #[prost(string, tag = "5")]
    pub icon_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub icon_url: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub width: i32,
    ///
    #[prost(int32, tag = "8")]
    pub height: i32,
    ///
    #[prost(string, tag = "9")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "MessageItemSubType", tag = "10")]
    pub sub_type: i32,
    ///
    #[prost(int64, tag = "11")]
    pub treasure_id: i64,
    ///
    #[prost(int64, tag = "12")]
    pub mid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgNotify {
    ///
    #[prost(enumeration = "MsgNotifyCmd", tag = "1")]
    pub cmd: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub entity: ::core::option::Option<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notify {
    ///
    #[prost(int64, tag = "1")]
    pub notify_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub card_type: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub content: ::core::option::Option<NotifyContent>,
    ///
    #[prost(message, optional, tag = "4")]
    pub rule: ::core::option::Option<NotifyRule>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyButton {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "NotifyActionType", tag = "2")]
    pub action: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyContent {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub icon_sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub button: ::core::option::Option<NotifyButton>,
    ///
    #[prost(string, tag = "9")]
    pub union_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub extra: ::core::option::Option<NotifyContentExtra>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotifyContentExtra {
    ///
    #[prost(bool, tag = "1")]
    pub multi_seasons: bool,
    ///
    #[prost(int64, tag = "2")]
    pub fav_season_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotifyPullImMsg {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub max_seq_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyRule {
    ///
    #[prost(int64, tag = "1")]
    pub show_time: i64,
    ///
    #[prost(int64, tag = "2")]
    pub show_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub show_times: i64,
    ///
    #[prost(string, repeated, tag = "4")]
    pub exempt_pages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopupInfo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub popup_info_list: ::prost::alloc::vec::Vec<PopupInfoItem>,
    ///
    #[prost(int64, tag = "2")]
    pub duration: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopupInfoItem {
    ///
    #[prost(enumeration = "PopupItemType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(enumeration = "PopupItemPosition", tag = "2")]
    pub positon: i32,
    ///
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub bold: bool,
    ///
    #[prost(string, tag = "6")]
    pub icon_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub icon_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub width: i64,
    ///
    #[prost(int64, tag = "9")]
    pub height: i64,
    ///
    #[prost(string, tag = "10")]
    pub bg_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RechargeBarColor {
    ///
    #[prost(string, tag = "1")]
    pub content_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub gradient_color_start: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub gradient_color_end: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RechargeBarInfo {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub level: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub color: ::core::option::Option<RechargeBarColor>,
    ///
    #[prost(message, optional, tag = "5")]
    pub notice: ::core::option::Option<RechargeBarNotice>,
    ///
    #[prost(string, tag = "6")]
    pub target_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub current_point: i64,
    ///
    #[prost(int64, tag = "8")]
    pub min_point: i64,
    ///
    #[prost(int64, tag = "9")]
    pub max_point: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RechargeBarNotice {
    ///
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub delay: i64,
    ///
    #[prost(int64, tag = "3")]
    pub duration: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sticker {
    ///
    #[prost(int64, tag = "1")]
    pub i_d: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub number: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Style {
    ///
    #[prost(string, tag = "1")]
    pub name_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub content_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub is_bold: bool,
    ///
    #[prost(bool, tag = "5")]
    pub play_area_hidden: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopUser {
    ///
    #[prost(string, tag = "1")]
    pub paid_user_num: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub users: ::prost::alloc::vec::Vec<User>,
    ///
    #[prost(int64, tag = "3")]
    pub online_user_num: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Treasure {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub number: i64,
    ///
    #[prost(int64, tag = "5")]
    pub stars: i64,
    ///
    #[prost(message, optional, tag = "6")]
    pub animation: ::core::option::Option<Animation>,
    ///
    #[prost(int64, tag = "7")]
    pub animation_type: i64,
    ///
    #[prost(message, repeated, tag = "8")]
    pub animation_list: ::prost::alloc::vec::Vec<Animation>,
    ///
    #[prost(string, tag = "9")]
    pub flow_icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub score: i64,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AudioCmdType {
    ///
    Default = 0,
    ///
    AcceptApply = 1,
    ///
    Invitation = 2,
    ///
    RejectInvitation = 3,
    ///
    SetRoomInfo = 4,
    ///
    SetApplyCount = 5,
    ///
    SetSeatInfo = 6,
    ///
    SetSeatMute = 7,
    ///
    DownSeat = 8,
    ///
    RejectApply = 9,
    ///
    ForceLeave = 10,
    ///
    SetContribution = 11,
    ///
    SetBlacklist = 12,
}
impl AudioCmdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "AudioCmdTypeDefault",
            Self::AcceptApply => "AudioCmdTypeAcceptApply",
            Self::Invitation => "AudioCmdTypeInvitation",
            Self::RejectInvitation => "AudioCmdTypeRejectInvitation",
            Self::SetRoomInfo => "AudioCmdTypeSetRoomInfo",
            Self::SetApplyCount => "AudioCmdTypeSetApplyCount",
            Self::SetSeatInfo => "AudioCmdTypeSetSeatInfo",
            Self::SetSeatMute => "AudioCmdTypeSetSeatMute",
            Self::DownSeat => "AudioCmdTypeDownSeat",
            Self::RejectApply => "AudioCmdTypeRejectApply",
            Self::ForceLeave => "AudioCmdTypeForceLeave",
            Self::SetContribution => "AudioCmdTypeSetContribution",
            Self::SetBlacklist => "AudioCmdTypeSetBlacklist",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AudioCmdTypeDefault" => Some(Self::Default),
            "AudioCmdTypeAcceptApply" => Some(Self::AcceptApply),
            "AudioCmdTypeInvitation" => Some(Self::Invitation),
            "AudioCmdTypeRejectInvitation" => Some(Self::RejectInvitation),
            "AudioCmdTypeSetRoomInfo" => Some(Self::SetRoomInfo),
            "AudioCmdTypeSetApplyCount" => Some(Self::SetApplyCount),
            "AudioCmdTypeSetSeatInfo" => Some(Self::SetSeatInfo),
            "AudioCmdTypeSetSeatMute" => Some(Self::SetSeatMute),
            "AudioCmdTypeDownSeat" => Some(Self::DownSeat),
            "AudioCmdTypeRejectApply" => Some(Self::RejectApply),
            "AudioCmdTypeForceLeave" => Some(Self::ForceLeave),
            "AudioCmdTypeSetContribution" => Some(Self::SetContribution),
            "AudioCmdTypeSetBlacklist" => Some(Self::SetBlacklist),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DmType {
    ///
    DefaultType = 0,
    ///
    EnterRoom = 1,
    ///
    LiveOpen = 2,
    ///
    LiveClose = 3,
    ///
    Reply = 4,
    ///
    TreasureSticker = 5,
    ///
    RoomTopUser = 6,
    ///
    ActionMsg = 7,
    ///
    ComboMsg = 8,
    ///
    LiveKeyChange = 9,
    ///
    MuteMsg = 10,
    ///
    WarnMsg = 11,
    ///
    PopupMsg = 12,
    ///
    BlockMsg = 13,
    ///
    LikesMsg = 14,
    ///
    UltimatePrizeMsg = 15,
    ///
    RechargeBarMsg = 16,
    ///
    AudioCmd = 17,
    ///
    AudioLevelUp = 18,
    ///
    Announcement = 19,
    ///
    GlobalGiftBroadcast = 20,
    ///
    PremiumEntranceMsg = 21,
}
impl DmType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultType => "DefaultType",
            Self::EnterRoom => "EnterRoom",
            Self::LiveOpen => "LiveOpen",
            Self::LiveClose => "LiveClose",
            Self::Reply => "Reply",
            Self::TreasureSticker => "TreasureSticker",
            Self::RoomTopUser => "RoomTopUser",
            Self::ActionMsg => "ActionMsg",
            Self::ComboMsg => "ComboMsg",
            Self::LiveKeyChange => "LiveKeyChange",
            Self::MuteMsg => "MuteMsg",
            Self::WarnMsg => "WarnMsg",
            Self::PopupMsg => "PopupMsg",
            Self::BlockMsg => "BlockMsg",
            Self::LikesMsg => "LikesMsg",
            Self::UltimatePrizeMsg => "UltimatePrizeMsg",
            Self::RechargeBarMsg => "RechargeBarMsg",
            Self::AudioCmd => "AudioCmd",
            Self::AudioLevelUp => "AudioLevelUp",
            Self::Announcement => "Announcement",
            Self::GlobalGiftBroadcast => "GlobalGiftBroadcast",
            Self::PremiumEntranceMsg => "PremiumEntranceMsg",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DefaultType" => Some(Self::DefaultType),
            "EnterRoom" => Some(Self::EnterRoom),
            "LiveOpen" => Some(Self::LiveOpen),
            "LiveClose" => Some(Self::LiveClose),
            "Reply" => Some(Self::Reply),
            "TreasureSticker" => Some(Self::TreasureSticker),
            "RoomTopUser" => Some(Self::RoomTopUser),
            "ActionMsg" => Some(Self::ActionMsg),
            "ComboMsg" => Some(Self::ComboMsg),
            "LiveKeyChange" => Some(Self::LiveKeyChange),
            "MuteMsg" => Some(Self::MuteMsg),
            "WarnMsg" => Some(Self::WarnMsg),
            "PopupMsg" => Some(Self::PopupMsg),
            "BlockMsg" => Some(Self::BlockMsg),
            "LikesMsg" => Some(Self::LikesMsg),
            "UltimatePrizeMsg" => Some(Self::UltimatePrizeMsg),
            "RechargeBarMsg" => Some(Self::RechargeBarMsg),
            "AudioCmd" => Some(Self::AudioCmd),
            "AudioLevelUp" => Some(Self::AudioLevelUp),
            "Announcement" => Some(Self::Announcement),
            "GlobalGiftBroadcast" => Some(Self::GlobalGiftBroadcast),
            "PremiumEntranceMsg" => Some(Self::PremiumEntranceMsg),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageItemSubType {
    ///
    DefaultSubType = 0,
    ///
    Name = 1,
    ///
    Gift = 2,
    ///
    GiftNum = 3,
    ///
    GiftIcon = 4,
    ///
    NewLine = 5,
    ///
    AudioLevelIcon = 6,
}
impl MessageItemSubType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultSubType => "DefaultSubType",
            Self::Name => "Name",
            Self::Gift => "Gift",
            Self::GiftNum => "GiftNum",
            Self::GiftIcon => "GiftIcon",
            Self::NewLine => "NewLine",
            Self::AudioLevelIcon => "AudioLevelIcon",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DefaultSubType" => Some(Self::DefaultSubType),
            "Name" => Some(Self::Name),
            "Gift" => Some(Self::Gift),
            "GiftNum" => Some(Self::GiftNum),
            "GiftIcon" => Some(Self::GiftIcon),
            "NewLine" => Some(Self::NewLine),
            "AudioLevelIcon" => Some(Self::AudioLevelIcon),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageItemType {
    ///
    Default = 0,
    ///
    Text = 1,
    ///
    Icon = 2,
}
impl MessageItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "Default",
            Self::Text => "Text",
            Self::Icon => "Icon",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Default" => Some(Self::Default),
            "Text" => Some(Self::Text),
            "Icon" => Some(Self::Icon),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MsgNotifyCmd {
    ///
    Unspecified = 0,
    ///
    PullIm = 1,
}
impl MsgNotifyCmd {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MSG_NOTIFY_CMD_UNSPECIFIED",
            Self::PullIm => "MSG_NOTIFY_CMD_PULL_IM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MSG_NOTIFY_CMD_UNSPECIFIED" => Some(Self::Unspecified),
            "MSG_NOTIFY_CMD_PULL_IM" => Some(Self::PullIm),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotifyActionType {
    ///
    DefaultActionType = 0,
    ///
    JumpActionType = 1,
    ///
    FavActionType = 2,
}
impl NotifyActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultActionType => "DefaultActionType",
            Self::JumpActionType => "JumpActionType",
            Self::FavActionType => "FavActionType",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DefaultActionType" => Some(Self::DefaultActionType),
            "JumpActionType" => Some(Self::JumpActionType),
            "FavActionType" => Some(Self::FavActionType),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PopupItemPosition {
    ///
    Default = 0,
    ///
    Title = 1,
    ///
    Content = 2,
}
impl PopupItemPosition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "PopupItemPositionDefault",
            Self::Title => "PopupItemPositionTitle",
            Self::Content => "PopupItemPositionContent",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PopupItemPositionDefault" => Some(Self::Default),
            "PopupItemPositionTitle" => Some(Self::Title),
            "PopupItemPositionContent" => Some(Self::Content),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PopupItemType {
    ///
    Default = 0,
    ///
    Text = 1,
    ///
    Icon = 2,
}
impl PopupItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "PopupItemTypeDefault",
            Self::Text => "PopupItemTypeText",
            Self::Icon => "PopupItemTypeIcon",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PopupItemTypeDefault" => Some(Self::Default),
            "PopupItemTypeText" => Some(Self::Text),
            "PopupItemTypeIcon" => Some(Self::Icon),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod app_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct AppClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AppClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AppClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AppClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn app_notify(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::Notify>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.broadcast.message.intl.App/AppNotify",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.broadcast.message.intl.App", "AppNotify"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn notify(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::MsgNotify>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.broadcast.message.intl.Msg/Notify",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.broadcast.message.intl.Msg", "Notify"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod app_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AppServer.
    #[async_trait]
    pub trait App: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn app_notify(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::Notify>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct AppServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AppServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AppServer<T>
    where
        T: App,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.broadcast.message.intl.App/AppNotify" => {
                    #[allow(non_camel_case_types)]
                    struct AppNotifySvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<()> for AppNotifySvc<T> {
                        type Response = super::Notify;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::app_notify(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AppNotifySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AppServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.broadcast.message.intl.App";
    impl<T> tonic::server::NamedService for AppServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod msg_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MsgServer.
    #[async_trait]
    pub trait Msg: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn notify(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::MsgNotify>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct MsgServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MsgServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MsgServer<T>
    where
        T: Msg,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.broadcast.message.intl.Msg/Notify" => {
                    #[allow(non_camel_case_types)]
                    struct NotifySvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<()> for NotifySvc<T> {
                        type Response = super::MsgNotify;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::notify(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NotifySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MsgServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.broadcast.message.intl.Msg";
    impl<T> tonic::server::NamedService for MsgServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}

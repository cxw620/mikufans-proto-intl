// This file is @generated by prost-build.
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityBubbleReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityBubbleResp {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub oid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdCreative {
    ///
    #[prost(string, tag = "1")]
    pub creative_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "AdMaterialType", tag = "5")]
    pub material_type: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub video: ::core::option::Option<AdVideoMedia>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdEvent {
    ///
    #[prost(string, tag = "1")]
    pub event_id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "AdEventType", tag = "2")]
    pub event_type: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub app_info: ::core::option::Option<AppInfo>,
    ///
    #[prost(enumeration = "Network", tag = "4")]
    pub network: i32,
    ///
    #[prost(int64, tag = "5")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub ctime: i64,
    ///
    #[prost(string, tag = "7")]
    pub order_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub line_item_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub creative_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "98")]
    pub payload: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, string", tag = "99")]
    pub extended_fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdEventPayload {
    ///
    #[prost(string, tag = "1")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub position_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdVideoMedia {
    ///
    #[prost(string, tag = "1")]
    pub play_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub width: i64,
    ///
    #[prost(int64, tag = "3")]
    pub height: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnimeScheduleReq {
    ///
    #[prost(int64, tag = "1")]
    pub date: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnimeScheduleResp {
    ///
    #[prost(string, tag = "1")]
    pub page_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub current_time: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub schedules: ::prost::alloc::vec::Vec<ScheduleSchedule>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub seasons: ::prost::alloc::vec::Vec<ScheduleSeason>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppInfo {
    ///
    #[prost(int32, tag = "1")]
    pub app_id: i32,
    ///
    #[prost(int32, tag = "2")]
    pub platform: i32,
    ///
    #[prost(string, tag = "3")]
    pub buvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub chid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub brand: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub device_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub model: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub osver: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub version_code: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppNotifyReportReq {
    ///
    #[prost(int64, tag = "1")]
    pub notify_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub resource_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub union_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadgeInfo {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub tag_type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BannerBadge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub bg_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Button {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardCornerMark {
    ///
    #[prost(string, tag = "1")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub left_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub image: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardStyle {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_blue: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    ///
    #[prost(int64, tag = "1")]
    pub conversation_id: i64,
    ///
    #[prost(enumeration = "ConversationType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub target: i64,
    ///
    #[prost(int64, tag = "4")]
    pub min_seq: i64,
    ///
    #[prost(int64, tag = "5")]
    pub read_seq: i64,
    ///
    #[prost(message, optional, tag = "6")]
    pub latest_msg: ::core::option::Option<Message>,
    ///
    #[prost(message, optional, tag = "99")]
    pub target_info: ::core::option::Option<UserInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversationListRequest {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationListResponse {
    ///
    #[prost(int64, tag = "1")]
    pub owner: i64,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadPageBannerSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadRewardedSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedItem {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon_night: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub need_login: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FetchHistoryMessagesRequest {
    ///
    #[prost(int64, tag = "1")]
    pub conversation_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub last_seq_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchHistoryMessagesResponse {
    ///
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(int64, tag = "3")]
    pub last_seq_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GamingSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDownloadPageBannerAdConfReq {}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDownloadPageBannerAdConfResp {
    ///
    #[prost(bool, tag = "1")]
    pub show_ad: bool,
    ///
    #[prost(int64, tag = "2")]
    pub max_show_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExposureSplashAdReq {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub item_ids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(enumeration = "SplashType", tag = "2")]
    pub splash_type: i32,
    ///
    #[prost(message, repeated, tag = "3")]
    pub item_creatives: ::prost::alloc::vec::Vec<
        get_exposure_splash_ad_req::AdItemCreative,
    >,
}
/// Nested message and enum types in `GetExposureSplashAdReq`.
pub mod get_exposure_splash_ad_req {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdItemCreative {
        ///
        #[prost(int64, tag = "1")]
        pub item_id: i64,
        ///
        #[prost(string, repeated, tag = "2")]
        pub creative_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExposureSplashAdResp {
    ///
    #[prost(message, optional, tag = "1")]
    pub ad: ::core::option::Option<SplashAd>,
    ///
    #[prost(string, tag = "2")]
    pub creative_id: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "98")]
    pub enable_realtime_report: bool,
    ///
    #[prost(string, tag = "99")]
    pub realtime_report_payload: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPremiumUpgradePanelReq {
    ///
    #[prost(enumeration = "VipUpgradePanelType", tag = "1")]
    pub panel_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub ep_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub quality_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPremiumUpgradePanelResp {
    ///
    #[prost(string, tag = "1")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub header_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub header_color_dark: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub product: ::core::option::Option<VipProduct>,
    ///
    #[prost(message, optional, tag = "7")]
    pub more: ::core::option::Option<get_premium_upgrade_panel_resp::More>,
    ///
    #[prost(message, optional, tag = "8")]
    pub button: ::core::option::Option<get_premium_upgrade_panel_resp::Button>,
}
/// Nested message and enum types in `GetPremiumUpgradePanelResp`.
pub mod get_premium_upgrade_panel_resp {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Button {
        ///
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub url: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct More {
        ///
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub url: ::prost::alloc::string::String,
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRelationReq {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRelationResp {
    ///
    #[prost(enumeration = "RelationState", tag = "1")]
    pub state: i32,
    ///
    #[prost(enumeration = "RelationState", tag = "2")]
    pub reverse_state: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSdkAdConfigReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSdkAdConfigResp {
    ///
    #[prost(bool, tag = "1")]
    pub show_ad: bool,
    ///
    #[prost(int64, tag = "2")]
    pub show_splash_interval: i64,
    ///
    #[prost(int64, tag = "3")]
    pub load_splash_timeout: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub recommend: ::core::option::Option<RecommendSdkAd>,
    ///
    #[prost(message, optional, tag = "5")]
    pub splash_hot: ::core::option::Option<SplashHotSdkAd>,
    ///
    #[prost(message, optional, tag = "6")]
    pub splash_cold: ::core::option::Option<SplashColdSdkAd>,
    ///
    #[prost(message, optional, tag = "7")]
    pub native_roll: ::core::option::Option<NativeRollSdkAd>,
    ///
    #[prost(message, optional, tag = "8")]
    pub in_stream_roll: ::core::option::Option<InStreamRollSdkAd>,
    ///
    #[prost(message, optional, tag = "9")]
    pub feed: ::core::option::Option<FeedSdkAd>,
    ///
    #[prost(message, optional, tag = "10")]
    pub gaming: ::core::option::Option<GamingSdkAd>,
    ///
    #[prost(message, optional, tag = "11")]
    pub search_result: ::core::option::Option<SearchResultSdkAd>,
    ///
    #[prost(message, optional, tag = "12")]
    pub view_rect: ::core::option::Option<ViewRectSdkAd>,
    ///
    #[prost(message, optional, tag = "13")]
    pub download_rewarded: ::core::option::Option<DownloadRewardedSdkAd>,
    ///
    #[prost(message, optional, tag = "14")]
    pub player_pause_half_screen: ::core::option::Option<PlayerPauseHalfScreenAdkAd>,
    ///
    #[prost(message, optional, tag = "15")]
    pub player_pause_full_screen: ::core::option::Option<PlayerPauseFullScreenAdkAd>,
    ///
    #[prost(message, optional, tag = "16")]
    pub switch_video_interstitial: ::core::option::Option<SwitchVideoInterstitialSdkAd>,
    ///
    #[prost(message, optional, tag = "17")]
    pub download_page_banner: ::core::option::Option<DownloadPageBannerSdkAd>,
    ///
    #[prost(message, optional, tag = "18")]
    pub mine_banner: ::core::option::Option<MineBannerSdkAd>,
    ///
    #[prost(message, optional, tag = "19")]
    pub view_rewarded: ::core::option::Option<ViewRewardedSdkAd>,
    ///
    #[prost(message, optional, tag = "20")]
    pub under_player: ::core::option::Option<UnderPlayerSdkAd>,
    ///
    #[prost(message, optional, tag = "21")]
    pub view_unlock_reward_ad: ::core::option::Option<ViewUnlockRewardAd>,
    ///
    #[prost(message, optional, tag = "22")]
    pub search_result_rect_banner: ::core::option::Option<SearchResultRectBannerSdkAd>,
    ///
    #[prost(message, optional, tag = "23")]
    pub player_overlays: ::core::option::Option<PlayerOverlaysSdkAd>,
    ///
    #[prost(message, optional, tag = "24")]
    pub search_square_rect_banner: ::core::option::Option<SearchSquareRectBannerSdkAd>,
    ///
    #[prost(message, optional, tag = "25")]
    pub in_stream_mid_post_roll: ::core::option::Option<InStreamRollMidPostSdkAd>,
    ///
    #[prost(message, optional, tag = "26")]
    pub view_rewarded_mix: ::core::option::Option<ViewRewardedMixAd>,
    ///
    #[prost(message, repeated, tag = "99")]
    pub tradplus_custom_maps: ::prost::alloc::vec::Vec<TradplusCustomMap>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSdkAdEcpmReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSdkAdEcpmResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub ecpms: ::prost::alloc::vec::Vec<SdkAdEcpm>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUid2TokenReq {
    ///
    #[prost(string, tag = "1")]
    pub hashed_email: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub hashed_phone_number: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub advertising_token: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub meta: ::core::option::Option<Uid2TokenExtra>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetViewCollectionsReq {
    ///
    #[prost(int64, tag = "1")]
    pub sid: i64,
    ///
    #[prost(enumeration = "ViewCollectionType", tag = "2")]
    pub r#type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetViewCollectionsResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub collections: ::prost::alloc::vec::Vec<OperationCollection>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetViewConfReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetViewConfResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub offline_ugc_quality_confs: ::prost::alloc::vec::Vec<ViewOfflineQualityConf>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub offline_ogv_quality_confs: ::prost::alloc::vec::Vec<ViewOfflineQualityConf>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetViewRefreshAdReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(enumeration = "ViewType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub season_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetViewRefreshAdResp {
    ///
    #[prost(message, optional, tag = "1")]
    pub pay_tips: ::core::option::Option<ViewOgvPayTipCard>,
    ///
    #[prost(message, optional, tag = "2")]
    pub under_player_ad: ::core::option::Option<UnderPlayerAdCard>,
    ///
    #[prost(message, optional, tag = "3")]
    pub recommend_ad: ::core::option::Option<RecommendAdCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageMessage {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub width: i32,
    ///
    #[prost(int32, tag = "3")]
    pub height: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InStreamRollMidPostSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
    ///
    #[prost(message, optional, tag = "3")]
    pub ad_tag_url_params: ::core::option::Option<
        in_stream_roll_mid_post_sdk_ad::AdTagUrlParams,
    >,
}
/// Nested message and enum types in `InStreamRollMidPostSDKAd`.
pub mod in_stream_roll_mid_post_sdk_ad {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdTagUrlParams {
        ///
        #[prost(map = "string, string", tag = "1")]
        pub gam: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        ///
        #[prost(map = "string, string", tag = "2")]
        pub beesads: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        ///
        #[prost(map = "string, string", tag = "3")]
        pub premiumads: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InStreamRollSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
    ///
    #[prost(message, optional, tag = "3")]
    pub ad_tag_url_params: ::core::option::Option<in_stream_roll_sdk_ad::AdTagUrlParams>,
}
/// Nested message and enum types in `InStreamRollSDKAd`.
pub mod in_stream_roll_sdk_ad {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdTagUrlParams {
        ///
        #[prost(string, tag = "1")]
        pub description_url: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub cust_params: ::prost::alloc::string::String,
        ///
        #[prost(map = "string, string", tag = "3")]
        pub gam: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        ///
        #[prost(map = "string, string", tag = "4")]
        pub beesads: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        ///
        #[prost(map = "string, string", tag = "5")]
        pub premiumads: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    ///
    #[prost(int64, tag = "1")]
    pub seq: i64,
    ///
    #[prost(enumeration = "MessageType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub send_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub recv_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub conversation_id: i64,
    ///
    #[prost(enumeration = "ConversationType", tag = "6")]
    pub conversation_type: i32,
    ///
    #[prost(string, tag = "7")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub send_time: i64,
    ///
    #[prost(message, optional, tag = "9")]
    pub send_info: ::core::option::Option<UserInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MineBannerSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NativeRollSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationCollection {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "5")]
    pub cards: ::prost::alloc::vec::Vec<OperationCollectionCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationCollectionCard {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub card_type: i32,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub views: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub duration: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub author: ::core::option::Option<operation_collection_card::Author>,
}
/// Nested message and enum types in `OperationCollectionCard`.
pub mod operation_collection_card {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Author {
        ///
        #[prost(int64, tag = "1")]
        pub mid: i64,
        ///
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub face: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "4")]
        pub uri: ::prost::alloc::string::String,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayTipButton {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerOverlaysSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerPauseFullScreenAdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerPauseHalfScreenAdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PreloadSplashAdReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreloadSplashAdResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub ads: ::prost::alloc::vec::Vec<SplashAd>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullConversationsRequest {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub conversation_ids: ::prost::alloc::vec::Vec<i64>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullConversationsResponse {
    ///
    #[prost(int64, tag = "1")]
    pub owner: i64,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PullMessagesRequest {
    ///
    #[prost(int64, tag = "1")]
    pub start_seq_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullMessagesResponse {
    ///
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(int64, tag = "3")]
    pub next_seq_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecUnlockAdListItem {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub vertical_cover: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub styles: ::prost::alloc::vec::Vec<Style>,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecUnlockAdListReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecUnlockAdListResp {
    ///
    #[prost(int64, tag = "1")]
    pub unlock_cnt: i64,
    ///
    #[prost(int64, tag = "2")]
    pub unlock_limit: i64,
    ///
    #[prost(string, tag = "3")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub rule: ::core::option::Option<RecUnlockAdListRule>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub list: ::prost::alloc::vec::Vec<RecUnlockAdListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecUnlockAdListRule {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecUnlockCntReq {}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecUnlockCntResp {
    ///
    #[prost(int64, tag = "1")]
    pub unlock_cnt: i64,
    ///
    #[prost(int64, tag = "2")]
    pub unlock_limit: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendAdCard {
    ///
    #[prost(message, optional, tag = "1")]
    pub direct_ad: ::core::option::Option<RecommendDirectAdCard>,
    ///
    #[prost(message, optional, tag = "2")]
    pub sdk_ad: ::core::option::Option<RecommendSdkAdCard>,
    ///
    #[prost(int64, tag = "3")]
    pub card_index: i64,
    ///
    #[prost(string, tag = "4")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "97")]
    pub is_stock: bool,
    ///
    #[prost(string, tag = "98")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "99")]
    pub badge: ::core::option::Option<BadgeInfo>,
    ///
    #[prost(message, repeated, tag = "100")]
    pub three_points: ::prost::alloc::vec::Vec<ThreePoints>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendDirectAdCard {
    ///
    #[prost(int64, tag = "1")]
    pub order_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub item_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub link_uri: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "6")]
    pub enable_realtime_report: bool,
    ///
    #[prost(string, tag = "7")]
    pub realtime_report_payload: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub creative_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendSdkAdCard {
    ///
    #[prost(string, tag = "1")]
    pub ad_scene_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdkAdEcpm {
    ///
    #[prost(string, tag = "1")]
    pub ad_unit_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub network_id: i64,
    ///
    #[prost(double, tag = "3")]
    pub ecpm: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleCard {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub styles: ::prost::alloc::vec::Vec<CardStyle>,
    ///
    #[prost(bool, tag = "7")]
    pub is_favorited: bool,
    ///
    #[prost(string, tag = "8")]
    pub release_info: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub release_time: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleSchedule {
    ///
    #[prost(int64, tag = "1")]
    pub day: i64,
    ///
    #[prost(int64, tag = "2")]
    pub day_of_week: i64,
    ///
    #[prost(bool, tag = "3")]
    pub is_today: bool,
    ///
    #[prost(bool, tag = "4")]
    pub is_coming: bool,
    ///
    #[prost(message, repeated, tag = "5")]
    pub cards: ::prost::alloc::vec::Vec<ScheduleCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleSeason {
    ///
    #[prost(int64, tag = "1")]
    pub season_year: i64,
    ///
    #[prost(string, tag = "2")]
    pub season_title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub cards: ::prost::alloc::vec::Vec<ScheduleCard>,
    ///
    #[prost(int64, tag = "4")]
    pub quarter: i64,
    ///
    #[prost(string, tag = "5")]
    pub note: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResultRectBannerSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResultSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareBanner {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<SearchSquareBannerItem>,
    ///
    #[prost(string, tag = "2")]
    pub track_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareBannerItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub resource_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub task_id: i64,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<BannerBadge>,
    ///
    #[prost(string, tag = "7")]
    pub creative_id: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "98")]
    pub enable_realtime_report: bool,
    ///
    #[prost(string, tag = "99")]
    pub realtime_report_payload: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareCardLive {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<SearchSquareCardLiveItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareCardLiveItem {
    ///
    #[prost(int64, tag = "1")]
    pub rid: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub views: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub author: ::core::option::Option<SearchAuthor>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareCardOgv {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<SearchSquareCardOgvItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareCardOgvItem {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "6")]
    pub styles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, optional, tag = "7")]
    pub card_corner_mark: ::core::option::Option<CardCornerMark>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareCardUgc {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<SearchSquareCardUgcItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareCardUgcItem {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub duration: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub views: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub author: ::core::option::Option<SearchAuthor>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareChannel {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<SearchSquareChannelItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareChannelItem {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub resource_id: i64,
    ///
    #[prost(string, tag = "6")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareDynamicCard {
    ///
    #[prost(string, tag = "1")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "search_square_dynamic_card::Card", tags = "2, 3, 4")]
    pub card: ::core::option::Option<search_square_dynamic_card::Card>,
}
/// Nested message and enum types in `SearchSquareDynamicCard`.
pub mod search_square_dynamic_card {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Card {
        ///
        #[prost(message, tag = "2")]
        Ogv(super::SearchSquareCardOgv),
        ///
        #[prost(message, tag = "3")]
        Ugc(super::SearchSquareCardUgc),
        ///
        #[prost(message, tag = "4")]
        Live(super::SearchSquareCardLive),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareRectBannerAd {
    ///
    #[prost(string, tag = "1")]
    pub ad_scene_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub max_show_count: i64,
    ///
    #[prost(int64, tag = "3")]
    pub show_interval: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareRectBannerSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchSquareV2Req {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchSquareV2Resp {
    ///
    #[prost(message, optional, tag = "1")]
    pub banner: ::core::option::Option<SearchSquareBanner>,
    ///
    #[prost(message, optional, tag = "2")]
    pub channel: ::core::option::Option<SearchSquareChannel>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub dynamic_cards: ::prost::alloc::vec::Vec<SearchSquareDynamicCard>,
    ///
    #[prost(message, optional, tag = "4")]
    pub rect_banner_ad: ::core::option::Option<SearchSquareRectBannerAd>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageRequest {
    ///
    #[prost(enumeration = "MessageType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub send_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub recv_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub conversation_id: i64,
    ///
    #[prost(enumeration = "ConversationType", tag = "5")]
    pub conversation_type: i32,
    ///
    #[prost(string, tag = "6")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub client_seq_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageResponse {
    ///
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetConversationSeqRequest {
    ///
    #[prost(int64, tag = "1")]
    pub conversation_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub read_seq: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetConversationSeqResponse {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplashAd {
    ///
    #[prost(int64, tag = "1")]
    pub item_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub order_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub skip_text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub show_duration: i64,
    ///
    #[prost(int64, tag = "8")]
    pub show_interval: i64,
    ///
    #[prost(int64, tag = "9")]
    pub on_time: i64,
    ///
    #[prost(int64, tag = "10")]
    pub off_time: i64,
    ///
    #[prost(enumeration = "AdMaterialType", tag = "11")]
    pub material_type: i32,
    ///
    #[prost(message, optional, tag = "12")]
    pub video: ::core::option::Option<AdVideoMedia>,
    ///
    #[prost(string, tag = "13")]
    pub item_md5: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "14")]
    pub show_ad_badge: bool,
    ///
    #[prost(message, repeated, tag = "15")]
    pub creatives: ::prost::alloc::vec::Vec<AdCreative>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplashColdSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplashHotSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartConversationRequest {
    ///
    #[prost(enumeration = "ConversationType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub target: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartConversationResponse {
    ///
    #[prost(message, optional, tag = "1")]
    pub conversation: ::core::option::Option<Conversation>,
    ///
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<UserInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Style {
    ///
    #[prost(int64, tag = "1")]
    pub style_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub style_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub style_icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitUserInfoCollectionReq {
    ///
    #[prost(enumeration = "submit_user_info_collection_req::Action", tag = "1")]
    pub action: i32,
    ///
    #[prost(string, tag = "2")]
    pub birthday: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub gender: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SubmitUserInfoCollectionReq`.
pub mod submit_user_info_collection_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        ///
        Cancel = 0,
        ///
        Confirm = 1,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Cancel => "CANCEL",
                Self::Confirm => "CONFIRM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CANCEL" => Some(Self::Cancel),
                "CONFIRM" => Some(Self::Confirm),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitUserInfoCollectionResp {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchVideoInterstitialSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
    ///
    #[prost(int64, tag = "3")]
    pub ad_init_delay_time: i64,
    ///
    #[prost(int64, tag = "4")]
    pub ad_daily_v_v: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextMessage {
    ///
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePoints {
    ///
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub min_build: i64,
    ///
    #[prost(message, repeated, tag = "4")]
    pub items: ::prost::alloc::vec::Vec<FeedItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopOn {
    ///
    #[prost(string, tag = "1")]
    pub ad_unit_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tradplus {
    ///
    #[prost(string, tag = "1")]
    pub ad_unit_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradplusCustomMap {
    ///
    #[prost(string, tag = "1")]
    pub ad_unit_id: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, string", tag = "2")]
    pub custom_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uid2Token {
    ///
    #[prost(string, tag = "1")]
    pub advertising_token: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub refresh_from_duration: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub meta: ::core::option::Option<Uid2TokenExtra>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uid2TokenExtra {
    ///
    #[prost(string, tag = "1")]
    pub refresh_token: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub refresh_response_key: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub advertising_token_base: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub refresh_from: i64,
    ///
    #[prost(int64, tag = "5")]
    pub refresh_expires: i64,
    ///
    #[prost(int64, tag = "6")]
    pub identity_expires: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnderPlayerAdCard {
    ///
    #[prost(int64, tag = "1")]
    pub show_after_pay_tip_count: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub direct_ad: ::core::option::Option<UnderPlayerDirectAdCard>,
    ///
    #[prost(message, optional, tag = "3")]
    pub sdk_ad: ::core::option::Option<UnderPlayerSdkAdCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnderPlayerDirectAdCard {
    ///
    #[prost(int64, tag = "1")]
    pub order_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub item_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub enable_realtime_report: bool,
    ///
    #[prost(string, tag = "6")]
    pub realtime_report_payload: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub is_stock: bool,
    ///
    #[prost(string, tag = "9")]
    pub creative_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnderPlayerSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnderPlayerSdkAdCard {
    ///
    #[prost(string, tag = "1")]
    pub ad_scene_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub max_show_count: i64,
    ///
    #[prost(int64, tag = "3")]
    pub show_after_pay_tip_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockPanelReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(enumeration = "ViewType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "3")]
    pub market: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockPanelResp {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub products: ::prost::alloc::vec::Vec<ViewProduct>,
    ///
    #[prost(message, optional, tag = "4")]
    pub button: ::core::option::Option<Button>,
    ///
    #[prost(int64, tag = "5")]
    pub user_stars: i64,
    ///
    #[prost(enumeration = "PanelType", tag = "6")]
    pub r#type: i32,
    ///
    #[prost(message, repeated, tag = "7")]
    pub bottom_text: ::prost::alloc::vec::Vec<Button>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(enumeration = "ViewType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub stars: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserInfoCollectionPopUpReq {}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserInfoCollectionPopUpResp {
    ///
    #[prost(bool, tag = "1")]
    pub show_popup: bool,
    ///
    #[prost(bool, tag = "2")]
    pub show_birthday: bool,
    ///
    #[prost(bool, tag = "3")]
    pub show_gender: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserLoginInfoReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserLoginInfoResp {
    ///
    #[prost(string, tag = "1")]
    pub buvid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub auth_type: i32,
    ///
    #[prost(int32, repeated, tag = "3")]
    pub login_options: ::prost::alloc::vec::Vec<i32>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewAdConfirmReq {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewAdConfirmResp {}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewAdUnlockPreCheckReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(enumeration = "ViewType", tag = "2")]
    pub r#type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewAdUnlockPreCheckResp {
    ///
    #[prost(enumeration = "UnlockStatus", tag = "1")]
    pub status: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub main_button: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub close_button: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewAdUnlockReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(enumeration = "ViewType", tag = "2")]
    pub r#type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewAdUnlockResp {
    ///
    #[prost(string, tag = "1")]
    pub success_toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewOfflineQualityConf {
    ///
    #[prost(enumeration = "VipBenefitType", tag = "1")]
    pub vip_benefit_type: i32,
    ///
    #[prost(int32, tag = "2")]
    pub max_quality: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewOgvPayTipCard {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub tip_tag: ::core::option::Option<ViewTag>,
    ///
    #[prost(int64, tag = "8")]
    pub goto_type: i64,
    ///
    #[prost(int64, tag = "9")]
    pub product_id: i64,
    ///
    #[prost(int64, tag = "10")]
    pub product_type: i64,
    ///
    #[prost(string, tag = "11")]
    pub fee_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub price: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub origin_price: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub product_name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "15")]
    pub button: ::core::option::Option<PayTipButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewProduct {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub stars: i64,
    ///
    #[prost(string, tag = "3")]
    pub product_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub fee_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub price: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub biz_id: i64,
    ///
    #[prost(string, tag = "7")]
    pub discount: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewRectSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewRewardedMixAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewRewardedSdkAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewTag {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewUnlockRewardAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub top_on: ::core::option::Option<TopOn>,
    ///
    #[prost(message, optional, tag = "2")]
    pub tradplus: ::core::option::Option<Tradplus>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipAddition {
    ///
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<vip_addition::VipAdditionHeader>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<vip_addition::VipAdditionItem>,
}
/// Nested message and enum types in `VipAddition`.
pub mod vip_addition {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VipAdditionHeader {
        ///
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VipAdditionItem {
        ///
        #[prost(int64, tag = "1")]
        pub addition_id: i64,
        ///
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub icon: ::prost::alloc::string::String,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipProduct {
    ///
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub display_type: i64,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub product_code: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub product_dist_msg: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub product_id: i64,
    ///
    #[prost(int64, tag = "7")]
    pub product_type: i64,
    ///
    #[prost(string, tag = "8")]
    pub fee_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub origin_price: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub price: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub offer_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "12")]
    pub addition: ::core::option::Option<VipAddition>,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdEventType {
    ///
    EventTypeUnknown = 0,
    ///
    EventTypeClick = 1,
    ///
    EventTypeExposure = 2,
}
impl AdEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EventTypeUnknown => "EVENT_TYPE_UNKNOWN",
            Self::EventTypeClick => "EVENT_TYPE_CLICK",
            Self::EventTypeExposure => "EVENT_TYPE_EXPOSURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNKNOWN" => Some(Self::EventTypeUnknown),
            "EVENT_TYPE_CLICK" => Some(Self::EventTypeClick),
            "EVENT_TYPE_EXPOSURE" => Some(Self::EventTypeExposure),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdMaterialType {
    ///
    MaterialTypeUnspecified = 0,
    ///
    MaterialTypeImage = 1,
    ///
    MaterialTypeVideo = 2,
}
impl AdMaterialType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MaterialTypeUnspecified => "MATERIAL_TYPE_UNSPECIFIED",
            Self::MaterialTypeImage => "MATERIAL_TYPE_IMAGE",
            Self::MaterialTypeVideo => "MATERIAL_TYPE_VIDEO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATERIAL_TYPE_UNSPECIFIED" => Some(Self::MaterialTypeUnspecified),
            "MATERIAL_TYPE_IMAGE" => Some(Self::MaterialTypeImage),
            "MATERIAL_TYPE_VIDEO" => Some(Self::MaterialTypeVideo),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConversationType {
    ///
    Unspecified = 0,
    ///
    Single = 1,
}
impl ConversationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONVERSATION_TYPE_UNSPECIFIED",
            Self::Single => "CONVERSATION_TYPE_SINGLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONVERSATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONVERSATION_TYPE_SINGLE" => Some(Self::Single),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageType {
    ///
    Unspecified = 0,
    ///
    Txt = 1,
    ///
    Img = 2,
}
impl MessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MESSAGE_TYPE_UNSPECIFIED",
            Self::Txt => "MESSAGE_TYPE_TXT",
            Self::Img => "MESSAGE_TYPE_IMG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MESSAGE_TYPE_TXT" => Some(Self::Txt),
            "MESSAGE_TYPE_IMG" => Some(Self::Img),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Network {
    ///
    Unknown = 0,
    ///
    Wifi = 1,
    ///
    Cellular = 2,
    ///
    Offline = 3,
    ///
    Othernet = 4,
    ///
    Ethernet = 5,
}
impl Network {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Wifi => "WIFI",
            Self::Cellular => "CELLULAR",
            Self::Offline => "OFFLINE",
            Self::Othernet => "OTHERNET",
            Self::Ethernet => "ETHERNET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "WIFI" => Some(Self::Wifi),
            "CELLULAR" => Some(Self::Cellular),
            "OFFLINE" => Some(Self::Offline),
            "OTHERNET" => Some(Self::Othernet),
            "ETHERNET" => Some(Self::Ethernet),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PanelType {
    ///
    PanelUnknown = 0,
    ///
    PanelBuystars = 1,
    ///
    PanelUnlock = 2,
    ///
    PanelUnlocked = 3,
}
impl PanelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PanelUnknown => "PANEL_UNKNOWN",
            Self::PanelBuystars => "PANEL_BUYSTARS",
            Self::PanelUnlock => "PANEL_UNLOCK",
            Self::PanelUnlocked => "PANEL_UNLOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PANEL_UNKNOWN" => Some(Self::PanelUnknown),
            "PANEL_BUYSTARS" => Some(Self::PanelBuystars),
            "PANEL_UNLOCK" => Some(Self::PanelUnlock),
            "PANEL_UNLOCKED" => Some(Self::PanelUnlocked),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RelationState {
    ///
    Unspecified = 0,
    ///
    Followed = 1,
    ///
    Blocked = 2,
}
impl RelationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RELATION_STATE_UNSPECIFIED",
            Self::Followed => "RELATION_STATE_FOLLOWED",
            Self::Blocked => "RELATION_STATE_BLOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "RELATION_STATE_FOLLOWED" => Some(Self::Followed),
            "RELATION_STATE_BLOCKED" => Some(Self::Blocked),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SplashType {
    ///
    Unspecified = 0,
    ///
    Hot = 1,
    ///
    Cold = 2,
}
impl SplashType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SPLASH_TYPE_UNSPECIFIED",
            Self::Hot => "SPLASH_TYPE_HOT",
            Self::Cold => "SPLASH_TYPE_COLD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPLASH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SPLASH_TYPE_HOT" => Some(Self::Hot),
            "SPLASH_TYPE_COLD" => Some(Self::Cold),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnlockStatus {
    ///
    Unknown = 0,
    ///
    AllowUnlock = 1,
    ///
    UnlockLimit = 2,
    ///
    Unlocked = 3,
}
impl UnlockStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNLOCK_STATUS_UNKNOWN",
            Self::AllowUnlock => "UNLOCK_STATUS_ALLOW_UNLOCK",
            Self::UnlockLimit => "UNLOCK_STATUS_UNLOCK_LIMIT",
            Self::Unlocked => "UNLOCK_STATUS_UNLOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNLOCK_STATUS_UNKNOWN" => Some(Self::Unknown),
            "UNLOCK_STATUS_ALLOW_UNLOCK" => Some(Self::AllowUnlock),
            "UNLOCK_STATUS_UNLOCK_LIMIT" => Some(Self::UnlockLimit),
            "UNLOCK_STATUS_UNLOCKED" => Some(Self::Unlocked),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViewCollectionType {
    ///
    Unknown = 0,
    ///
    Ogv = 1,
    ///
    Ugc = 2,
}
impl ViewCollectionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "VIEW_COLLECTION_TYPE_UNKNOWN",
            Self::Ogv => "VIEW_COLLECTION_TYPE_OGV",
            Self::Ugc => "VIEW_COLLECTION_TYPE_UGC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIEW_COLLECTION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "VIEW_COLLECTION_TYPE_OGV" => Some(Self::Ogv),
            "VIEW_COLLECTION_TYPE_UGC" => Some(Self::Ugc),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViewType {
    ///
    Unknown = 0,
    ///
    Ugc = 1,
    ///
    Ogv = 2,
}
impl ViewType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "VIEW_TYPE_UNKNOWN",
            Self::Ugc => "VIEW_TYPE_UGC",
            Self::Ogv => "VIEW_TYPE_OGV",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIEW_TYPE_UNKNOWN" => Some(Self::Unknown),
            "VIEW_TYPE_UGC" => Some(Self::Ugc),
            "VIEW_TYPE_OGV" => Some(Self::Ogv),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VipBenefitType {
    ///
    Unknown = 0,
    ///
    Standard = 1,
    ///
    Basic = 2,
}
impl VipBenefitType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "VIP_BENEFIT_TYPE_UNKNOWN",
            Self::Standard => "VIP_BENEFIT_TYPE_STANDARD",
            Self::Basic => "VIP_BENEFIT_TYPE_BASIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIP_BENEFIT_TYPE_UNKNOWN" => Some(Self::Unknown),
            "VIP_BENEFIT_TYPE_STANDARD" => Some(Self::Standard),
            "VIP_BENEFIT_TYPE_BASIC" => Some(Self::Basic),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VipUpgradePanelType {
    ///
    Unknown = 0,
    ///
    Quality = 1,
    ///
    Download = 2,
    ///
    Switch = 3,
    ///
    Preview = 4,
}
impl VipUpgradePanelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "VIP_UPGRADE_PANEL_TYPE_UNKNOWN",
            Self::Quality => "VIP_UPGRADE_PANEL_TYPE_QUALITY",
            Self::Download => "VIP_UPGRADE_PANEL_TYPE_DOWNLOAD",
            Self::Switch => "VIP_UPGRADE_PANEL_TYPE_SWITCH",
            Self::Preview => "VIP_UPGRADE_PANEL_TYPE_PREVIEW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIP_UPGRADE_PANEL_TYPE_UNKNOWN" => Some(Self::Unknown),
            "VIP_UPGRADE_PANEL_TYPE_QUALITY" => Some(Self::Quality),
            "VIP_UPGRADE_PANEL_TYPE_DOWNLOAD" => Some(Self::Download),
            "VIP_UPGRADE_PANEL_TYPE_SWITCH" => Some(Self::Switch),
            "VIP_UPGRADE_PANEL_TYPE_PREVIEW" => Some(Self::Preview),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod app_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct AppClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AppClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AppClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AppClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn activity_bubble(
            &mut self,
            request: impl tonic::IntoRequest<super::ActivityBubbleReq>,
        ) -> std::result::Result<
            tonic::Response<super::ActivityBubbleResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/ActivityBubble",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "ActivityBubble",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn anime_schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::AnimeScheduleReq>,
        ) -> std::result::Result<
            tonic::Response<super::AnimeScheduleResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/AnimeSchedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "AnimeSchedule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn app_notify_report(
            &mut self,
            request: impl tonic::IntoRequest<super::AppNotifyReportReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/AppNotifyReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "AppNotifyReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn conversation_list(
            &mut self,
            request: impl tonic::IntoRequest<super::ConversationListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConversationListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/ConversationList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "ConversationList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_download_page_banner_ad_conf(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDownloadPageBannerAdConfReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetDownloadPageBannerAdConfResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetDownloadPageBannerAdConf",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetDownloadPageBannerAdConf",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_exposure_splash_ad(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExposureSplashAdReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetExposureSplashAdResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetExposureSplashAd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetExposureSplashAd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_premium_upgrade_panel(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPremiumUpgradePanelReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetPremiumUpgradePanelResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetPremiumUpgradePanel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetPremiumUpgradePanel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_relation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRelationReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetRelationResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetRelation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.intl.app.interfaces.v2.App", "GetRelation"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_sdk_ad_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSdkAdConfigReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetSdkAdConfigResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetSDKAdConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetSDKAdConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_sdk_ad_ecpm(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSdkAdEcpmReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetSdkAdEcpmResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetSDKAdEcpm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetSDKAdEcpm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_uid2_token(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUid2TokenReq>,
        ) -> std::result::Result<tonic::Response<super::Uid2Token>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetUID2Token",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetUID2Token",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_view_collections(
            &mut self,
            request: impl tonic::IntoRequest<super::GetViewCollectionsReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetViewCollectionsResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetViewCollections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetViewCollections",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_view_conf(
            &mut self,
            request: impl tonic::IntoRequest<super::GetViewConfReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetViewConfResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetViewConf",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.intl.app.interfaces.v2.App", "GetViewConf"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_view_refresh_ad(
            &mut self,
            request: impl tonic::IntoRequest<super::GetViewRefreshAdReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetViewRefreshAdResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/GetViewRefreshAd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "GetViewRefreshAd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn ping(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/Ping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.intl.app.interfaces.v2.App", "Ping"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn preload_splash_ad(
            &mut self,
            request: impl tonic::IntoRequest<super::PreloadSplashAdReq>,
        ) -> std::result::Result<
            tonic::Response<super::PreloadSplashAdResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/PreloadSplashAd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "PreloadSplashAd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn pull_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::PullConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullConversationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/PullConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "PullConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn pull_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::PullMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/PullMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "PullMessages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn rec_unlock_ad_list(
            &mut self,
            request: impl tonic::IntoRequest<super::RecUnlockAdListReq>,
        ) -> std::result::Result<
            tonic::Response<super::RecUnlockAdListResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/RecUnlockAdList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "RecUnlockAdList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn rec_unlock_cnt(
            &mut self,
            request: impl tonic::IntoRequest<super::RecUnlockCntReq>,
        ) -> std::result::Result<
            tonic::Response<super::RecUnlockCntResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/RecUnlockCnt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "RecUnlockCnt",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn report_ad_event(
            &mut self,
            request: impl tonic::IntoRequest<super::AdEvent>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/ReportAdEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "ReportAdEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn search_square_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchSquareV2Req>,
        ) -> std::result::Result<
            tonic::Response<super::SearchSquareV2Resp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/SearchSquareV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "SearchSquareV2",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn send_message(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/SendMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.intl.app.interfaces.v2.App", "SendMessage"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn set_conversation_seq(
            &mut self,
            request: impl tonic::IntoRequest<super::SetConversationSeqRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetConversationSeqResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/SetConversationSeq",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "SetConversationSeq",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn start_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::StartConversationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartConversationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/StartConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "StartConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn submit_user_info_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitUserInfoCollectionReq>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitUserInfoCollectionResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/SubmitUserInfoCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "SubmitUserInfoCollection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn unlock(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/Unlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.intl.app.interfaces.v2.App", "Unlock"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn unlock_panel(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockPanelReq>,
        ) -> std::result::Result<
            tonic::Response<super::UnlockPanelResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/UnlockPanel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.intl.app.interfaces.v2.App", "UnlockPanel"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn user_info_collection_pop_up(
            &mut self,
            request: impl tonic::IntoRequest<super::UserInfoCollectionPopUpReq>,
        ) -> std::result::Result<
            tonic::Response<super::UserInfoCollectionPopUpResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/UserInfoCollectionPopUp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "UserInfoCollectionPopUp",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn user_login_info(
            &mut self,
            request: impl tonic::IntoRequest<super::UserLoginInfoReq>,
        ) -> std::result::Result<
            tonic::Response<super::UserLoginInfoResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/UserLoginInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "UserLoginInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view_ad_confirm(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewAdConfirmReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewAdConfirmResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/ViewAdConfirm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "ViewAdConfirm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view_ad_unlock(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewAdUnlockReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewAdUnlockResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/ViewAdUnlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "ViewAdUnlock",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view_ad_unlock_pre_check(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewAdUnlockPreCheckReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewAdUnlockPreCheckResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.intl.app.interfaces.v2.App/ViewAdUnlockPreCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.intl.app.interfaces.v2.App",
                        "ViewAdUnlockPreCheck",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod app_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AppServer.
    #[async_trait]
    pub trait App: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn activity_bubble(
            &self,
            request: tonic::Request<super::ActivityBubbleReq>,
        ) -> std::result::Result<
            tonic::Response<super::ActivityBubbleResp>,
            tonic::Status,
        >;
        ///
        async fn anime_schedule(
            &self,
            request: tonic::Request<super::AnimeScheduleReq>,
        ) -> std::result::Result<
            tonic::Response<super::AnimeScheduleResp>,
            tonic::Status,
        >;
        ///
        async fn app_notify_report(
            &self,
            request: tonic::Request<super::AppNotifyReportReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn conversation_list(
            &self,
            request: tonic::Request<super::ConversationListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConversationListResponse>,
            tonic::Status,
        >;
        ///
        async fn get_download_page_banner_ad_conf(
            &self,
            request: tonic::Request<super::GetDownloadPageBannerAdConfReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetDownloadPageBannerAdConfResp>,
            tonic::Status,
        >;
        ///
        async fn get_exposure_splash_ad(
            &self,
            request: tonic::Request<super::GetExposureSplashAdReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetExposureSplashAdResp>,
            tonic::Status,
        >;
        ///
        async fn get_premium_upgrade_panel(
            &self,
            request: tonic::Request<super::GetPremiumUpgradePanelReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetPremiumUpgradePanelResp>,
            tonic::Status,
        >;
        ///
        async fn get_relation(
            &self,
            request: tonic::Request<super::GetRelationReq>,
        ) -> std::result::Result<tonic::Response<super::GetRelationResp>, tonic::Status>;
        ///
        async fn get_sdk_ad_config(
            &self,
            request: tonic::Request<super::GetSdkAdConfigReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetSdkAdConfigResp>,
            tonic::Status,
        >;
        ///
        async fn get_sdk_ad_ecpm(
            &self,
            request: tonic::Request<super::GetSdkAdEcpmReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetSdkAdEcpmResp>,
            tonic::Status,
        >;
        ///
        async fn get_uid2_token(
            &self,
            request: tonic::Request<super::GetUid2TokenReq>,
        ) -> std::result::Result<tonic::Response<super::Uid2Token>, tonic::Status>;
        ///
        async fn get_view_collections(
            &self,
            request: tonic::Request<super::GetViewCollectionsReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetViewCollectionsResp>,
            tonic::Status,
        >;
        ///
        async fn get_view_conf(
            &self,
            request: tonic::Request<super::GetViewConfReq>,
        ) -> std::result::Result<tonic::Response<super::GetViewConfResp>, tonic::Status>;
        ///
        async fn get_view_refresh_ad(
            &self,
            request: tonic::Request<super::GetViewRefreshAdReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetViewRefreshAdResp>,
            tonic::Status,
        >;
        ///
        async fn ping(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn preload_splash_ad(
            &self,
            request: tonic::Request<super::PreloadSplashAdReq>,
        ) -> std::result::Result<
            tonic::Response<super::PreloadSplashAdResp>,
            tonic::Status,
        >;
        ///
        async fn pull_conversations(
            &self,
            request: tonic::Request<super::PullConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullConversationsResponse>,
            tonic::Status,
        >;
        ///
        async fn pull_messages(
            &self,
            request: tonic::Request<super::PullMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullMessagesResponse>,
            tonic::Status,
        >;
        ///
        async fn rec_unlock_ad_list(
            &self,
            request: tonic::Request<super::RecUnlockAdListReq>,
        ) -> std::result::Result<
            tonic::Response<super::RecUnlockAdListResp>,
            tonic::Status,
        >;
        ///
        async fn rec_unlock_cnt(
            &self,
            request: tonic::Request<super::RecUnlockCntReq>,
        ) -> std::result::Result<
            tonic::Response<super::RecUnlockCntResp>,
            tonic::Status,
        >;
        ///
        async fn report_ad_event(
            &self,
            request: tonic::Request<super::AdEvent>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn search_square_v2(
            &self,
            request: tonic::Request<super::SearchSquareV2Req>,
        ) -> std::result::Result<
            tonic::Response<super::SearchSquareV2Resp>,
            tonic::Status,
        >;
        ///
        async fn send_message(
            &self,
            request: tonic::Request<super::SendMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendMessageResponse>,
            tonic::Status,
        >;
        ///
        async fn set_conversation_seq(
            &self,
            request: tonic::Request<super::SetConversationSeqRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetConversationSeqResponse>,
            tonic::Status,
        >;
        ///
        async fn start_conversation(
            &self,
            request: tonic::Request<super::StartConversationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartConversationResponse>,
            tonic::Status,
        >;
        ///
        async fn submit_user_info_collection(
            &self,
            request: tonic::Request<super::SubmitUserInfoCollectionReq>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitUserInfoCollectionResp>,
            tonic::Status,
        >;
        ///
        async fn unlock(
            &self,
            request: tonic::Request<super::UnlockReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn unlock_panel(
            &self,
            request: tonic::Request<super::UnlockPanelReq>,
        ) -> std::result::Result<tonic::Response<super::UnlockPanelResp>, tonic::Status>;
        ///
        async fn user_info_collection_pop_up(
            &self,
            request: tonic::Request<super::UserInfoCollectionPopUpReq>,
        ) -> std::result::Result<
            tonic::Response<super::UserInfoCollectionPopUpResp>,
            tonic::Status,
        >;
        ///
        async fn user_login_info(
            &self,
            request: tonic::Request<super::UserLoginInfoReq>,
        ) -> std::result::Result<
            tonic::Response<super::UserLoginInfoResp>,
            tonic::Status,
        >;
        ///
        async fn view_ad_confirm(
            &self,
            request: tonic::Request<super::ViewAdConfirmReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewAdConfirmResp>,
            tonic::Status,
        >;
        ///
        async fn view_ad_unlock(
            &self,
            request: tonic::Request<super::ViewAdUnlockReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewAdUnlockResp>,
            tonic::Status,
        >;
        ///
        async fn view_ad_unlock_pre_check(
            &self,
            request: tonic::Request<super::ViewAdUnlockPreCheckReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewAdUnlockPreCheckResp>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct AppServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AppServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AppServer<T>
    where
        T: App,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.intl.app.interfaces.v2.App/ActivityBubble" => {
                    #[allow(non_camel_case_types)]
                    struct ActivityBubbleSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::ActivityBubbleReq>
                    for ActivityBubbleSvc<T> {
                        type Response = super::ActivityBubbleResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ActivityBubbleReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::activity_bubble(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ActivityBubbleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/AnimeSchedule" => {
                    #[allow(non_camel_case_types)]
                    struct AnimeScheduleSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::AnimeScheduleReq>
                    for AnimeScheduleSvc<T> {
                        type Response = super::AnimeScheduleResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnimeScheduleReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::anime_schedule(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AnimeScheduleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/AppNotifyReport" => {
                    #[allow(non_camel_case_types)]
                    struct AppNotifyReportSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::AppNotifyReportReq>
                    for AppNotifyReportSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AppNotifyReportReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::app_notify_report(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AppNotifyReportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/ConversationList" => {
                    #[allow(non_camel_case_types)]
                    struct ConversationListSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::ConversationListRequest>
                    for ConversationListSvc<T> {
                        type Response = super::ConversationListResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConversationListRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::conversation_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConversationListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetDownloadPageBannerAdConf" => {
                    #[allow(non_camel_case_types)]
                    struct GetDownloadPageBannerAdConfSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::GetDownloadPageBannerAdConfReq>
                    for GetDownloadPageBannerAdConfSvc<T> {
                        type Response = super::GetDownloadPageBannerAdConfResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::GetDownloadPageBannerAdConfReq,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_download_page_banner_ad_conf(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDownloadPageBannerAdConfSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetExposureSplashAd" => {
                    #[allow(non_camel_case_types)]
                    struct GetExposureSplashAdSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::GetExposureSplashAdReq>
                    for GetExposureSplashAdSvc<T> {
                        type Response = super::GetExposureSplashAdResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetExposureSplashAdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_exposure_splash_ad(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetExposureSplashAdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetPremiumUpgradePanel" => {
                    #[allow(non_camel_case_types)]
                    struct GetPremiumUpgradePanelSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::GetPremiumUpgradePanelReq>
                    for GetPremiumUpgradePanelSvc<T> {
                        type Response = super::GetPremiumUpgradePanelResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPremiumUpgradePanelReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_premium_upgrade_panel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPremiumUpgradePanelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetRelation" => {
                    #[allow(non_camel_case_types)]
                    struct GetRelationSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::GetRelationReq>
                    for GetRelationSvc<T> {
                        type Response = super::GetRelationResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRelationReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_relation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRelationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetSDKAdConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetSDKAdConfigSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::GetSdkAdConfigReq>
                    for GetSDKAdConfigSvc<T> {
                        type Response = super::GetSdkAdConfigResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSdkAdConfigReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_sdk_ad_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSDKAdConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetSDKAdEcpm" => {
                    #[allow(non_camel_case_types)]
                    struct GetSDKAdEcpmSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::GetSdkAdEcpmReq>
                    for GetSDKAdEcpmSvc<T> {
                        type Response = super::GetSdkAdEcpmResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSdkAdEcpmReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_sdk_ad_ecpm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSDKAdEcpmSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetUID2Token" => {
                    #[allow(non_camel_case_types)]
                    struct GetUID2TokenSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::GetUid2TokenReq>
                    for GetUID2TokenSvc<T> {
                        type Response = super::Uid2Token;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUid2TokenReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_uid2_token(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUID2TokenSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetViewCollections" => {
                    #[allow(non_camel_case_types)]
                    struct GetViewCollectionsSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::GetViewCollectionsReq>
                    for GetViewCollectionsSvc<T> {
                        type Response = super::GetViewCollectionsResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetViewCollectionsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_view_collections(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetViewCollectionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetViewConf" => {
                    #[allow(non_camel_case_types)]
                    struct GetViewConfSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::GetViewConfReq>
                    for GetViewConfSvc<T> {
                        type Response = super::GetViewConfResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetViewConfReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_view_conf(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetViewConfSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/GetViewRefreshAd" => {
                    #[allow(non_camel_case_types)]
                    struct GetViewRefreshAdSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::GetViewRefreshAdReq>
                    for GetViewRefreshAdSvc<T> {
                        type Response = super::GetViewRefreshAdResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetViewRefreshAdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::get_view_refresh_ad(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetViewRefreshAdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/Ping" => {
                    #[allow(non_camel_case_types)]
                    struct PingSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<()> for PingSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::ping(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/PreloadSplashAd" => {
                    #[allow(non_camel_case_types)]
                    struct PreloadSplashAdSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::PreloadSplashAdReq>
                    for PreloadSplashAdSvc<T> {
                        type Response = super::PreloadSplashAdResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PreloadSplashAdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::preload_splash_ad(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PreloadSplashAdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/PullConversations" => {
                    #[allow(non_camel_case_types)]
                    struct PullConversationsSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::PullConversationsRequest>
                    for PullConversationsSvc<T> {
                        type Response = super::PullConversationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PullConversationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::pull_conversations(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PullConversationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/PullMessages" => {
                    #[allow(non_camel_case_types)]
                    struct PullMessagesSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::PullMessagesRequest>
                    for PullMessagesSvc<T> {
                        type Response = super::PullMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PullMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::pull_messages(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PullMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/RecUnlockAdList" => {
                    #[allow(non_camel_case_types)]
                    struct RecUnlockAdListSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::RecUnlockAdListReq>
                    for RecUnlockAdListSvc<T> {
                        type Response = super::RecUnlockAdListResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RecUnlockAdListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::rec_unlock_ad_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RecUnlockAdListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/RecUnlockCnt" => {
                    #[allow(non_camel_case_types)]
                    struct RecUnlockCntSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::RecUnlockCntReq>
                    for RecUnlockCntSvc<T> {
                        type Response = super::RecUnlockCntResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RecUnlockCntReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::rec_unlock_cnt(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RecUnlockCntSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/ReportAdEvent" => {
                    #[allow(non_camel_case_types)]
                    struct ReportAdEventSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::AdEvent>
                    for ReportAdEventSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AdEvent>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::report_ad_event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReportAdEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/SearchSquareV2" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSquareV2Svc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::SearchSquareV2Req>
                    for SearchSquareV2Svc<T> {
                        type Response = super::SearchSquareV2Resp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchSquareV2Req>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::search_square_v2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchSquareV2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/SendMessage" => {
                    #[allow(non_camel_case_types)]
                    struct SendMessageSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::SendMessageRequest>
                    for SendMessageSvc<T> {
                        type Response = super::SendMessageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SendMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::send_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SendMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/SetConversationSeq" => {
                    #[allow(non_camel_case_types)]
                    struct SetConversationSeqSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::SetConversationSeqRequest>
                    for SetConversationSeqSvc<T> {
                        type Response = super::SetConversationSeqResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetConversationSeqRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::set_conversation_seq(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetConversationSeqSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/StartConversation" => {
                    #[allow(non_camel_case_types)]
                    struct StartConversationSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::StartConversationRequest>
                    for StartConversationSvc<T> {
                        type Response = super::StartConversationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartConversationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::start_conversation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartConversationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/SubmitUserInfoCollection" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitUserInfoCollectionSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::SubmitUserInfoCollectionReq>
                    for SubmitUserInfoCollectionSvc<T> {
                        type Response = super::SubmitUserInfoCollectionResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitUserInfoCollectionReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::submit_user_info_collection(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitUserInfoCollectionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/Unlock" => {
                    #[allow(non_camel_case_types)]
                    struct UnlockSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::UnlockReq>
                    for UnlockSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnlockReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::unlock(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/UnlockPanel" => {
                    #[allow(non_camel_case_types)]
                    struct UnlockPanelSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::UnlockPanelReq>
                    for UnlockPanelSvc<T> {
                        type Response = super::UnlockPanelResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnlockPanelReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::unlock_panel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlockPanelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/UserInfoCollectionPopUp" => {
                    #[allow(non_camel_case_types)]
                    struct UserInfoCollectionPopUpSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::UserInfoCollectionPopUpReq>
                    for UserInfoCollectionPopUpSvc<T> {
                        type Response = super::UserInfoCollectionPopUpResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UserInfoCollectionPopUpReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::user_info_collection_pop_up(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UserInfoCollectionPopUpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/UserLoginInfo" => {
                    #[allow(non_camel_case_types)]
                    struct UserLoginInfoSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::UserLoginInfoReq>
                    for UserLoginInfoSvc<T> {
                        type Response = super::UserLoginInfoResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UserLoginInfoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::user_login_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UserLoginInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/ViewAdConfirm" => {
                    #[allow(non_camel_case_types)]
                    struct ViewAdConfirmSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::ViewAdConfirmReq>
                    for ViewAdConfirmSvc<T> {
                        type Response = super::ViewAdConfirmResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewAdConfirmReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::view_ad_confirm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewAdConfirmSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/ViewAdUnlock" => {
                    #[allow(non_camel_case_types)]
                    struct ViewAdUnlockSvc<T: App>(pub Arc<T>);
                    impl<T: App> tonic::server::UnaryService<super::ViewAdUnlockReq>
                    for ViewAdUnlockSvc<T> {
                        type Response = super::ViewAdUnlockResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewAdUnlockReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::view_ad_unlock(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewAdUnlockSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.intl.app.interfaces.v2.App/ViewAdUnlockPreCheck" => {
                    #[allow(non_camel_case_types)]
                    struct ViewAdUnlockPreCheckSvc<T: App>(pub Arc<T>);
                    impl<
                        T: App,
                    > tonic::server::UnaryService<super::ViewAdUnlockPreCheckReq>
                    for ViewAdUnlockPreCheckSvc<T> {
                        type Response = super::ViewAdUnlockPreCheckResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewAdUnlockPreCheckReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as App>::view_ad_unlock_pre_check(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewAdUnlockPreCheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AppServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.intl.app.interfaces.v2.App";
    impl<T> tonic::server::NamedService for AppServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}

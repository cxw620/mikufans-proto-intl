// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityResource {
    ///
    #[prost(string, tag = "1")]
    pub mod_pool_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub mod_resource_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub selected_bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub light_text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub dark_text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub divider_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivitySeason {
    ///
    #[prost(message, optional, tag = "1")]
    pub arc: ::core::option::Option<super::super::archive::v1::Arc>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub pages: ::prost::alloc::vec::Vec<ViewPage>,
    ///
    #[prost(message, optional, tag = "3")]
    pub owner_ext: ::core::option::Option<OnwerExt>,
    ///
    #[prost(message, optional, tag = "4")]
    pub req_user: ::core::option::Option<ReqUser>,
    ///
    #[prost(message, optional, tag = "5")]
    pub elec_rank: ::core::option::Option<ElecRank>,
    ///
    #[prost(message, optional, tag = "6")]
    pub history: ::core::option::Option<History>,
    ///
    #[prost(string, tag = "7")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub honor: ::core::option::Option<Honor>,
    ///
    #[prost(message, repeated, tag = "9")]
    pub staff: ::prost::alloc::vec::Vec<Staff>,
    ///
    #[prost(message, optional, tag = "10")]
    pub ugc_season: ::core::option::Option<UgcSeason>,
    ///
    #[prost(message, optional, tag = "11")]
    pub tab: ::core::option::Option<Tab>,
    ///
    #[prost(message, optional, tag = "12")]
    pub rank: ::core::option::Option<Rank>,
    ///
    #[prost(message, optional, tag = "13")]
    pub order: ::core::option::Option<Order>,
    ///
    #[prost(bool, tag = "14")]
    pub support_dislike: bool,
    ///
    #[prost(message, optional, tag = "15")]
    pub operation_relate: ::core::option::Option<OperationRelate>,
    ///
    #[prost(message, optional, tag = "16")]
    pub activity_resource: ::core::option::Option<ActivityResource>,
    ///
    #[prost(string, tag = "17")]
    pub short_link: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "18")]
    pub label: ::core::option::Option<Label>,
    ///
    #[prost(message, optional, tag = "19")]
    pub dislike: ::core::option::Option<Dislike>,
    ///
    #[prost(message, optional, tag = "20")]
    pub player_icon: ::core::option::Option<PlayerIcon>,
    ///
    #[prost(string, tag = "21")]
    pub share_subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "22")]
    pub cm_config: ::core::option::Option<CmConfig>,
    ///
    #[prost(message, optional, tag = "23")]
    pub tf_panel_customized: ::core::option::Option<TfPanelCustomized>,
    ///
    #[prost(string, tag = "24")]
    pub argue_msg: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ECode", tag = "25")]
    pub ecode: i32,
    ///
    #[prost(message, optional, tag = "26")]
    pub custom_config: ::core::option::Option<CustomConfig>,
    ///
    #[prost(string, tag = "27")]
    pub badge_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "28")]
    pub desc_v2: ::prost::alloc::vec::Vec<DescV2>,
    ///
    #[prost(message, optional, tag = "29")]
    pub config: ::core::option::Option<Config>,
    ///
    #[prost(message, optional, tag = "30")]
    pub online: ::core::option::Option<Online>,
    ///
    #[prost(message, optional, tag = "31")]
    pub arc_extra: ::core::option::Option<ArcExtra>,
    ///
    #[prost(message, optional, tag = "32")]
    pub reply_preface: ::core::option::Option<ReplyStyle>,
    ///
    #[prost(message, optional, tag = "33")]
    pub up_like_img: ::core::option::Option<UpLikeImg>,
    ///
    #[prost(message, repeated, tag = "34")]
    pub special_cell_new: ::prost::alloc::vec::Vec<SpecialCell>,
    ///
    #[prost(message, optional, tag = "35")]
    pub like_animation: ::core::option::Option<LikeAnimation>,
    ///
    #[prost(message, optional, tag = "36")]
    pub user_garb: ::core::option::Option<UserGarb>,
    ///
    #[prost(message, optional, tag = "37")]
    pub control_config: ::core::option::Option<ControlConfig>,
    ///
    #[prost(message, optional, tag = "38")]
    pub coin_style: ::core::option::Option<CoinStyle>,
    ///
    #[prost(message, optional, tag = "39")]
    pub rabbit_year: ::core::option::Option<RabbitYear>,
    ///
    #[prost(message, optional, tag = "40")]
    pub stat_v2: ::core::option::Option<ArchiveStat>,
    ///
    #[prost(message, optional, tag = "41")]
    pub argue_bar: ::core::option::Option<ArgueBar>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdInfo {
    ///
    #[prost(int64, tag = "1")]
    pub creative_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub creative_type: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub creative_content: ::core::option::Option<CreativeContent>,
    ///
    #[prost(string, tag = "4")]
    pub ad_cb: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub card_type: i32,
    ///
    #[prost(bytes = "vec", tag = "6")]
    pub extra: ::prost::alloc::vec::Vec<u8>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddContractReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub up_mid: i64,
    ///
    #[prost(string, tag = "3")]
    pub spmid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArcExtra {
    ///
    #[prost(string, tag = "1")]
    pub arc_pub_location: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchiveStat {
    ///
    #[prost(message, optional, tag = "11")]
    pub view_vt: ::core::option::Option<StatInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArcsPlayer {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(map = "int64, string", tag = "2")]
    pub player_info: ::std::collections::HashMap<i64, ::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArgueBar {
    ///
    #[prost(string, tag = "1")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub msg: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub icon_color_night: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    ///
    #[prost(int32, tag = "1")]
    pub paid: i32,
    ///
    #[prost(int64, tag = "2")]
    pub price: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub msg: ::core::option::Option<AssetMsg>,
    ///
    #[prost(message, optional, tag = "4")]
    pub preview_msg: ::core::option::Option<AssetMsg>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetMsg {
    ///
    #[prost(string, tag = "1")]
    pub desc1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc2: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Attention {
    ///
    #[prost(int32, tag = "1")]
    pub start_time: i32,
    ///
    #[prost(int32, tag = "2")]
    pub end_time: i32,
    ///
    #[prost(double, tag = "3")]
    pub pos_x: f64,
    ///
    #[prost(double, tag = "4")]
    pub pos_y: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audio {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub song_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub play_count: i64,
    ///
    #[prost(int64, tag = "5")]
    pub reply_count: i64,
    ///
    #[prost(int64, tag = "6")]
    pub upper_id: i64,
    ///
    #[prost(string, tag = "7")]
    pub entrance: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub song_attr: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadgeStyle {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub border_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub border_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bg_style: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bgm {
    ///
    #[prost(int64, tag = "1")]
    pub sid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BizFavSeasonParam {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BizFollowVideoParam {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BizJumpLinkParam {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BizReserveActivityParam {
    ///
    #[prost(int64, tag = "1")]
    pub activity_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub reserve_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BizReserveGameParam {
    ///
    #[prost(int64, tag = "1")]
    pub game_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Button {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "JumpShowType", tag = "4")]
    pub jump_show_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ButtonStyle {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub jump_link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuzzwordConfig {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub schema: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub source: i32,
    ///
    #[prost(int64, tag = "4")]
    pub start: i64,
    ///
    #[prost(int64, tag = "5")]
    pub end: i64,
    ///
    #[prost(bool, tag = "6")]
    pub follow_control: bool,
    ///
    #[prost(int64, tag = "7")]
    pub id: i64,
    ///
    #[prost(int64, tag = "8")]
    pub buzzword_id: i64,
    ///
    #[prost(int32, tag = "9")]
    pub schema_type: i32,
    ///
    #[prost(string, tag = "10")]
    pub picture: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cm {
    ///
    #[prost(message, optional, tag = "1")]
    pub source_content: ::core::option::Option<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmConfig {
    ///
    #[prost(message, optional, tag = "1")]
    pub ads_control: ::core::option::Option<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheViewReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub arc: ::core::option::Option<super::super::archive::v1::Arc>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub pages: ::prost::alloc::vec::Vec<ViewPage>,
    ///
    #[prost(message, optional, tag = "3")]
    pub owner_ext: ::core::option::Option<OnwerExt>,
    ///
    #[prost(message, optional, tag = "4")]
    pub req_user: ::core::option::Option<ReqUser>,
    ///
    #[prost(message, optional, tag = "5")]
    pub season: ::core::option::Option<Season>,
    ///
    #[prost(message, optional, tag = "6")]
    pub elec_rank: ::core::option::Option<ElecRank>,
    ///
    #[prost(message, optional, tag = "7")]
    pub history: ::core::option::Option<History>,
    ///
    #[prost(message, optional, tag = "8")]
    pub dislike: ::core::option::Option<Dislike>,
    ///
    #[prost(message, optional, tag = "9")]
    pub player_icon: ::core::option::Option<PlayerIcon>,
    ///
    #[prost(string, tag = "10")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub short_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub share_subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "13")]
    pub tf_panel_customized: ::core::option::Option<TfPanelCustomized>,
    ///
    #[prost(message, optional, tag = "14")]
    pub online: ::core::option::Option<Online>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheViewReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub trackid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub ad_extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub from_spmid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CellFluid {
    ///
    #[prost(string, tag = "1")]
    pub top_base_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub top_split_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub top_text_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChargingPlus {
    ///
    #[prost(bool, tag = "1")]
    pub pass: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chronos {
    ///
    #[prost(string, tag = "1")]
    pub md5: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub file: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sign: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChronosPkgReq {
    ///
    #[prost(string, tag = "1")]
    pub service_key: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub engine_version: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub message_protocol: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickActivitySeasonReq {
    ///
    #[prost(enumeration = "BizType", tag = "1")]
    pub order_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub action: i64,
    ///
    #[prost(oneof = "click_activity_season_req::OrderParam", tags = "3, 4")]
    pub order_param: ::core::option::Option<click_activity_season_req::OrderParam>,
}
/// Nested message and enum types in `ClickActivitySeasonReq`.
pub mod click_activity_season_req {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OrderParam {
        ///
        #[prost(message, tag = "3")]
        Reserve(super::BizReserveActivityParam),
        ///
        #[prost(message, tag = "4")]
        FavSeason(super::BizFavSeasonParam),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickPlayerCardReply {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickPlayerCardReq {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "4")]
    pub action: i64,
    ///
    #[prost(string, tag = "5")]
    pub spmid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmIpad {
    ///
    #[prost(message, optional, tag = "1")]
    pub cm: ::core::option::Option<Cm>,
    ///
    #[prost(message, optional, tag = "2")]
    pub author: ::core::option::Option<super::super::archive::v1::Author>,
    ///
    #[prost(message, optional, tag = "3")]
    pub stat: ::core::option::Option<super::super::archive::v1::Stat>,
    ///
    #[prost(int64, tag = "4")]
    pub duration: i64,
    ///
    #[prost(int64, tag = "5")]
    pub aid: i64,
    ///
    #[prost(message, optional, tag = "6")]
    pub stat_v2: ::core::option::Option<ArchiveStat>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinCustom {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinStyle {
    ///
    #[prost(string, tag = "1")]
    pub coin_app_zip_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub coin_app_icon1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub coin_app_icon2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub coin_app_icon3: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub coin_app_icon4: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandDm {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub command: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub progress: i32,
    ///
    #[prost(string, tag = "7")]
    pub ctime: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub mtime: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub id_str: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    ///
    #[prost(string, tag = "1")]
    pub relates_title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub relates_style: i32,
    ///
    #[prost(int32, tag = "3")]
    pub relate_gif_exp: i32,
    ///
    #[prost(int32, tag = "4")]
    pub end_page_half: i32,
    ///
    #[prost(int32, tag = "5")]
    pub end_page_full: i32,
    ///
    #[prost(bool, tag = "6")]
    pub auto_swindow: bool,
    ///
    #[prost(bool, tag = "7")]
    pub popup_info: bool,
    ///
    #[prost(string, tag = "8")]
    pub abtest_small_window: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub rec_three_point_style: i32,
    ///
    #[prost(bool, tag = "10")]
    pub is_absolute_time: bool,
    ///
    #[prost(bool, tag = "11")]
    pub new_swindow: bool,
    ///
    #[prost(bool, tag = "12")]
    pub relates_biserial: bool,
    ///
    #[prost(message, optional, tag = "13")]
    pub listener_conf: ::core::option::Option<ListenerConfig>,
    ///
    #[prost(string, tag = "14")]
    pub relates_feed_style: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "15")]
    pub relates_feed_popup: bool,
    ///
    #[prost(bool, tag = "16")]
    pub relates_has_next: bool,
    ///
    #[prost(int32, tag = "17")]
    pub local_play: i32,
    ///
    #[prost(bool, tag = "18")]
    pub play_story: bool,
    ///
    #[prost(bool, tag = "19")]
    pub arc_play_story: bool,
    ///
    #[prost(string, tag = "20")]
    pub story_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "21")]
    pub landscape_story: bool,
    ///
    #[prost(bool, tag = "22")]
    pub arc_landscape_story: bool,
    ///
    #[prost(string, tag = "23")]
    pub landscape_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "24")]
    pub show_listen_button: bool,
    ///
    #[prost(int64, tag = "25")]
    pub valid_show_m: i64,
    ///
    #[prost(int64, tag = "26")]
    pub valid_show_n: i64,
    ///
    #[prost(bool, tag = "27")]
    pub dm_treasure_box_control: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContinuousPlayReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub relates: ::prost::alloc::vec::Vec<Relate>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContinuousPlayReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub trackid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub autoplay: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "8")]
    pub device_type: i64,
    ///
    #[prost(string, tag = "9")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub display_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractCard {
    ///
    #[prost(float, tag = "1")]
    pub display_progress: f32,
    ///
    #[prost(int64, tag = "2")]
    pub display_accuracy: i64,
    ///
    #[prost(int64, tag = "3")]
    pub display_duration: i64,
    ///
    #[prost(int32, tag = "4")]
    pub show_mode: i32,
    ///
    #[prost(int32, tag = "5")]
    pub page_type: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub upper: ::core::option::Option<UpperInfos>,
    ///
    #[prost(int32, tag = "7")]
    pub is_follow_display: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub text: ::core::option::Option<ContractText>,
    ///
    #[prost(int64, tag = "9")]
    pub follow_display_end_duration: i64,
    ///
    #[prost(int32, tag = "10")]
    pub is_play_display: i32,
    ///
    #[prost(int32, tag = "11")]
    pub is_interact_display: i32,
    ///
    #[prost(bool, tag = "12")]
    pub play_display_switch: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractText {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub inline_title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Control {
    ///
    #[prost(bool, tag = "1")]
    pub limit: bool,
    ///
    #[prost(bool, tag = "2")]
    pub disable: bool,
    ///
    #[prost(string, tag = "3")]
    pub disable_click_tip: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlConfig {
    ///
    #[prost(message, optional, tag = "1")]
    pub like_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "2")]
    pub dislike_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "3")]
    pub coin_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "4")]
    pub fav_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "5")]
    pub share_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "6")]
    pub toast_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "7")]
    pub material_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "8")]
    pub danmu_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "9")]
    pub remark_show: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "10")]
    pub half_danmu_send: ::core::option::Option<Control>,
    ///
    #[prost(message, optional, tag = "11")]
    pub up_show: ::core::option::Option<Control>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreativeContent {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub button_title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub video_id: i64,
    ///
    #[prost(string, tag = "5")]
    pub username: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub image_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub image_md5: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub log_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub log_md5: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub click_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub show_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConfig {
    ///
    #[prost(string, tag = "1")]
    pub redirect_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dm {
    ///
    #[prost(bool, tag = "1")]
    pub closed: bool,
    ///
    #[prost(bool, tag = "2")]
    pub real_name: bool,
    ///
    #[prost(int64, tag = "3")]
    pub count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescV2 {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "DescType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub rid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dislike {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub reasons: ::prost::alloc::vec::Vec<DislikeReasons>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DislikeReasons {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(int32, tag = "3")]
    pub rid: i32,
    ///
    #[prost(int64, tag = "4")]
    pub tag_id: i64,
    ///
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmSummon {
    ///
    #[prost(string, repeated, tag = "1")]
    pub title: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub err_msg: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub long_content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub short_content: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ELecPlus {
    ///
    #[prost(int64, tag = "1")]
    pub state: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElecRank {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<ElecRankItem>,
    ///
    #[prost(int64, tag = "2")]
    pub count: i64,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElecRankItem {
    ///
    #[prost(string, tag = "1")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub mid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Episode {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_right_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub page: ::core::option::Option<super::super::archive::v1::Page>,
    ///
    #[prost(message, optional, tag = "8")]
    pub stat: ::core::option::Option<super::super::archive::v1::Stat>,
    ///
    #[prost(string, tag = "9")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub author: ::core::option::Option<super::super::archive::v1::Author>,
    ///
    #[prost(string, tag = "11")]
    pub author_desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "12")]
    pub badge_style: ::core::option::Option<BadgeStyle>,
    ///
    #[prost(bool, tag = "13")]
    pub need_pay: bool,
    ///
    #[prost(bool, tag = "14")]
    pub episode_pay: bool,
    ///
    #[prost(bool, tag = "15")]
    pub free_watch: bool,
    ///
    #[prost(string, tag = "16")]
    pub first_frame: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "17")]
    pub stat_v2: ::core::option::Option<ArchiveStat>,
    ///
    #[prost(message, repeated, tag = "18")]
    pub pages: ::prost::alloc::vec::Vec<super::super::archive::v1::Page>,
    ///
    #[prost(double, tag = "19")]
    pub progress_percent: f64,
    ///
    #[prost(int64, tag = "20")]
    pub duration: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExposePlayerCardReq {
    ///
    #[prost(enumeration = "PlayerCardType", tag = "1")]
    pub card_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtTab {
    ///
    #[prost(enumeration = "ExtType", tag = "1")]
    pub ext_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub data: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedViewItem {
    ///
    #[prost(message, optional, tag = "1")]
    pub view: ::core::option::Option<ViewReply>,
    ///
    #[prost(string, tag = "2")]
    pub goto: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub track_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedViewReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<FeedViewItem>,
    ///
    #[prost(bool, tag = "2")]
    pub has_next: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedViewReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "7")]
    pub display_id: i64,
    ///
    #[prost(string, tag = "8")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub page_version: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub from_track_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetArcsPlayerReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub arcs_player: ::prost::alloc::vec::Vec<ArcsPlayer>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetArcsPlayerReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub play_avs: ::prost::alloc::vec::Vec<PlayAv>,
    ///
    #[prost(message, optional, tag = "2")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub like_list: ::prost::alloc::vec::Vec<User>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserReq {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub mids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub up_mid: i64,
    ///
    #[prost(bool, tag = "4")]
    pub only_fans: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoodsInfo {
    ///
    #[prost(string, tag = "1")]
    pub goods_id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "Category", tag = "2")]
    pub category: i32,
    ///
    #[prost(int64, tag = "3")]
    pub goods_price: i64,
    ///
    #[prost(enumeration = "PayState", tag = "4")]
    pub pay_state: i32,
    ///
    #[prost(string, tag = "5")]
    pub goods_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub price_fmt: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HalfScreen {
    ///
    #[prost(int64, tag = "1")]
    pub daily_max: i64,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct History {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub progress: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Honor {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text_extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub url_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub category: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IconData {
    ///
    #[prost(string, tag = "1")]
    pub meta_json: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub sprits_img: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractArea {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<User>,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interaction {
    ///
    #[prost(message, optional, tag = "1")]
    pub history_node: ::core::option::Option<Node>,
    ///
    #[prost(int64, tag = "2")]
    pub graph_version: i64,
    ///
    #[prost(string, tag = "3")]
    pub msg: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub evaluation: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub mark: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Label {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon_night: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub icon_width: i64,
    ///
    #[prost(int64, tag = "6")]
    pub icon_height: i64,
    ///
    #[prost(string, tag = "7")]
    pub lottie: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub lottie_night: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeAnimation {
    ///
    #[prost(string, tag = "1")]
    pub like_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub liked_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub like_animation: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeComment {
    ///
    #[prost(string, tag = "1")]
    pub reply: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeCustom {
    ///
    #[prost(bool, tag = "1")]
    pub like_switch: bool,
    ///
    #[prost(int64, tag = "2")]
    pub full_to_half_progress: i64,
    ///
    #[prost(int64, tag = "3")]
    pub non_full_progress: i64,
    ///
    #[prost(int64, tag = "4")]
    pub update_count: i64,
    ///
    #[prost(bool, tag = "5")]
    pub immediately_upgrade: bool,
    ///
    #[prost(message, optional, tag = "6")]
    pub like_comment: ::core::option::Option<LikeComment>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeReply {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub v_voucher: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub ogv_type: i64,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub goto: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub like: i32,
    ///
    #[prost(string, tag = "9")]
    pub source: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub token: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub action_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenerConfig {
    ///
    #[prost(int64, tag = "1")]
    pub jump_style: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub guide_bar: ::core::option::Option<ListenerGuideBar>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenerGuideBar {
    ///
    #[prost(int64, tag = "1")]
    pub show_strategy: i64,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub btn_text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub show_time: i64,
    ///
    #[prost(int64, tag = "6")]
    pub background_time: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Live {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub roomid: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub endpage_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveInfo {
    ///
    #[prost(string, tag = "1")]
    pub area_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub watched_show: i64,
    ///
    #[prost(int64, tag = "3")]
    pub live_status: i64,
    ///
    #[prost(int64, tag = "4")]
    pub icon_type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveOrderInfo {
    ///
    #[prost(int64, tag = "1")]
    pub sid: i64,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub live_plan_start_time: i64,
    ///
    #[prost(bool, tag = "4")]
    pub is_follow: bool,
    ///
    #[prost(int64, tag = "5")]
    pub follow_count: i64,
    ///
    #[prost(string, tag = "6")]
    pub style: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaterialLeft {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub left_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub param: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub operational_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub static_icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaterialRes {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub typ: i32,
    ///
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub bg_pic: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub jump_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NftFaceIcon {
    ///
    #[prost(int32, tag = "1")]
    pub region_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub show_status: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    ///
    #[prost(int64, tag = "1")]
    pub node_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notice {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialVerify {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Online {
    ///
    #[prost(bool, tag = "1")]
    pub online_show: bool,
    ///
    #[prost(string, tag = "2")]
    pub player_online_logo: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnwerExt {
    ///
    #[prost(message, optional, tag = "1")]
    pub official_verify: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "2")]
    pub live: ::core::option::Option<Live>,
    ///
    #[prost(message, optional, tag = "3")]
    pub vip: ::core::option::Option<Vip>,
    ///
    #[prost(int64, repeated, tag = "4")]
    pub assists: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(int64, tag = "5")]
    pub fans: i64,
    ///
    #[prost(string, tag = "6")]
    pub arc_count: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub nft_face_icon: ::core::option::Option<NftFaceIcon>,
    ///
    #[prost(message, optional, tag = "8")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationCard {
    ///
    #[prost(int32, tag = "1")]
    pub start_time: i32,
    ///
    #[prost(int32, tag = "2")]
    pub end_time: i32,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub button_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub content: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationCardNew {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub from: i32,
    ///
    #[prost(int32, tag = "3")]
    pub to: i32,
    ///
    #[prost(bool, tag = "4")]
    pub status: bool,
    ///
    #[prost(enumeration = "OperationCardType", tag = "5")]
    pub card_type: i32,
    ///
    #[prost(enumeration = "BizType", tag = "8")]
    pub biz_type: i32,
    ///
    #[prost(oneof = "operation_card_new::Param", tags = "9, 10, 11, 12")]
    pub param: ::core::option::Option<operation_card_new::Param>,
}
/// Nested message and enum types in `OperationCardNew`.
pub mod operation_card_new {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Param {
        ///
        #[prost(message, tag = "9")]
        Follow(super::BizFollowVideoParam),
        ///
        #[prost(message, tag = "10")]
        Reserve(super::BizReserveActivityParam),
        ///
        #[prost(message, tag = "11")]
        Jump(super::BizJumpLinkParam),
        ///
        #[prost(message, tag = "12")]
        Game(super::BizReserveGameParam),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationCardV2 {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub from: i32,
    ///
    #[prost(int32, tag = "3")]
    pub to: i32,
    ///
    #[prost(bool, tag = "4")]
    pub status: bool,
    ///
    #[prost(enumeration = "BizType", tag = "5")]
    pub biz_type: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub content: ::core::option::Option<OperationCardV2Content>,
    ///
    #[prost(oneof = "operation_card_v2::Param", tags = "7, 8, 9, 10")]
    pub param: ::core::option::Option<operation_card_v2::Param>,
}
/// Nested message and enum types in `OperationCardV2`.
pub mod operation_card_v2 {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Param {
        ///
        #[prost(message, tag = "7")]
        Follow(super::BizFollowVideoParam),
        ///
        #[prost(message, tag = "8")]
        Reserve(super::BizReserveActivityParam),
        ///
        #[prost(message, tag = "9")]
        Jump(super::BizJumpLinkParam),
        ///
        #[prost(message, tag = "10")]
        Game(super::BizReserveGameParam),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationCardV2Content {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub button_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub button_selected_title: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "6")]
    pub show_selected: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationRelate {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub relate_item: ::prost::alloc::vec::Vec<RelateItem>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub ai_relate_item: ::prost::alloc::vec::Vec<Relate>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    ///
    #[prost(bool, tag = "1")]
    pub status: bool,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub button_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub button_selected_title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub season_stat_view: i64,
    ///
    #[prost(int64, tag = "6")]
    pub season_stat_danmaku: i64,
    ///
    #[prost(enumeration = "BizType", tag = "7")]
    pub order_type: i32,
    ///
    #[prost(string, tag = "10")]
    pub intro: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub season_stat_view_vt: ::core::option::Option<StatInfo>,
    ///
    #[prost(oneof = "order::OrderParam", tags = "8, 9")]
    pub order_param: ::core::option::Option<order::OrderParam>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OrderParam {
        ///
        #[prost(message, tag = "8")]
        Reserve(super::BizReserveActivityParam),
        ///
        #[prost(message, tag = "9")]
        FavSeason(super::BizFavSeasonParam),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayAv {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayToast {
    ///
    #[prost(enumeration = "PlayToastEnum", tag = "1")]
    pub business: i32,
    ///
    #[prost(string, tag = "2")]
    pub icon_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerAutomate {
    ///
    #[prost(int64, tag = "1")]
    pub daily_max: i64,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerIcon {
    ///
    #[prost(string, tag = "1")]
    pub url1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub hash1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub hash2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub drag_left_png: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub middle_png: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub drag_right_png: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub drag_data: ::core::option::Option<IconData>,
    ///
    #[prost(message, optional, tag = "9")]
    pub nodrag_data: ::core::option::Option<IconData>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRelatesReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<Relate>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRelatesReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(string, tag = "7")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub from_track_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointMaterial {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "MaterialSource", tag = "2")]
    pub material_source: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PowerIconStyle {
    ///
    #[prost(string, tag = "1")]
    pub icon_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_night_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub icon_width: i64,
    ///
    #[prost(int64, tag = "4")]
    pub icon_height: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Premiere {
    ///
    #[prost(enumeration = "PremiereState", tag = "1")]
    pub premiere_state: i32,
    ///
    #[prost(int64, tag = "2")]
    pub start_time: i64,
    ///
    #[prost(int64, tag = "3")]
    pub service_time: i64,
    ///
    #[prost(int64, tag = "4")]
    pub room_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PremiereArchiveReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub premiere: ::core::option::Option<Premiere>,
    ///
    #[prost(bool, tag = "2")]
    pub risk_status: bool,
    ///
    #[prost(string, tag = "3")]
    pub risk_reason: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PremiereArchiveReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PremiereReserve {
    ///
    #[prost(int64, tag = "1")]
    pub reserve_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub count: i64,
    ///
    #[prost(bool, tag = "3")]
    pub is_follow: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PremiereResource {
    ///
    #[prost(message, optional, tag = "1")]
    pub premiere: ::core::option::Option<Premiere>,
    ///
    #[prost(message, optional, tag = "2")]
    pub reserve: ::core::option::Option<PremiereReserve>,
    ///
    #[prost(message, optional, tag = "3")]
    pub text: ::core::option::Option<PremiereText>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PremiereText {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub online_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub online_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub online_icon_dark: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub intro_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub intro_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub guidance_pulldown: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub guidance_entry: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub intro_icon_night: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullClientAction {
    ///
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub pull_action: bool,
    ///
    #[prost(string, tag = "3")]
    pub params: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RabbitYear {
    ///
    #[prost(message, optional, tag = "1")]
    pub player_automate: ::core::option::Option<PlayerAutomate>,
    ///
    #[prost(message, optional, tag = "2")]
    pub dm_summon: ::core::option::Option<DmSummon>,
    ///
    #[prost(message, optional, tag = "3")]
    pub half_screen: ::core::option::Option<HalfScreen>,
    ///
    #[prost(message, optional, tag = "4")]
    pub special_dm: ::core::option::Option<SpecialDm>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rank {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankInfo {
    ///
    #[prost(string, tag = "1")]
    pub icon_url_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_url_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bkg_night_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bkg_day_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub font_night_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub font_day_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub rank_content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub rank_link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReasonStyle {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub border_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub border_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bg_style: i32,
    ///
    #[prost(int32, tag = "9")]
    pub selected: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecDislike {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub closed_sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub paste_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub closed_paste_text: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub dislike_reason: ::prost::alloc::vec::Vec<DislikeReasons>,
    ///
    #[prost(string, tag = "7")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub closed_toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecThreePoint {
    ///
    #[prost(message, optional, tag = "1")]
    pub dislike: ::core::option::Option<RecDislike>,
    ///
    #[prost(message, optional, tag = "2")]
    pub feedback: ::core::option::Option<RecDislike>,
    ///
    #[prost(bool, tag = "3")]
    pub watch_later: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshPage {
    ///
    #[prost(int32, tag = "1")]
    pub refreshable: i32,
    ///
    #[prost(int32, tag = "2")]
    pub refresh_icon: i32,
    ///
    #[prost(string, tag = "3")]
    pub refresh_text: ::prost::alloc::string::String,
    ///
    #[prost(float, tag = "4")]
    pub refresh_show: f32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectPage {
    ///
    #[prost(enumeration = "RejectPageEnum", tag = "1")]
    pub business: i32,
    ///
    #[prost(string, tag = "2")]
    pub pic: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub primary_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub secondary_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub button: ::core::option::Option<Button>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relate {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub pic: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub author: ::core::option::Option<super::super::archive::v1::Author>,
    ///
    #[prost(message, optional, tag = "5")]
    pub stat: ::core::option::Option<super::super::archive::v1::Stat>,
    ///
    #[prost(int64, tag = "6")]
    pub duration: i64,
    ///
    #[prost(string, tag = "7")]
    pub goto: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub param: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "11")]
    pub rating: f64,
    ///
    #[prost(string, tag = "12")]
    pub reserve: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "15")]
    pub rcmd_reason: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub badge: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "17")]
    pub cid: i64,
    ///
    #[prost(int32, tag = "18")]
    pub season_type: i32,
    ///
    #[prost(int32, tag = "19")]
    pub rating_count: i32,
    ///
    #[prost(string, tag = "20")]
    pub tag_name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "21")]
    pub pack_info: ::core::option::Option<PackInfo>,
    ///
    #[prost(message, optional, tag = "22")]
    pub notice: ::core::option::Option<Notice>,
    ///
    #[prost(message, optional, tag = "23")]
    pub button: ::core::option::Option<Button>,
    ///
    #[prost(string, tag = "24")]
    pub trackid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "25")]
    pub new_card: i32,
    ///
    #[prost(message, optional, tag = "26")]
    pub rcmd_reason_style: ::core::option::Option<ReasonStyle>,
    ///
    #[prost(string, tag = "27")]
    pub cover_gif: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "28")]
    pub cm: ::core::option::Option<Cm>,
    ///
    #[prost(int64, tag = "29")]
    pub reserve_status: i64,
    ///
    #[prost(string, tag = "30")]
    pub rcmd_reason_extra: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "31")]
    pub rec_three_point: ::core::option::Option<RecThreePoint>,
    ///
    #[prost(string, tag = "32")]
    pub unique_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "33")]
    pub material_id: i64,
    ///
    #[prost(int64, tag = "34")]
    pub from_source_type: i64,
    ///
    #[prost(string, tag = "35")]
    pub from_source_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "36")]
    pub dimension: ::core::option::Option<super::super::archive::v1::Dimension>,
    ///
    #[prost(string, tag = "37")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "38")]
    pub badge_style: ::core::option::Option<ReasonStyle>,
    ///
    #[prost(message, optional, tag = "39")]
    pub power_icon_style: ::core::option::Option<PowerIconStyle>,
    ///
    #[prost(string, tag = "40")]
    pub reserve_status_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "41")]
    pub dislike_report_data: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "42")]
    pub rank_info_game: ::core::option::Option<RankInfo>,
    ///
    #[prost(string, tag = "43")]
    pub first_frame: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "44")]
    pub game_recommend_reason: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "45")]
    pub wiki_info_game: ::core::option::Option<WikiInfo>,
    ///
    #[prost(message, optional, tag = "46")]
    pub live_info: ::core::option::Option<LiveInfo>,
    ///
    #[prost(message, optional, tag = "47")]
    pub stat_v2: ::core::option::Option<ArchiveStat>,
    ///
    #[prost(string, tag = "48")]
    pub report_flow_data: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelateItem {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub use_default_browser: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelateTab {
    ///
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatesFeedReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<Relate>,
    ///
    #[prost(bool, tag = "2")]
    pub has_next: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatesFeedReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "7")]
    pub relates_page: i64,
    ///
    #[prost(string, tag = "8")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub autoplay: i32,
    ///
    #[prost(string, tag = "10")]
    pub from_track_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub biz_extra: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "12")]
    pub device_type: i64,
    ///
    #[prost(string, tag = "13")]
    pub ad_extra: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "14")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
    ///
    #[prost(int32, tag = "15")]
    pub refresh_num: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyStyle {
    ///
    #[prost(string, tag = "1")]
    pub badge_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub badge_text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub badge_type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqUser {
    ///
    #[prost(int32, tag = "1")]
    pub attention: i32,
    ///
    #[prost(int32, tag = "2")]
    pub guest_attention: i32,
    ///
    #[prost(int32, tag = "3")]
    pub favorite: i32,
    ///
    #[prost(int32, tag = "4")]
    pub like: i32,
    ///
    #[prost(int32, tag = "5")]
    pub dislike: i32,
    ///
    #[prost(int32, tag = "6")]
    pub coin: i32,
    ///
    #[prost(int32, tag = "7")]
    pub attention_level: i32,
    ///
    #[prost(int32, tag = "8")]
    pub fav_season: i32,
    ///
    #[prost(message, optional, tag = "9")]
    pub elec_plus_btn: ::core::option::Option<Button>,
    ///
    #[prost(message, optional, tag = "10")]
    pub elec_plus: ::core::option::Option<ELecPlus>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReserveReply {
    ///
    #[prost(int64, tag = "1")]
    pub reserve_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReserveReq {
    ///
    #[prost(int64, tag = "1")]
    pub reserve_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub reserve_action: i64,
    ///
    #[prost(int64, tag = "3")]
    pub up_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Restriction {
    ///
    #[prost(bool, tag = "1")]
    pub is_teenagers: bool,
    ///
    #[prost(bool, tag = "2")]
    pub is_lessons: bool,
    ///
    #[prost(bool, tag = "3")]
    pub is_review: bool,
    ///
    #[prost(bool, tag = "4")]
    pub disable_rcmd: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Season {
    ///
    #[prost(string, tag = "1")]
    pub allow_download: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub season_id: i64,
    ///
    #[prost(int32, tag = "3")]
    pub is_jump: i32,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub is_finish: i32,
    ///
    #[prost(int64, tag = "7")]
    pub newest_ep_id: i64,
    ///
    #[prost(string, tag = "8")]
    pub newest_ep_index: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub total_count: i64,
    ///
    #[prost(int32, tag = "10")]
    pub weekday: i32,
    ///
    #[prost(message, optional, tag = "11")]
    pub user_season: ::core::option::Option<UserSeason>,
    ///
    #[prost(message, optional, tag = "12")]
    pub player: ::core::option::Option<SeasonPlayer>,
    ///
    #[prost(string, tag = "13")]
    pub ogv_playurl: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonActivityRecordReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub activity: ::core::option::Option<UgcSeasonActivity>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonActivityRecordReq {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub activity_id: i64,
    ///
    #[prost(int32, tag = "3")]
    pub action: i32,
    ///
    #[prost(int64, tag = "4")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub scene: i64,
    ///
    #[prost(string, tag = "7")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub action_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonPlayer {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub vid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(string, tag = "4")]
    pub from: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub season: ::core::option::Option<UgcSeason>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonReq {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonShow {
    ///
    #[prost(string, tag = "1")]
    pub button_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub join_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub rule_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub checkin_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub checkin_prompt: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonWidgetExposeReply {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub activity_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonWidgetExposeReq {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub activity_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "7")]
    pub scene: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Section {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub r#type: i64,
    ///
    #[prost(message, repeated, tag = "4")]
    pub episodes: ::prost::alloc::vec::Vec<Episode>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShortFormVideoDownloadReply {
    ///
    #[prost(bool, tag = "1")]
    pub has_download_url: bool,
    ///
    #[prost(string, tag = "2")]
    pub download_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub md5: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub size: i64,
    ///
    #[prost(string, tag = "5")]
    pub backup_download_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShortFormVideoDownloadReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub buvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub mobi_app: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub build: i64,
    ///
    #[prost(string, tag = "7")]
    pub device: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub platform: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub restriction: ::core::option::Option<Restriction>,
    ///
    #[prost(string, tag = "11")]
    pub tf_isp: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecialCell {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub cell_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub cell_bgcolor: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub cell_bgcolor_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub param: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub page_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub jump_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub end_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub end_icon_night: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "15")]
    pub notes_count: i64,
    ///
    #[prost(message, optional, tag = "16")]
    pub cell_fluid: ::core::option::Option<CellFluid>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpecialDm {
    ///
    #[prost(int64, tag = "1")]
    pub start: i64,
    ///
    #[prost(int64, tag = "2")]
    pub end: i64,
    ///
    #[prost(bool, tag = "3")]
    pub is_display: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Staff {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub official_verify: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "6")]
    pub vip: ::core::option::Option<Vip>,
    ///
    #[prost(int32, tag = "7")]
    pub attention: i32,
    ///
    #[prost(int32, tag = "8")]
    pub label_style: i32,
    ///
    #[prost(message, optional, tag = "9")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardCard {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub button_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub button_selected_title: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub show_selected: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatInfo {
    ///
    #[prost(int32, tag = "1")]
    pub icon: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub pure_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TfInfoReply {
    ///
    #[prost(int64, tag = "1")]
    pub tips_id: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub tf_toast: ::core::option::Option<TfToast>,
    ///
    #[prost(message, optional, tag = "3")]
    pub tf_panel_customized: ::core::option::Option<TfPanelCustomized>,
    ///
    #[prost(bool, tag = "4")]
    pub user_flag_new: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TfInfoReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TfPanelCustomized {
    ///
    #[prost(string, tag = "1")]
    pub right_btn_img: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub right_btn_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub right_btn_text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub right_btn_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub main_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub operator: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, message", tag = "7")]
    pub sub_panel: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SubTfPanel,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TfToast {
    ///
    #[prost(string, tag = "1")]
    pub btn_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub btn_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TIcon {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tab {
    ///
    #[prost(string, tag = "1")]
    pub background: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "TabOtype", tag = "2")]
    pub otype: i32,
    ///
    #[prost(int64, tag = "3")]
    pub oid: i64,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "TabStyle", tag = "5")]
    pub style: i32,
    ///
    #[prost(string, tag = "6")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub text_color_selected: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub pic: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub id: i64,
    ///
    #[prost(message, optional, tag = "11")]
    pub ad_tab_info: ::core::option::Option<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabModule {
    ///
    #[prost(message, repeated, tag = "1")]
    pub ext_tabs: ::prost::alloc::vec::Vec<ExtTab>,
    ///
    #[prost(int32, tag = "2")]
    pub idx: i32,
    ///
    #[prost(string, tag = "3")]
    pub protocol_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tag {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub likes: i64,
    ///
    #[prost(int64, tag = "4")]
    pub hates: i64,
    ///
    #[prost(int32, tag = "5")]
    pub liked: i32,
    ///
    #[prost(int32, tag = "6")]
    pub hated: i32,
    ///
    #[prost(string, tag = "7")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub tag_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcSeason {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub intro: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "5")]
    pub sections: ::prost::alloc::vec::Vec<Section>,
    ///
    #[prost(message, optional, tag = "6")]
    pub stat: ::core::option::Option<UgcSeasonStat>,
    ///
    #[prost(string, tag = "7")]
    pub label_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub label_text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub label_bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub label_text_night_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub label_bg_night_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub desc_right: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "13")]
    pub ep_count: i64,
    ///
    #[prost(enumeration = "SeasonType", tag = "14")]
    pub season_type: i32,
    ///
    #[prost(bool, tag = "15")]
    pub show_continual_button: bool,
    ///
    #[prost(int64, tag = "16")]
    pub ep_num: i64,
    ///
    #[prost(bool, tag = "17")]
    pub season_pay: bool,
    ///
    #[prost(message, optional, tag = "18")]
    pub goods_info: ::core::option::Option<GoodsInfo>,
    ///
    #[prost(message, optional, tag = "19")]
    pub pay_button: ::core::option::Option<ButtonStyle>,
    ///
    #[prost(string, tag = "20")]
    pub label_text_new: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "21")]
    pub activity: ::core::option::Option<UgcSeasonActivity>,
    ///
    #[prost(string, repeated, tag = "22")]
    pub season_ability: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, optional, tag = "23")]
    pub stat_v2: ::core::option::Option<UgcSeasonStatV2>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcSeasonActivity {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub activity_id: i64,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub intro: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub day_count: i32,
    ///
    #[prost(int32, tag = "7")]
    pub user_count: i32,
    ///
    #[prost(int64, tag = "8")]
    pub join_deadline: i64,
    ///
    #[prost(int64, tag = "9")]
    pub activity_deadline: i64,
    ///
    #[prost(int32, tag = "10")]
    pub checkin_view_time: i32,
    ///
    #[prost(bool, tag = "11")]
    pub new_activity: bool,
    ///
    #[prost(message, optional, tag = "12")]
    pub user_activity: ::core::option::Option<UserActivity>,
    ///
    #[prost(message, optional, tag = "13")]
    pub season_show: ::core::option::Option<SeasonShow>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UgcSeasonStat {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub view: i32,
    ///
    #[prost(int32, tag = "3")]
    pub danmaku: i32,
    ///
    #[prost(int32, tag = "4")]
    pub reply: i32,
    ///
    #[prost(int32, tag = "5")]
    pub fav: i32,
    ///
    #[prost(int32, tag = "6")]
    pub coin: i32,
    ///
    #[prost(int32, tag = "7")]
    pub share: i32,
    ///
    #[prost(int32, tag = "8")]
    pub now_rank: i32,
    ///
    #[prost(int32, tag = "9")]
    pub his_rank: i32,
    ///
    #[prost(int32, tag = "10")]
    pub like: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcSeasonStatV2 {
    ///
    #[prost(message, optional, tag = "11")]
    pub view_vt: ::core::option::Option<StatInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpAct {
    ///
    #[prost(int64, tag = "1")]
    pub sid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub statement: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub button: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpLikeImg {
    ///
    #[prost(string, tag = "1")]
    pub pre_img: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub suc_img: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub r#type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpViewMaterial {
    ///
    #[prost(message, optional, tag = "1")]
    pub like_info: ::core::option::Option<InteractArea>,
    ///
    #[prost(string, tag = "2")]
    pub data_center_info: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub tab_module: ::core::option::Option<TabModule>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpperInfos {
    ///
    #[prost(int64, tag = "1")]
    pub fans_count: i64,
    ///
    #[prost(int64, tag = "2")]
    pub arc_count_last_half_year: i64,
    ///
    #[prost(int64, tag = "3")]
    pub first_up_dates: i64,
    ///
    #[prost(int64, tag = "4")]
    pub total_play_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub follower: i64,
    ///
    #[prost(int64, tag = "5")]
    pub is_attention: i64,
    ///
    #[prost(int64, tag = "6")]
    pub is_interrelation: i64,
    ///
    #[prost(int64, tag = "7")]
    pub is_follow: i64,
    ///
    #[prost(string, tag = "8")]
    pub interact_desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActivity {
    ///
    #[prost(int32, tag = "1")]
    pub user_state: i32,
    ///
    #[prost(int64, tag = "2")]
    pub last_checkin_date: i64,
    ///
    #[prost(int32, tag = "3")]
    pub checkin_today: i32,
    ///
    #[prost(int32, tag = "4")]
    pub user_day_count: i32,
    ///
    #[prost(int32, tag = "5")]
    pub user_view_time: i32,
    ///
    #[prost(string, tag = "6")]
    pub portrait: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserGarb {
    ///
    #[prost(string, tag = "1")]
    pub url_image_ani_cut: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub like_toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserRelation {
    ///
    #[prost(message, optional, tag = "1")]
    pub like_info: ::core::option::Option<InteractArea>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSeason {
    ///
    #[prost(string, tag = "1")]
    pub attention: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoGuide {
    ///
    #[prost(message, repeated, tag = "1")]
    pub attention: ::prost::alloc::vec::Vec<Attention>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub command_dms: ::prost::alloc::vec::Vec<CommandDm>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub operation_card: ::prost::alloc::vec::Vec<OperationCard>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub operation_card_new: ::prost::alloc::vec::Vec<OperationCardNew>,
    ///
    #[prost(message, optional, tag = "5")]
    pub contract_card: ::core::option::Option<ContractCard>,
    ///
    #[prost(message, repeated, tag = "6")]
    pub cards_second: ::prost::alloc::vec::Vec<OperationCardV2>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoPoint {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub from: i64,
    ///
    #[prost(int64, tag = "3")]
    pub to: i64,
    ///
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub logo_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoShot {
    ///
    #[prost(string, tag = "1")]
    pub pv_data: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub img_x_len: i32,
    ///
    #[prost(int32, tag = "3")]
    pub img_y_len: i32,
    ///
    #[prost(int32, tag = "4")]
    pub img_x_size: i32,
    ///
    #[prost(int32, tag = "5")]
    pub img_y_size: i32,
    ///
    #[prost(string, repeated, tag = "6")]
    pub image: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewMaterial {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub jump_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewMaterialReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub material_res: ::prost::alloc::vec::Vec<MaterialRes>,
    ///
    #[prost(message, optional, tag = "2")]
    pub material_left: ::core::option::Option<MaterialLeft>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewMaterialReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewPage {
    ///
    #[prost(message, optional, tag = "1")]
    pub page: ::core::option::Option<super::super::archive::v1::Page>,
    ///
    #[prost(message, optional, tag = "2")]
    pub audio: ::core::option::Option<Audio>,
    ///
    #[prost(message, optional, tag = "3")]
    pub dm: ::core::option::Option<Dm>,
    ///
    #[prost(string, tag = "4")]
    pub download_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub download_subtitle: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewProgressReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub video_guide: ::core::option::Option<VideoGuide>,
    ///
    #[prost(message, optional, tag = "2")]
    pub chronos: ::core::option::Option<Chronos>,
    ///
    #[prost(message, optional, tag = "3")]
    pub arc_shot: ::core::option::Option<VideoShot>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub points: ::prost::alloc::vec::Vec<VideoPoint>,
    ///
    #[prost(message, optional, tag = "5")]
    pub point_material: ::core::option::Option<PointMaterial>,
    ///
    #[prost(bool, tag = "6")]
    pub point_permanent: bool,
    ///
    #[prost(message, repeated, tag = "7")]
    pub buzzword_periods: ::prost::alloc::vec::Vec<BuzzwordConfig>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewProgressReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub up_mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub engine_version: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub message_protocol: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub service_key: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub arc: ::core::option::Option<super::super::archive::v1::Arc>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub pages: ::prost::alloc::vec::Vec<ViewPage>,
    ///
    #[prost(message, optional, tag = "3")]
    pub owner_ext: ::core::option::Option<OnwerExt>,
    ///
    #[prost(message, optional, tag = "4")]
    pub req_user: ::core::option::Option<ReqUser>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub tag: ::prost::alloc::vec::Vec<Tag>,
    ///
    #[prost(map = "string, message", tag = "6")]
    pub t_icon: ::std::collections::HashMap<::prost::alloc::string::String, TIcon>,
    ///
    #[prost(message, optional, tag = "7")]
    pub season: ::core::option::Option<Season>,
    ///
    #[prost(message, optional, tag = "8")]
    pub elec_rank: ::core::option::Option<ElecRank>,
    ///
    #[prost(message, optional, tag = "9")]
    pub history: ::core::option::Option<History>,
    ///
    #[prost(message, repeated, tag = "10")]
    pub relates: ::prost::alloc::vec::Vec<Relate>,
    ///
    #[prost(message, optional, tag = "11")]
    pub dislike: ::core::option::Option<Dislike>,
    ///
    #[prost(message, optional, tag = "12")]
    pub player_icon: ::core::option::Option<PlayerIcon>,
    ///
    #[prost(string, tag = "13")]
    pub vip_active: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "15")]
    pub honor: ::core::option::Option<Honor>,
    ///
    #[prost(message, repeated, tag = "16")]
    pub relate_tab: ::prost::alloc::vec::Vec<RelateTab>,
    ///
    #[prost(string, tag = "17")]
    pub activity_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "18")]
    pub bgm: ::prost::alloc::vec::Vec<Bgm>,
    ///
    #[prost(message, repeated, tag = "19")]
    pub staff: ::prost::alloc::vec::Vec<Staff>,
    ///
    #[prost(string, tag = "20")]
    pub argue_msg: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "21")]
    pub short_link: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "22")]
    pub play_param: i32,
    ///
    #[prost(message, optional, tag = "23")]
    pub label: ::core::option::Option<Label>,
    ///
    #[prost(message, optional, tag = "24")]
    pub ugc_season: ::core::option::Option<UgcSeason>,
    ///
    #[prost(message, optional, tag = "25")]
    pub config: ::core::option::Option<Config>,
    ///
    #[prost(string, tag = "26")]
    pub share_subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "27")]
    pub interaction: ::core::option::Option<Interaction>,
    ///
    #[prost(enumeration = "ECode", tag = "28")]
    pub ecode: i32,
    ///
    #[prost(message, optional, tag = "29")]
    pub custom_config: ::core::option::Option<CustomConfig>,
    ///
    #[prost(message, repeated, tag = "30")]
    pub cms: ::prost::alloc::vec::Vec<Cm>,
    ///
    #[prost(message, optional, tag = "31")]
    pub cm_config: ::core::option::Option<CmConfig>,
    ///
    #[prost(message, optional, tag = "32")]
    pub tab: ::core::option::Option<Tab>,
    ///
    #[prost(message, optional, tag = "33")]
    pub rank: ::core::option::Option<Rank>,
    ///
    #[prost(message, optional, tag = "34")]
    pub tf_panel_customized: ::core::option::Option<TfPanelCustomized>,
    ///
    #[prost(message, optional, tag = "35")]
    pub up_act: ::core::option::Option<UpAct>,
    ///
    #[prost(message, optional, tag = "36")]
    pub user_garb: ::core::option::Option<UserGarb>,
    ///
    #[prost(message, optional, tag = "37")]
    pub activity_season: ::core::option::Option<ActivitySeason>,
    ///
    #[prost(string, tag = "38")]
    pub badge_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "39")]
    pub live_order_info: ::core::option::Option<LiveOrderInfo>,
    ///
    #[prost(message, repeated, tag = "40")]
    pub desc_v2: ::prost::alloc::vec::Vec<DescV2>,
    ///
    #[prost(message, optional, tag = "41")]
    pub cm_ipad: ::core::option::Option<CmIpad>,
    ///
    #[prost(message, repeated, tag = "42")]
    pub sticker: ::prost::alloc::vec::Vec<ViewMaterial>,
    ///
    #[prost(message, optional, tag = "43")]
    pub up_like_img: ::core::option::Option<UpLikeImg>,
    ///
    #[prost(message, optional, tag = "44")]
    pub like_custom: ::core::option::Option<LikeCustom>,
    ///
    #[prost(message, repeated, tag = "45")]
    pub desc_tag: ::prost::alloc::vec::Vec<Tag>,
    ///
    #[prost(message, optional, tag = "46")]
    pub special_cell: ::core::option::Option<SpecialCell>,
    ///
    #[prost(message, optional, tag = "47")]
    pub online: ::core::option::Option<Online>,
    ///
    #[prost(message, optional, tag = "48")]
    pub cm_under_player: ::core::option::Option<::prost_types::Any>,
    ///
    #[prost(message, repeated, tag = "49")]
    pub video_source: ::prost::alloc::vec::Vec<ViewMaterial>,
    ///
    #[prost(message, repeated, tag = "50")]
    pub special_cell_new: ::prost::alloc::vec::Vec<SpecialCell>,
    ///
    #[prost(message, optional, tag = "51")]
    pub premiere: ::core::option::Option<PremiereResource>,
    ///
    #[prost(bool, tag = "52")]
    pub refresh_special_cell: bool,
    ///
    #[prost(message, optional, tag = "53")]
    pub material_left: ::core::option::Option<MaterialLeft>,
    ///
    #[prost(int64, tag = "54")]
    pub notes_count: i64,
    ///
    #[prost(message, optional, tag = "55")]
    pub pull_action: ::core::option::Option<PullClientAction>,
    ///
    #[prost(message, optional, tag = "56")]
    pub arc_extra: ::core::option::Option<ArcExtra>,
    ///
    #[prost(message, optional, tag = "57")]
    pub pagination: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
    ///
    #[prost(message, optional, tag = "58")]
    pub like_animation: ::core::option::Option<LikeAnimation>,
    ///
    #[prost(message, optional, tag = "59")]
    pub reply_preface: ::core::option::Option<ReplyStyle>,
    ///
    #[prost(message, optional, tag = "60")]
    pub refresh_page: ::core::option::Option<RefreshPage>,
    ///
    #[prost(message, optional, tag = "61")]
    pub coin_custom: ::core::option::Option<CoinCustom>,
    ///
    #[prost(message, optional, tag = "62")]
    pub control_config: ::core::option::Option<ControlConfig>,
    ///
    #[prost(message, optional, tag = "63")]
    pub up_view_material: ::core::option::Option<UpViewMaterial>,
    ///
    #[prost(message, optional, tag = "64")]
    pub user_relation: ::core::option::Option<UserRelation>,
    ///
    #[prost(message, optional, tag = "65")]
    pub coin_style: ::core::option::Option<CoinStyle>,
    ///
    #[prost(message, optional, tag = "66")]
    pub rabbit_year: ::core::option::Option<RabbitYear>,
    ///
    #[prost(message, optional, tag = "67")]
    pub stat_v2: ::core::option::Option<ArchiveStat>,
    ///
    #[prost(message, optional, tag = "68")]
    pub charging_plus: ::core::option::Option<ChargingPlus>,
    ///
    #[prost(message, optional, tag = "69")]
    pub reject_page: ::core::option::Option<RejectPage>,
    ///
    #[prost(message, repeated, tag = "70")]
    pub play_toast: ::prost::alloc::vec::Vec<PlayToast>,
    ///
    #[prost(enumeration = "ViewState", tag = "71")]
    pub view_state: i32,
    ///
    #[prost(message, optional, tag = "72")]
    pub argue_bar: ::core::option::Option<ArgueBar>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub trackid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub ad_extra: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "7")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "8")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "9")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "10")]
    pub fourk: i32,
    ///
    #[prost(string, tag = "11")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "13")]
    pub autoplay: i32,
    ///
    #[prost(message, optional, tag = "14")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(string, tag = "15")]
    pub page_version: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub biz_extra: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "17")]
    pub device_type: i64,
    ///
    #[prost(int64, tag = "18")]
    pub relates_page: i64,
    ///
    #[prost(string, tag = "19")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "20")]
    pub in_feed_play: i32,
    ///
    #[prost(string, tag = "21")]
    pub play_mode: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "22")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
    ///
    #[prost(int32, tag = "23")]
    pub refresh: i32,
    ///
    #[prost(int32, tag = "24")]
    pub refresh_num: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewTagReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub special_cell_new: ::prost::alloc::vec::Vec<SpecialCell>,
    ///
    #[prost(message, optional, tag = "2")]
    pub material_left: ::core::option::Option<MaterialLeft>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewTagReq {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vip {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub due_date: i64,
    ///
    #[prost(string, tag = "3")]
    pub due_remark: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub access_status: i32,
    ///
    #[prost(int32, tag = "5")]
    pub vip_status: i32,
    ///
    #[prost(string, tag = "6")]
    pub vip_status_warn: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub theme_type: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub label: ::core::option::Option<VipLabel>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipLabel {
    ///
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub label_theme: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WikiInfo {
    ///
    #[prost(string, tag = "1")]
    pub wiki_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub wiki_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubTfPanel {
    ///
    #[prost(string, tag = "1")]
    pub right_btn_img: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub right_btn_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub right_btn_text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub right_btn_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub main_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub operator: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BizType {
    ///
    None = 0,
    ///
    FollowVideo = 1,
    ///
    ReserveActivity = 2,
    ///
    JumpLink = 3,
    ///
    FavSeason = 4,
    ///
    ReserveGame = 5,
}
impl BizType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "BizTypeNone",
            Self::FollowVideo => "BizTypeFollowVideo",
            Self::ReserveActivity => "BizTypeReserveActivity",
            Self::JumpLink => "BizTypeJumpLink",
            Self::FavSeason => "BizTypeFavSeason",
            Self::ReserveGame => "BizTypeReserveGame",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BizTypeNone" => Some(Self::None),
            "BizTypeFollowVideo" => Some(Self::FollowVideo),
            "BizTypeReserveActivity" => Some(Self::ReserveActivity),
            "BizTypeJumpLink" => Some(Self::JumpLink),
            "BizTypeFavSeason" => Some(Self::FavSeason),
            "BizTypeReserveGame" => Some(Self::ReserveGame),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Category {
    ///
    Unknown = 0,
    ///
    Season = 1,
}
impl Category {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "CategoryUnknown",
            Self::Season => "CategorySeason",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CategoryUnknown" => Some(Self::Unknown),
            "CategorySeason" => Some(Self::Season),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DescType {
    ///
    Unknown = 0,
    ///
    Text = 1,
    ///
    At = 2,
}
impl DescType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "DescTypeUnknown",
            Self::Text => "DescTypeText",
            Self::At => "DescTypeAt",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DescTypeUnknown" => Some(Self::Unknown),
            "DescTypeText" => Some(Self::Text),
            "DescTypeAt" => Some(Self::At),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECode {
    ///
    Default = 0,
    ///
    Code404 = 1,
    ///
    Codeversionlimit = 2,
}
impl ECode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "DEFAULT",
            Self::Code404 => "CODE404",
            Self::Codeversionlimit => "CODEVERSIONLIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT" => Some(Self::Default),
            "CODE404" => Some(Self::Code404),
            "CODEVERSIONLIMIT" => Some(Self::Codeversionlimit),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExtType {
    ///
    ExtNone = 0,
    ///
    ExtDataCenter = 1,
    ///
    ExtDataEarnings = 2,
}
impl ExtType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ExtNone => "ExtNone",
            Self::ExtDataCenter => "ExtDataCenter",
            Self::ExtDataEarnings => "ExtDataEarnings",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ExtNone" => Some(Self::ExtNone),
            "ExtDataCenter" => Some(Self::ExtDataCenter),
            "ExtDataEarnings" => Some(Self::ExtDataEarnings),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JumpShowType {
    ///
    JstDefault = 0,
    ///
    JstFullscreen = 1,
    ///
    JstHalfscreen = 2,
}
impl JumpShowType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::JstDefault => "JST_DEFAULT",
            Self::JstFullscreen => "JST_FULLSCREEN",
            Self::JstHalfscreen => "JST_HALFSCREEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JST_DEFAULT" => Some(Self::JstDefault),
            "JST_FULLSCREEN" => Some(Self::JstFullscreen),
            "JST_HALFSCREEN" => Some(Self::JstHalfscreen),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MaterialSource {
    ///
    Default = 0,
    ///
    BiJian = 1,
}
impl MaterialSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "Default",
            Self::BiJian => "BiJian",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Default" => Some(Self::Default),
            "BiJian" => Some(Self::BiJian),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationCardType {
    ///
    CardTypeNone = 0,
    ///
    CardTypeStandard = 1,
    ///
    CardTypeSkip = 2,
}
impl OperationCardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CardTypeNone => "CardTypeNone",
            Self::CardTypeStandard => "CardTypeStandard",
            Self::CardTypeSkip => "CardTypeSkip",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CardTypeNone" => Some(Self::CardTypeNone),
            "CardTypeStandard" => Some(Self::CardTypeStandard),
            "CardTypeSkip" => Some(Self::CardTypeSkip),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayState {
    ///
    Unknown = 0,
    ///
    Active = 1,
}
impl PayState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PayStateUnknown",
            Self::Active => "PayStateActive",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PayStateUnknown" => Some(Self::Unknown),
            "PayStateActive" => Some(Self::Active),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayToastEnum {
    ///
    PlaytoastUnknown = 0,
    ///
    PlaytoastChargingplus = 1,
}
impl PlayToastEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PlaytoastUnknown => "PLAYTOAST_UNKNOWN",
            Self::PlaytoastChargingplus => "PLAYTOAST_CHARGINGPLUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAYTOAST_UNKNOWN" => Some(Self::PlaytoastUnknown),
            "PLAYTOAST_CHARGINGPLUS" => Some(Self::PlaytoastChargingplus),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayerCardType {
    ///
    None = 0,
    ///
    Attention = 1,
    ///
    Operation = 2,
    ///
    Contract = 3,
}
impl PlayerCardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PlayerCardTypeNone",
            Self::Attention => "PlayerCardTypeAttention",
            Self::Operation => "PlayerCardTypeOperation",
            Self::Contract => "PlayerCardTypeContract",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayerCardTypeNone" => Some(Self::None),
            "PlayerCardTypeAttention" => Some(Self::Attention),
            "PlayerCardTypeOperation" => Some(Self::Operation),
            "PlayerCardTypeContract" => Some(Self::Contract),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PremiereState {
    ///
    PremiereNone = 0,
    ///
    PremiereBefore = 1,
    ///
    PremiereIn = 2,
    ///
    PremiereAfter = 3,
}
impl PremiereState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PremiereNone => "premiere_none",
            Self::PremiereBefore => "premiere_before",
            Self::PremiereIn => "premiere_in",
            Self::PremiereAfter => "premiere_after",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "premiere_none" => Some(Self::PremiereNone),
            "premiere_before" => Some(Self::PremiereBefore),
            "premiere_in" => Some(Self::PremiereIn),
            "premiere_after" => Some(Self::PremiereAfter),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RejectPageEnum {
    ///
    RejectpageUnknown = 0,
    ///
    RejectpageChargingplus = 1,
}
impl RejectPageEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RejectpageUnknown => "REJECTPAGE_UNKNOWN",
            Self::RejectpageChargingplus => "REJECTPAGE_CHARGINGPLUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REJECTPAGE_UNKNOWN" => Some(Self::RejectpageUnknown),
            "REJECTPAGE_CHARGINGPLUS" => Some(Self::RejectpageChargingplus),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SeasonType {
    ///
    Unknown = 0,
    ///
    Base = 1,
    ///
    Good = 2,
}
impl SeasonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Base => "Base",
            Self::Good => "Good",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "Base" => Some(Self::Base),
            "Good" => Some(Self::Good),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabOtype {
    ///
    UnknownOtype = 0,
    ///
    Url = 1,
    ///
    TopicNa = 2,
    ///
    CmUri = 3,
}
impl TabOtype {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownOtype => "UnknownOtype",
            Self::Url => "URL",
            Self::TopicNa => "TopicNA",
            Self::CmUri => "CmURI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownOtype" => Some(Self::UnknownOtype),
            "URL" => Some(Self::Url),
            "TopicNA" => Some(Self::TopicNa),
            "CmURI" => Some(Self::CmUri),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabStyle {
    ///
    UnknownStyle = 0,
    ///
    Text = 1,
    ///
    Pic = 2,
}
impl TabStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownStyle => "UnknownStyle",
            Self::Text => "Text",
            Self::Pic => "Pic",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownStyle" => Some(Self::UnknownStyle),
            "Text" => Some(Self::Text),
            "Pic" => Some(Self::Pic),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViewState {
    ///
    ViewNone = 0,
    ///
    ViewHostOnlySelf = 1,
}
impl ViewState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ViewNone => "ViewNone",
            Self::ViewHostOnlySelf => "ViewHostOnlySelf",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ViewNone" => Some(Self::ViewNone),
            "ViewHostOnlySelf" => Some(Self::ViewHostOnlySelf),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod legacy_view_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct LegacyViewClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LegacyViewClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LegacyViewClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LegacyViewClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn like(
            &mut self,
            request: impl tonic::IntoRequest<super::LikeReq>,
        ) -> std::result::Result<tonic::Response<super::LikeReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.LegacyView/Like",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.LegacyView", "Like"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod view_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct ViewClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ViewClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ViewClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ViewClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn add_contract(
            &mut self,
            request: impl tonic::IntoRequest<super::AddContractReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/AddContract",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "AddContract"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn cache_view(
            &mut self,
            request: impl tonic::IntoRequest<super::CacheViewReq>,
        ) -> std::result::Result<tonic::Response<super::CacheViewReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/CacheView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "CacheView"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn chronos_pkg(
            &mut self,
            request: impl tonic::IntoRequest<super::ChronosPkgReq>,
        ) -> std::result::Result<tonic::Response<super::Chronos>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ChronosPkg",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "ChronosPkg"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn click_activity_season(
            &mut self,
            request: impl tonic::IntoRequest<super::ClickActivitySeasonReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ClickActivitySeason",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.view.v1.View", "ClickActivitySeason"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn click_player_card(
            &mut self,
            request: impl tonic::IntoRequest<super::ClickPlayerCardReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ClickPlayerCard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "ClickPlayerCard"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn click_player_card_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::ClickPlayerCardReq>,
        ) -> std::result::Result<
            tonic::Response<super::ClickPlayerCardReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ClickPlayerCardV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.view.v1.View", "ClickPlayerCardV2"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn continuous_play(
            &mut self,
            request: impl tonic::IntoRequest<super::ContinuousPlayReq>,
        ) -> std::result::Result<
            tonic::Response<super::ContinuousPlayReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ContinuousPlay",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "ContinuousPlay"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn expose_player_card(
            &mut self,
            request: impl tonic::IntoRequest<super::ExposePlayerCardReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ExposePlayerCard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.view.v1.View", "ExposePlayerCard"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn feed_view(
            &mut self,
            request: impl tonic::IntoRequest<super::FeedViewReq>,
        ) -> std::result::Result<tonic::Response<super::FeedViewReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/FeedView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "FeedView"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_arcs_player(
            &mut self,
            request: impl tonic::IntoRequest<super::GetArcsPlayerReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetArcsPlayerReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/GetArcsPlayer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "GetArcsPlayer"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserReq>,
        ) -> std::result::Result<tonic::Response<super::GetUserReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "GetUser"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn player_relates(
            &mut self,
            request: impl tonic::IntoRequest<super::PlayerRelatesReq>,
        ) -> std::result::Result<
            tonic::Response<super::PlayerRelatesReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/PlayerRelates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "PlayerRelates"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn premiere_archive(
            &mut self,
            request: impl tonic::IntoRequest<super::PremiereArchiveReq>,
        ) -> std::result::Result<
            tonic::Response<super::PremiereArchiveReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/PremiereArchive",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "PremiereArchive"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn relates_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::RelatesFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::RelatesFeedReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/RelatesFeed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "RelatesFeed"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn reserve(
            &mut self,
            request: impl tonic::IntoRequest<super::ReserveReq>,
        ) -> std::result::Result<tonic::Response<super::ReserveReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/Reserve",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "Reserve"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn season(
            &mut self,
            request: impl tonic::IntoRequest<super::SeasonReq>,
        ) -> std::result::Result<tonic::Response<super::SeasonReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/Season",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "Season"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn season_activity_record(
            &mut self,
            request: impl tonic::IntoRequest<super::SeasonActivityRecordReq>,
        ) -> std::result::Result<
            tonic::Response<super::SeasonActivityRecordReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/SeasonActivityRecord",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.view.v1.View", "SeasonActivityRecord"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn season_widget_expose(
            &mut self,
            request: impl tonic::IntoRequest<super::SeasonWidgetExposeReq>,
        ) -> std::result::Result<
            tonic::Response<super::SeasonWidgetExposeReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/SeasonWidgetExpose",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.view.v1.View", "SeasonWidgetExpose"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn short_form_video_download(
            &mut self,
            request: impl tonic::IntoRequest<super::ShortFormVideoDownloadReq>,
        ) -> std::result::Result<
            tonic::Response<super::ShortFormVideoDownloadReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ShortFormVideoDownload",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.view.v1.View",
                        "ShortFormVideoDownload",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn tf_info(
            &mut self,
            request: impl tonic::IntoRequest<super::TfInfoReq>,
        ) -> std::result::Result<tonic::Response<super::TfInfoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/TFInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "TFInfo"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewReq>,
        ) -> std::result::Result<tonic::Response<super::ViewReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/View",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "View"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view_material(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewMaterialReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewMaterialReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ViewMaterial",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "ViewMaterial"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view_progress(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewProgressReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewProgressReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ViewProgress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "ViewProgress"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn view_tag(
            &mut self,
            request: impl tonic::IntoRequest<super::ViewTagReq>,
        ) -> std::result::Result<tonic::Response<super::ViewTagReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.view.v1.View/ViewTag",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.view.v1.View", "ViewTag"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod legacy_view_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LegacyViewServer.
    #[async_trait]
    pub trait LegacyView: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn like(
            &self,
            request: tonic::Request<super::LikeReq>,
        ) -> std::result::Result<tonic::Response<super::LikeReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct LegacyViewServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LegacyViewServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LegacyViewServer<T>
    where
        T: LegacyView,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.view.v1.LegacyView/Like" => {
                    #[allow(non_camel_case_types)]
                    struct LikeSvc<T: LegacyView>(pub Arc<T>);
                    impl<T: LegacyView> tonic::server::UnaryService<super::LikeReq>
                    for LikeSvc<T> {
                        type Response = super::LikeReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LikeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LegacyView>::like(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LikeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LegacyViewServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.view.v1.LegacyView";
    impl<T> tonic::server::NamedService for LegacyViewServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod view_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ViewServer.
    #[async_trait]
    pub trait View: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn add_contract(
            &self,
            request: tonic::Request<super::AddContractReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn cache_view(
            &self,
            request: tonic::Request<super::CacheViewReq>,
        ) -> std::result::Result<tonic::Response<super::CacheViewReply>, tonic::Status>;
        ///
        async fn chronos_pkg(
            &self,
            request: tonic::Request<super::ChronosPkgReq>,
        ) -> std::result::Result<tonic::Response<super::Chronos>, tonic::Status>;
        ///
        async fn click_activity_season(
            &self,
            request: tonic::Request<super::ClickActivitySeasonReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn click_player_card(
            &self,
            request: tonic::Request<super::ClickPlayerCardReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn click_player_card_v2(
            &self,
            request: tonic::Request<super::ClickPlayerCardReq>,
        ) -> std::result::Result<
            tonic::Response<super::ClickPlayerCardReply>,
            tonic::Status,
        >;
        ///
        async fn continuous_play(
            &self,
            request: tonic::Request<super::ContinuousPlayReq>,
        ) -> std::result::Result<
            tonic::Response<super::ContinuousPlayReply>,
            tonic::Status,
        >;
        ///
        async fn expose_player_card(
            &self,
            request: tonic::Request<super::ExposePlayerCardReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn feed_view(
            &self,
            request: tonic::Request<super::FeedViewReq>,
        ) -> std::result::Result<tonic::Response<super::FeedViewReply>, tonic::Status>;
        ///
        async fn get_arcs_player(
            &self,
            request: tonic::Request<super::GetArcsPlayerReq>,
        ) -> std::result::Result<
            tonic::Response<super::GetArcsPlayerReply>,
            tonic::Status,
        >;
        ///
        async fn get_user(
            &self,
            request: tonic::Request<super::GetUserReq>,
        ) -> std::result::Result<tonic::Response<super::GetUserReply>, tonic::Status>;
        ///
        async fn player_relates(
            &self,
            request: tonic::Request<super::PlayerRelatesReq>,
        ) -> std::result::Result<
            tonic::Response<super::PlayerRelatesReply>,
            tonic::Status,
        >;
        ///
        async fn premiere_archive(
            &self,
            request: tonic::Request<super::PremiereArchiveReq>,
        ) -> std::result::Result<
            tonic::Response<super::PremiereArchiveReply>,
            tonic::Status,
        >;
        ///
        async fn relates_feed(
            &self,
            request: tonic::Request<super::RelatesFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::RelatesFeedReply>,
            tonic::Status,
        >;
        ///
        async fn reserve(
            &self,
            request: tonic::Request<super::ReserveReq>,
        ) -> std::result::Result<tonic::Response<super::ReserveReply>, tonic::Status>;
        ///
        async fn season(
            &self,
            request: tonic::Request<super::SeasonReq>,
        ) -> std::result::Result<tonic::Response<super::SeasonReply>, tonic::Status>;
        ///
        async fn season_activity_record(
            &self,
            request: tonic::Request<super::SeasonActivityRecordReq>,
        ) -> std::result::Result<
            tonic::Response<super::SeasonActivityRecordReply>,
            tonic::Status,
        >;
        ///
        async fn season_widget_expose(
            &self,
            request: tonic::Request<super::SeasonWidgetExposeReq>,
        ) -> std::result::Result<
            tonic::Response<super::SeasonWidgetExposeReply>,
            tonic::Status,
        >;
        ///
        async fn short_form_video_download(
            &self,
            request: tonic::Request<super::ShortFormVideoDownloadReq>,
        ) -> std::result::Result<
            tonic::Response<super::ShortFormVideoDownloadReply>,
            tonic::Status,
        >;
        ///
        async fn tf_info(
            &self,
            request: tonic::Request<super::TfInfoReq>,
        ) -> std::result::Result<tonic::Response<super::TfInfoReply>, tonic::Status>;
        ///
        async fn view(
            &self,
            request: tonic::Request<super::ViewReq>,
        ) -> std::result::Result<tonic::Response<super::ViewReply>, tonic::Status>;
        ///
        async fn view_material(
            &self,
            request: tonic::Request<super::ViewMaterialReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewMaterialReply>,
            tonic::Status,
        >;
        ///
        async fn view_progress(
            &self,
            request: tonic::Request<super::ViewProgressReq>,
        ) -> std::result::Result<
            tonic::Response<super::ViewProgressReply>,
            tonic::Status,
        >;
        ///
        async fn view_tag(
            &self,
            request: tonic::Request<super::ViewTagReq>,
        ) -> std::result::Result<tonic::Response<super::ViewTagReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct ViewServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ViewServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ViewServer<T>
    where
        T: View,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.view.v1.View/AddContract" => {
                    #[allow(non_camel_case_types)]
                    struct AddContractSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::AddContractReq>
                    for AddContractSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddContractReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::add_contract(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddContractSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/CacheView" => {
                    #[allow(non_camel_case_types)]
                    struct CacheViewSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::CacheViewReq>
                    for CacheViewSvc<T> {
                        type Response = super::CacheViewReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CacheViewReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::cache_view(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CacheViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ChronosPkg" => {
                    #[allow(non_camel_case_types)]
                    struct ChronosPkgSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ChronosPkgReq>
                    for ChronosPkgSvc<T> {
                        type Response = super::Chronos;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ChronosPkgReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::chronos_pkg(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ChronosPkgSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ClickActivitySeason" => {
                    #[allow(non_camel_case_types)]
                    struct ClickActivitySeasonSvc<T: View>(pub Arc<T>);
                    impl<
                        T: View,
                    > tonic::server::UnaryService<super::ClickActivitySeasonReq>
                    for ClickActivitySeasonSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClickActivitySeasonReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::click_activity_season(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClickActivitySeasonSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ClickPlayerCard" => {
                    #[allow(non_camel_case_types)]
                    struct ClickPlayerCardSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ClickPlayerCardReq>
                    for ClickPlayerCardSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClickPlayerCardReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::click_player_card(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClickPlayerCardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ClickPlayerCardV2" => {
                    #[allow(non_camel_case_types)]
                    struct ClickPlayerCardV2Svc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ClickPlayerCardReq>
                    for ClickPlayerCardV2Svc<T> {
                        type Response = super::ClickPlayerCardReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClickPlayerCardReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::click_player_card_v2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClickPlayerCardV2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ContinuousPlay" => {
                    #[allow(non_camel_case_types)]
                    struct ContinuousPlaySvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ContinuousPlayReq>
                    for ContinuousPlaySvc<T> {
                        type Response = super::ContinuousPlayReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ContinuousPlayReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::continuous_play(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ContinuousPlaySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ExposePlayerCard" => {
                    #[allow(non_camel_case_types)]
                    struct ExposePlayerCardSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ExposePlayerCardReq>
                    for ExposePlayerCardSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExposePlayerCardReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::expose_player_card(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExposePlayerCardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/FeedView" => {
                    #[allow(non_camel_case_types)]
                    struct FeedViewSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::FeedViewReq>
                    for FeedViewSvc<T> {
                        type Response = super::FeedViewReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FeedViewReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::feed_view(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FeedViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/GetArcsPlayer" => {
                    #[allow(non_camel_case_types)]
                    struct GetArcsPlayerSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::GetArcsPlayerReq>
                    for GetArcsPlayerSvc<T> {
                        type Response = super::GetArcsPlayerReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetArcsPlayerReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::get_arcs_player(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetArcsPlayerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/GetUser" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::GetUserReq>
                    for GetUserSvc<T> {
                        type Response = super::GetUserReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUserReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::get_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/PlayerRelates" => {
                    #[allow(non_camel_case_types)]
                    struct PlayerRelatesSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::PlayerRelatesReq>
                    for PlayerRelatesSvc<T> {
                        type Response = super::PlayerRelatesReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlayerRelatesReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::player_relates(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlayerRelatesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/PremiereArchive" => {
                    #[allow(non_camel_case_types)]
                    struct PremiereArchiveSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::PremiereArchiveReq>
                    for PremiereArchiveSvc<T> {
                        type Response = super::PremiereArchiveReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PremiereArchiveReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::premiere_archive(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PremiereArchiveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/RelatesFeed" => {
                    #[allow(non_camel_case_types)]
                    struct RelatesFeedSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::RelatesFeedReq>
                    for RelatesFeedSvc<T> {
                        type Response = super::RelatesFeedReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RelatesFeedReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::relates_feed(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RelatesFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/Reserve" => {
                    #[allow(non_camel_case_types)]
                    struct ReserveSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ReserveReq>
                    for ReserveSvc<T> {
                        type Response = super::ReserveReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReserveReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::reserve(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReserveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/Season" => {
                    #[allow(non_camel_case_types)]
                    struct SeasonSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::SeasonReq>
                    for SeasonSvc<T> {
                        type Response = super::SeasonReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SeasonReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::season(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SeasonSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/SeasonActivityRecord" => {
                    #[allow(non_camel_case_types)]
                    struct SeasonActivityRecordSvc<T: View>(pub Arc<T>);
                    impl<
                        T: View,
                    > tonic::server::UnaryService<super::SeasonActivityRecordReq>
                    for SeasonActivityRecordSvc<T> {
                        type Response = super::SeasonActivityRecordReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SeasonActivityRecordReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::season_activity_record(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SeasonActivityRecordSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/SeasonWidgetExpose" => {
                    #[allow(non_camel_case_types)]
                    struct SeasonWidgetExposeSvc<T: View>(pub Arc<T>);
                    impl<
                        T: View,
                    > tonic::server::UnaryService<super::SeasonWidgetExposeReq>
                    for SeasonWidgetExposeSvc<T> {
                        type Response = super::SeasonWidgetExposeReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SeasonWidgetExposeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::season_widget_expose(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SeasonWidgetExposeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ShortFormVideoDownload" => {
                    #[allow(non_camel_case_types)]
                    struct ShortFormVideoDownloadSvc<T: View>(pub Arc<T>);
                    impl<
                        T: View,
                    > tonic::server::UnaryService<super::ShortFormVideoDownloadReq>
                    for ShortFormVideoDownloadSvc<T> {
                        type Response = super::ShortFormVideoDownloadReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShortFormVideoDownloadReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::short_form_video_download(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShortFormVideoDownloadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/TFInfo" => {
                    #[allow(non_camel_case_types)]
                    struct TFInfoSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::TfInfoReq>
                    for TFInfoSvc<T> {
                        type Response = super::TfInfoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TfInfoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::tf_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TFInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/View" => {
                    #[allow(non_camel_case_types)]
                    struct ViewSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ViewReq>
                    for ViewSvc<T> {
                        type Response = super::ViewReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::view(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ViewMaterial" => {
                    #[allow(non_camel_case_types)]
                    struct ViewMaterialSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ViewMaterialReq>
                    for ViewMaterialSvc<T> {
                        type Response = super::ViewMaterialReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewMaterialReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::view_material(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewMaterialSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ViewProgress" => {
                    #[allow(non_camel_case_types)]
                    struct ViewProgressSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ViewProgressReq>
                    for ViewProgressSvc<T> {
                        type Response = super::ViewProgressReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewProgressReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::view_progress(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewProgressSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.view.v1.View/ViewTag" => {
                    #[allow(non_camel_case_types)]
                    struct ViewTagSvc<T: View>(pub Arc<T>);
                    impl<T: View> tonic::server::UnaryService<super::ViewTagReq>
                    for ViewTagSvc<T> {
                        type Response = super::ViewTagReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ViewTagReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as View>::view_tag(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ViewTagSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ViewServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.view.v1.View";
    impl<T> tonic::server::NamedService for ViewServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}

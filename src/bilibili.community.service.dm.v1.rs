// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Avatar {
    ///
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "AvatarType", tag = "3")]
    pub avatar_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bubble {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleV2 {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "BubbleType", tag = "3")]
    pub bubble_type: i32,
    ///
    #[prost(bool, tag = "4")]
    pub exposure_once: bool,
    ///
    #[prost(enumeration = "ExposureType", tag = "5")]
    pub exposure_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Button {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ToastFunctionType", tag = "2")]
    pub action: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuzzwordConfig {
    ///
    #[prost(message, repeated, tag = "1")]
    pub keywords: ::prost::alloc::vec::Vec<BuzzwordShowConfig>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuzzwordShowConfig {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub schema: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub source: i32,
    ///
    #[prost(int64, tag = "4")]
    pub id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub buzzword_id: i64,
    ///
    #[prost(int32, tag = "6")]
    pub schema_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckBox {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CheckboxType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(bool, tag = "3")]
    pub default_value: bool,
    ///
    #[prost(bool, tag = "4")]
    pub show: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckBoxV2 {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CheckboxType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(bool, tag = "3")]
    pub default_value: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickButton {
    ///
    #[prost(string, repeated, tag = "1")]
    pub portrait_text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "2")]
    pub landscape_text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "3")]
    pub portrait_text_focus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "4")]
    pub landscape_text_focus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(enumeration = "RenderType", tag = "5")]
    pub render_type: i32,
    ///
    #[prost(bool, tag = "6")]
    pub show: bool,
    ///
    #[prost(message, optional, tag = "7")]
    pub bubble: ::core::option::Option<Bubble>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClickButtonV2 {
    ///
    #[prost(string, repeated, tag = "1")]
    pub portrait_text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "2")]
    pub landscape_text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "3")]
    pub portrait_text_focus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "4")]
    pub landscape_text_focus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(enumeration = "RenderType", tag = "5")]
    pub render_type: i32,
    ///
    #[prost(bool, tag = "6")]
    pub text_input_post: bool,
    ///
    #[prost(bool, tag = "7")]
    pub exposure_once: bool,
    ///
    #[prost(enumeration = "ExposureType", tag = "8")]
    pub exposure_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    ///
    #[prost(message, repeated, tag = "1")]
    pub command_dms: ::prost::alloc::vec::Vec<CommandDm>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandDm {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub command: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub progress: i32,
    ///
    #[prost(string, tag = "7")]
    pub ctime: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub mtime: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub idstr: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "11")]
    pub r#type: i32,
    ///
    #[prost(bool, tag = "12")]
    pub auto_create: bool,
    ///
    #[prost(int32, tag = "13")]
    pub count_down: i32,
    ///
    #[prost(int32, tag = "14")]
    pub attr: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmakuAiFlag {
    ///
    #[prost(message, repeated, tag = "1")]
    pub dm_flags: ::prost::alloc::vec::Vec<DanmakuFlag>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmakuElem {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub progress: i32,
    ///
    #[prost(int32, tag = "3")]
    pub mode: i32,
    ///
    #[prost(int32, tag = "4")]
    pub fontsize: i32,
    ///
    #[prost(enumeration = "DmColorfulType", tag = "5")]
    pub color: i32,
    ///
    #[prost(string, tag = "6")]
    pub mid_hash: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub ctime: i64,
    ///
    #[prost(int32, tag = "9")]
    pub weight: i32,
    ///
    #[prost(string, tag = "10")]
    pub action: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "11")]
    pub pool: i32,
    ///
    #[prost(string, tag = "12")]
    pub id_str: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "13")]
    pub attr: i32,
    ///
    #[prost(string, tag = "22")]
    pub animation: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "23")]
    pub extra: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "DmColorfulType", tag = "24")]
    pub colorful: i32,
    ///
    #[prost(int32, tag = "25")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "26")]
    pub oid: i64,
    ///
    #[prost(enumeration = "DmFromType", tag = "27")]
    pub dm_from: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DanmakuFlag {
    ///
    #[prost(int64, tag = "1")]
    pub dmid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub flag: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmakuFlagConfig {
    ///
    #[prost(int32, tag = "1")]
    pub rec_flag: i32,
    ///
    #[prost(string, tag = "2")]
    pub rec_text: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub rec_switch: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmuDefaultPlayerConfig {
    ///
    #[prost(bool, tag = "1")]
    pub player_danmaku_use_default_config: bool,
    ///
    #[prost(bool, tag = "4")]
    pub player_danmaku_ai_recommended_switch: bool,
    ///
    #[prost(int32, tag = "5")]
    pub player_danmaku_ai_recommended_level: i32,
    ///
    #[prost(bool, tag = "6")]
    pub player_danmaku_blocktop: bool,
    ///
    #[prost(bool, tag = "7")]
    pub player_danmaku_blockscroll: bool,
    ///
    #[prost(bool, tag = "8")]
    pub player_danmaku_blockbottom: bool,
    ///
    #[prost(bool, tag = "9")]
    pub player_danmaku_blockcolorful: bool,
    ///
    #[prost(bool, tag = "10")]
    pub player_danmaku_blockrepeat: bool,
    ///
    #[prost(bool, tag = "11")]
    pub player_danmaku_blockspecial: bool,
    ///
    #[prost(float, tag = "12")]
    pub player_danmaku_opacity: f32,
    ///
    #[prost(float, tag = "13")]
    pub player_danmaku_scalingfactor: f32,
    ///
    #[prost(float, tag = "14")]
    pub player_danmaku_domain: f32,
    ///
    #[prost(int32, tag = "15")]
    pub player_danmaku_speed: i32,
    ///
    #[prost(bool, tag = "16")]
    pub inline_player_danmaku_switch: bool,
    ///
    #[prost(int32, tag = "17")]
    pub player_danmaku_senior_mode_switch: i32,
    ///
    #[prost(int32, tag = "18")]
    pub player_danmaku_ai_recommended_level_v2: i32,
    ///
    #[prost(map = "int32, int32", tag = "19")]
    pub player_danmaku_ai_recommended_level_v2_map: ::std::collections::HashMap<
        i32,
        i32,
    >,
    ///
    #[prost(bool, tag = "20")]
    pub player_danmaku_enable_herd_dm: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmuPlayerConfig {
    ///
    #[prost(bool, tag = "1")]
    pub player_danmaku_switch: bool,
    ///
    #[prost(bool, tag = "2")]
    pub player_danmaku_switch_save: bool,
    ///
    #[prost(bool, tag = "3")]
    pub player_danmaku_use_default_config: bool,
    ///
    #[prost(bool, tag = "4")]
    pub player_danmaku_ai_recommended_switch: bool,
    ///
    #[prost(int32, tag = "5")]
    pub player_danmaku_ai_recommended_level: i32,
    ///
    #[prost(bool, tag = "6")]
    pub player_danmaku_blocktop: bool,
    ///
    #[prost(bool, tag = "7")]
    pub player_danmaku_blockscroll: bool,
    ///
    #[prost(bool, tag = "8")]
    pub player_danmaku_blockbottom: bool,
    ///
    #[prost(bool, tag = "9")]
    pub player_danmaku_blockcolorful: bool,
    ///
    #[prost(bool, tag = "10")]
    pub player_danmaku_blockrepeat: bool,
    ///
    #[prost(bool, tag = "11")]
    pub player_danmaku_blockspecial: bool,
    ///
    #[prost(float, tag = "12")]
    pub player_danmaku_opacity: f32,
    ///
    #[prost(float, tag = "13")]
    pub player_danmaku_scalingfactor: f32,
    ///
    #[prost(float, tag = "14")]
    pub player_danmaku_domain: f32,
    ///
    #[prost(int32, tag = "15")]
    pub player_danmaku_speed: i32,
    ///
    #[prost(bool, tag = "16")]
    pub player_danmaku_enableblocklist: bool,
    ///
    #[prost(bool, tag = "17")]
    pub inline_player_danmaku_switch: bool,
    ///
    #[prost(int32, tag = "18")]
    pub inline_player_danmaku_config: i32,
    ///
    #[prost(int32, tag = "19")]
    pub player_danmaku_ios_switch_save: i32,
    ///
    #[prost(int32, tag = "20")]
    pub player_danmaku_senior_mode_switch: i32,
    ///
    #[prost(int32, tag = "21")]
    pub player_danmaku_ai_recommended_level_v2: i32,
    ///
    #[prost(map = "int32, int32", tag = "22")]
    pub player_danmaku_ai_recommended_level_v2_map: ::std::collections::HashMap<
        i32,
        i32,
    >,
    ///
    #[prost(bool, tag = "23")]
    pub player_danmaku_enable_herd_dm: bool,
    ///
    #[prost(bool, tag = "24")]
    pub player_danmaku_blocktop_bottom: bool,
    ///
    #[prost(int32, tag = "25")]
    pub player_danmaku_domain_v2: i32,
    ///
    #[prost(int32, tag = "26")]
    pub player_danmaku_density: i32,
    ///
    #[prost(bool, tag = "27")]
    pub player_danmaku_subtitle_proof: bool,
    ///
    #[prost(bool, tag = "28")]
    pub player_danmaku_people_proof: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmuPlayerConfigPanel {
    ///
    #[prost(string, tag = "1")]
    pub selection_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DanmuPlayerDynamicConfig {
    ///
    #[prost(int32, tag = "1")]
    pub progress: i32,
    ///
    #[prost(float, tag = "14")]
    pub player_danmaku_domain: f32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmuPlayerViewConfig {
    ///
    #[prost(message, optional, tag = "1")]
    pub danmuku_default_player_config: ::core::option::Option<DanmuDefaultPlayerConfig>,
    ///
    #[prost(message, optional, tag = "2")]
    pub danmuku_player_config: ::core::option::Option<DanmuPlayerConfig>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub danmuku_player_dynamic_config: ::prost::alloc::vec::Vec<
        DanmuPlayerDynamicConfig,
    >,
    ///
    #[prost(message, optional, tag = "4")]
    pub danmuku_player_config_panel: ::core::option::Option<DanmuPlayerConfigPanel>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanmuWebPlayerConfig {
    ///
    #[prost(bool, tag = "1")]
    pub dm_switch: bool,
    ///
    #[prost(bool, tag = "2")]
    pub ai_switch: bool,
    ///
    #[prost(int32, tag = "3")]
    pub ai_level: i32,
    ///
    #[prost(bool, tag = "4")]
    pub blocktop: bool,
    ///
    #[prost(bool, tag = "5")]
    pub blockscroll: bool,
    ///
    #[prost(bool, tag = "6")]
    pub blockbottom: bool,
    ///
    #[prost(bool, tag = "7")]
    pub blockcolor: bool,
    ///
    #[prost(bool, tag = "8")]
    pub blockspecial: bool,
    ///
    #[prost(bool, tag = "9")]
    pub preventshade: bool,
    ///
    #[prost(bool, tag = "10")]
    pub dmask: bool,
    ///
    #[prost(float, tag = "11")]
    pub opacity: f32,
    ///
    #[prost(int32, tag = "12")]
    pub dmarea: i32,
    ///
    #[prost(float, tag = "13")]
    pub speedplus: f32,
    ///
    #[prost(float, tag = "14")]
    pub fontsize: f32,
    ///
    #[prost(bool, tag = "15")]
    pub screensync: bool,
    ///
    #[prost(bool, tag = "16")]
    pub speedsync: bool,
    ///
    #[prost(string, tag = "17")]
    pub fontfamily: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "18")]
    pub bold: bool,
    ///
    #[prost(int32, tag = "19")]
    pub fontborder: i32,
    ///
    #[prost(string, tag = "20")]
    pub draw_type: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "21")]
    pub senior_mode_switch: i32,
    ///
    #[prost(int32, tag = "22")]
    pub ai_level_v2: i32,
    ///
    #[prost(map = "int32, int32", tag = "23")]
    pub ai_level_v2_map: ::std::collections::HashMap<i32, i32>,
    ///
    #[prost(bool, tag = "24")]
    pub blocktop_bottom: bool,
    ///
    #[prost(int32, tag = "25")]
    pub dm_area_v2: i32,
    ///
    #[prost(int32, tag = "26")]
    pub dm_density: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmColorful {
    ///
    #[prost(enumeration = "DmColorfulType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub src: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmExpoReportReq {
    ///
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(bytes = "vec", tag = "3")]
    pub dmids: ::prost::alloc::vec::Vec<u8>,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmExpoReportRes {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmHerdView {
    ///
    #[prost(int32, tag = "1")]
    pub display_herd_dm_num: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub herd_dms: ::prost::alloc::vec::Vec<ViewHerdDmElem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmMaskWall {
    ///
    #[prost(int64, tag = "1")]
    pub start: i64,
    ///
    #[prost(int64, tag = "2")]
    pub end: i64,
    ///
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "DmMaskWallContentType", tag = "4")]
    pub content_type: i32,
    ///
    #[prost(enumeration = "DmMaskWallBizType", tag = "5")]
    pub biz_type: i32,
    ///
    #[prost(message, repeated, tag = "6")]
    pub contents: ::prost::alloc::vec::Vec<DmMaskWallContent>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmMaskWallContent {
    ///
    #[prost(enumeration = "DmMaskWallContentType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmPlayerConfigReq {
    ///
    #[prost(int64, tag = "1")]
    pub ts: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub switch: ::core::option::Option<PlayerDanmakuSwitch>,
    ///
    #[prost(message, optional, tag = "3")]
    pub switch_save: ::core::option::Option<PlayerDanmakuSwitchSave>,
    ///
    #[prost(message, optional, tag = "4")]
    pub use_default_config: ::core::option::Option<PlayerDanmakuUseDefaultConfig>,
    ///
    #[prost(message, optional, tag = "5")]
    pub ai_recommended_switch: ::core::option::Option<PlayerDanmakuAiRecommendedSwitch>,
    ///
    #[prost(message, optional, tag = "6")]
    pub ai_recommended_level: ::core::option::Option<PlayerDanmakuAiRecommendedLevel>,
    ///
    #[prost(message, optional, tag = "7")]
    pub blocktop: ::core::option::Option<PlayerDanmakuBlocktop>,
    ///
    #[prost(message, optional, tag = "8")]
    pub blockscroll: ::core::option::Option<PlayerDanmakuBlockscroll>,
    ///
    #[prost(message, optional, tag = "9")]
    pub blockbottom: ::core::option::Option<PlayerDanmakuBlockbottom>,
    ///
    #[prost(message, optional, tag = "10")]
    pub blockcolorful: ::core::option::Option<PlayerDanmakuBlockcolorful>,
    ///
    #[prost(message, optional, tag = "11")]
    pub blockrepeat: ::core::option::Option<PlayerDanmakuBlockrepeat>,
    ///
    #[prost(message, optional, tag = "12")]
    pub blockspecial: ::core::option::Option<PlayerDanmakuBlockspecial>,
    ///
    #[prost(message, optional, tag = "13")]
    pub opacity: ::core::option::Option<PlayerDanmakuOpacity>,
    ///
    #[prost(message, optional, tag = "14")]
    pub scalingfactor: ::core::option::Option<PlayerDanmakuScalingfactor>,
    ///
    #[prost(message, optional, tag = "15")]
    pub domain: ::core::option::Option<PlayerDanmakuDomain>,
    ///
    #[prost(message, optional, tag = "16")]
    pub speed: ::core::option::Option<PlayerDanmakuSpeed>,
    ///
    #[prost(message, optional, tag = "17")]
    pub enableblocklist: ::core::option::Option<PlayerDanmakuEnableblocklist>,
    ///
    #[prost(message, optional, tag = "18")]
    pub inline_player_danmaku_switch: ::core::option::Option<InlinePlayerDanmakuSwitch>,
    ///
    #[prost(message, optional, tag = "19")]
    pub senior_mode_switch: ::core::option::Option<PlayerDanmakuSeniorModeSwitch>,
    ///
    #[prost(message, optional, tag = "20")]
    pub ai_recommended_level_v2: ::core::option::Option<
        PlayerDanmakuAiRecommendedLevelV2,
    >,
    ///
    #[prost(message, optional, tag = "21")]
    pub enable_herd_dm: ::core::option::Option<PlayerDanmakuEnableHerdDm>,
    ///
    #[prost(message, optional, tag = "22")]
    pub blocktop_bottom: ::core::option::Option<PlayerDanmakuBlocktopBottom>,
    ///
    #[prost(message, optional, tag = "23")]
    pub domain_v2: ::core::option::Option<PlayerDanmakuDomainV2>,
    ///
    #[prost(message, optional, tag = "24")]
    pub density: ::core::option::Option<PlayerDanmakuDensity>,
    ///
    #[prost(message, optional, tag = "25")]
    pub subtitle_proof: ::core::option::Option<PlayerDanmakuSubtitleProof>,
    ///
    #[prost(message, optional, tag = "26")]
    pub people_proof: ::core::option::Option<PlayerDanmakuPeopleProof>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmSegConfig {
    ///
    #[prost(int64, tag = "1")]
    pub page_size: i64,
    ///
    #[prost(int64, tag = "2")]
    pub total: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmSegMobileReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub elems: ::prost::alloc::vec::Vec<DanmakuElem>,
    ///
    #[prost(int32, tag = "2")]
    pub state: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub ai_flag: ::core::option::Option<DanmakuAiFlag>,
    ///
    #[prost(int64, repeated, tag = "4")]
    pub segment_rules: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub colorful_src: ::prost::alloc::vec::Vec<DmColorful>,
    ///
    #[prost(string, tag = "6")]
    pub context_src: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmSegMobileReq {
    ///
    #[prost(int64, tag = "1")]
    pub pid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "4")]
    pub segment_index: i64,
    ///
    #[prost(int32, tag = "5")]
    pub teenagers_mode: i32,
    ///
    #[prost(int64, tag = "6")]
    pub ps: i64,
    ///
    #[prost(int64, tag = "7")]
    pub pe: i64,
    ///
    #[prost(int32, tag = "8")]
    pub pull_mode: i32,
    ///
    #[prost(int32, tag = "9")]
    pub from_scene: i32,
    ///
    #[prost(string, tag = "10")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub context_ext: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmSegOttReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub elems: ::prost::alloc::vec::Vec<DanmakuElem>,
    ///
    #[prost(int32, tag = "2")]
    pub state: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmSegOttReq {
    ///
    #[prost(int64, tag = "1")]
    pub pid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "4")]
    pub segment_index: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmSegSdkReply {
    ///
    #[prost(bool, tag = "1")]
    pub closed: bool,
    ///
    #[prost(message, repeated, tag = "2")]
    pub elems: ::prost::alloc::vec::Vec<DanmakuElem>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DmSegSdkReq {
    ///
    #[prost(int64, tag = "1")]
    pub pid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "4")]
    pub segment_index: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmSubView {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub pid: i64,
    ///
    #[prost(message, repeated, tag = "4")]
    pub post_panel2: ::prost::alloc::vec::Vec<PostPanelV2>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmViewReply {
    ///
    #[prost(bool, tag = "1")]
    pub closed: bool,
    ///
    #[prost(message, optional, tag = "2")]
    pub mask: ::core::option::Option<VideoMask>,
    ///
    #[prost(message, optional, tag = "3")]
    pub subtitle: ::core::option::Option<VideoSubtitle>,
    ///
    #[prost(string, repeated, tag = "4")]
    pub special_dms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, optional, tag = "5")]
    pub ai_flag: ::core::option::Option<DanmakuFlagConfig>,
    ///
    #[prost(message, optional, tag = "6")]
    pub player_config: ::core::option::Option<DanmuPlayerViewConfig>,
    ///
    #[prost(int32, tag = "7")]
    pub send_box_style: i32,
    ///
    #[prost(bool, tag = "8")]
    pub allow: bool,
    ///
    #[prost(bool, tag = "9")]
    pub check_box: bool,
    ///
    #[prost(string, tag = "10")]
    pub check_box_show_msg: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub text_placeholder: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub input_placeholder: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "13")]
    pub report_filter_content: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, optional, tag = "14")]
    pub expo_report: ::core::option::Option<ExpoReport>,
    ///
    #[prost(message, optional, tag = "15")]
    pub buzzword_config: ::core::option::Option<BuzzwordConfig>,
    ///
    #[prost(message, repeated, tag = "16")]
    pub expressions: ::prost::alloc::vec::Vec<Expressions>,
    ///
    #[prost(message, repeated, tag = "17")]
    pub post_panel: ::prost::alloc::vec::Vec<PostPanel>,
    ///
    #[prost(string, repeated, tag = "18")]
    pub activity_meta: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, repeated, tag = "19")]
    pub post_panel2: ::prost::alloc::vec::Vec<PostPanelV2>,
    ///
    #[prost(message, repeated, tag = "20")]
    pub dm_mask_wall: ::prost::alloc::vec::Vec<DmMaskWall>,
    ///
    #[prost(message, optional, tag = "21")]
    pub dm_herd: ::core::option::Option<DmHerdView>,
    ///
    #[prost(message, optional, tag = "22")]
    pub command: ::core::option::Option<Command>,
    ///
    #[prost(string, tag = "23")]
    pub kv: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "24")]
    pub sub_views: ::prost::alloc::vec::Vec<DmSubView>,
    ///
    #[prost(message, optional, tag = "25")]
    pub qoe: ::core::option::Option<QoeInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmViewReq {
    ///
    #[prost(int64, tag = "1")]
    pub pid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub is_hard_boot: i32,
    ///
    #[prost(string, tag = "6")]
    pub context_ext: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DmWebViewReply {
    ///
    #[prost(int32, tag = "1")]
    pub state: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_side: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub dm_sge: ::core::option::Option<DmSegConfig>,
    ///
    #[prost(message, optional, tag = "5")]
    pub flag: ::core::option::Option<DanmakuFlagConfig>,
    ///
    #[prost(string, repeated, tag = "6")]
    pub special_dms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(bool, tag = "7")]
    pub check_box: bool,
    ///
    #[prost(int64, tag = "8")]
    pub count: i64,
    ///
    #[prost(message, repeated, tag = "9")]
    pub command_dms: ::prost::alloc::vec::Vec<CommandDm>,
    ///
    #[prost(message, optional, tag = "10")]
    pub player_config: ::core::option::Option<DanmuWebPlayerConfig>,
    ///
    #[prost(string, repeated, tag = "11")]
    pub report_filter_content: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, repeated, tag = "12")]
    pub expressions: ::prost::alloc::vec::Vec<Expressions>,
    ///
    #[prost(message, repeated, tag = "13")]
    pub post_panel: ::prost::alloc::vec::Vec<PostPanel>,
    ///
    #[prost(string, repeated, tag = "14")]
    pub activity_meta: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, repeated, tag = "15")]
    pub post_panel2: ::prost::alloc::vec::Vec<PostPanelV2>,
    ///
    #[prost(message, repeated, tag = "16")]
    pub sub_views: ::prost::alloc::vec::Vec<DmSubView>,
    ///
    #[prost(message, optional, tag = "17")]
    pub qoe: ::core::option::Option<QoeInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpoReport {
    ///
    #[prost(bool, tag = "1")]
    pub should_report_at_end: bool,
    ///
    #[prost(double, tag = "2")]
    pub player_sample: f64,
    ///
    #[prost(message, repeated, tag = "3")]
    pub durations: ::prost::alloc::vec::Vec<ReportDuration>,
    ///
    #[prost(int32, tag = "4")]
    pub max_size: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Expression {
    ///
    #[prost(string, repeated, tag = "1")]
    pub keyword: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub period: ::prost::alloc::vec::Vec<Period>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Expressions {
    ///
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<Expression>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InlinePlayerDanmakuSwitch {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Label {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "2")]
    pub content: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelV2 {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "2")]
    pub content: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(bool, tag = "3")]
    pub exposure_once: bool,
    ///
    #[prost(enumeration = "ExposureType", tag = "4")]
    pub exposure_type: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Period {
    ///
    #[prost(int64, tag = "1")]
    pub start: i64,
    ///
    #[prost(int64, tag = "2")]
    pub end: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuAiRecommendedLevel {
    ///
    #[prost(int32, tag = "1")]
    pub value: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuAiRecommendedLevelV2 {
    ///
    #[prost(int32, tag = "1")]
    pub value: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuAiRecommendedSwitch {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlockbottom {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlockcolorful {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlockrepeat {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlockscroll {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlockspecial {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlocktop {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuBlocktopBottom {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuDensity {
    ///
    #[prost(int32, tag = "1")]
    pub value: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuDomain {
    ///
    #[prost(float, tag = "1")]
    pub value: f32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuDomainV2 {
    ///
    #[prost(int32, tag = "1")]
    pub value: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuEnableHerdDm {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuEnableblocklist {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuOpacity {
    ///
    #[prost(float, tag = "1")]
    pub value: f32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuPeopleProof {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuScalingfactor {
    ///
    #[prost(float, tag = "1")]
    pub value: f32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuSeniorModeSwitch {
    ///
    #[prost(int32, tag = "1")]
    pub value: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuSpeed {
    ///
    #[prost(int32, tag = "1")]
    pub value: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuSubtitleProof {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuSwitch {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
    ///
    #[prost(bool, tag = "2")]
    pub can_ignore: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuSwitchSave {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerDanmakuUseDefaultConfig {
    ///
    #[prost(bool, tag = "1")]
    pub value: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostPanel {
    ///
    #[prost(int64, tag = "1")]
    pub start: i64,
    ///
    #[prost(int64, tag = "2")]
    pub end: i64,
    ///
    #[prost(int64, tag = "3")]
    pub priority: i64,
    ///
    #[prost(int64, tag = "4")]
    pub biz_id: i64,
    ///
    #[prost(enumeration = "PostPanelBizType", tag = "5")]
    pub biz_type: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub click_button: ::core::option::Option<ClickButton>,
    ///
    #[prost(message, optional, tag = "7")]
    pub text_input: ::core::option::Option<TextInput>,
    ///
    #[prost(message, optional, tag = "8")]
    pub check_box: ::core::option::Option<CheckBox>,
    ///
    #[prost(message, optional, tag = "9")]
    pub toast: ::core::option::Option<Toast>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostPanelV2 {
    ///
    #[prost(int64, tag = "1")]
    pub start: i64,
    ///
    #[prost(int64, tag = "2")]
    pub end: i64,
    ///
    #[prost(enumeration = "PostPanelBizType", tag = "3")]
    pub biz_type: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub click_button: ::core::option::Option<ClickButtonV2>,
    ///
    #[prost(message, optional, tag = "5")]
    pub text_input: ::core::option::Option<TextInputV2>,
    ///
    #[prost(message, optional, tag = "6")]
    pub check_box: ::core::option::Option<CheckBoxV2>,
    ///
    #[prost(message, optional, tag = "7")]
    pub toast: ::core::option::Option<ToastV2>,
    ///
    #[prost(message, optional, tag = "8")]
    pub bubble: ::core::option::Option<BubbleV2>,
    ///
    #[prost(message, optional, tag = "9")]
    pub label: ::core::option::Option<LabelV2>,
    ///
    #[prost(enumeration = "PostStatus", tag = "10")]
    pub post_status: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QoeInfo {
    ///
    #[prost(string, tag = "1")]
    pub info: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReportDuration {
    ///
    #[prost(int64, tag = "1")]
    pub start_second: i64,
    ///
    #[prost(int64, tag = "2")]
    pub end_second: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    ///
    #[prost(int32, tag = "1")]
    pub code: i32,
    ///
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtitleItem {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub id_str: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub lan: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub lan_doc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub subtitle_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub author: ::core::option::Option<UserInfo>,
    ///
    #[prost(enumeration = "SubtitleType", tag = "7")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "8")]
    pub lan_doc_brief: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "SubtitleAiType", tag = "9")]
    pub ai_type: i32,
    ///
    #[prost(enumeration = "SubtitleAiStatus", tag = "10")]
    pub ai_status: i32,
    ///
    #[prost(enumeration = "SubtitleRole", tag = "11")]
    pub role: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInput {
    ///
    #[prost(string, repeated, tag = "1")]
    pub portrait_placeholder: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "2")]
    pub landscape_placeholder: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(enumeration = "RenderType", tag = "3")]
    pub render_type: i32,
    ///
    #[prost(bool, tag = "4")]
    pub placeholder_post: bool,
    ///
    #[prost(bool, tag = "5")]
    pub show: bool,
    ///
    #[prost(message, repeated, tag = "6")]
    pub avatar: ::prost::alloc::vec::Vec<Avatar>,
    ///
    #[prost(enumeration = "PostStatus", tag = "7")]
    pub post_status: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub label: ::core::option::Option<Label>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInputV2 {
    ///
    #[prost(string, repeated, tag = "1")]
    pub portrait_placeholder: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "2")]
    pub landscape_placeholder: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(enumeration = "RenderType", tag = "3")]
    pub render_type: i32,
    ///
    #[prost(bool, tag = "4")]
    pub placeholder_post: bool,
    ///
    #[prost(message, repeated, tag = "5")]
    pub avatar: ::prost::alloc::vec::Vec<Avatar>,
    ///
    #[prost(int32, tag = "6")]
    pub text_input_limit: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Toast {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub duration: i32,
    ///
    #[prost(bool, tag = "3")]
    pub show: bool,
    ///
    #[prost(message, optional, tag = "4")]
    pub button: ::core::option::Option<Button>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToastButtonV2 {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ToastFunctionType", tag = "2")]
    pub action: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToastV2 {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub duration: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub toast_button_v2: ::core::option::Option<ToastButtonV2>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sex: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub sign: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub rank: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoMask {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub plat: i32,
    ///
    #[prost(int32, tag = "3")]
    pub fps: i32,
    ///
    #[prost(int64, tag = "4")]
    pub time: i64,
    ///
    #[prost(string, tag = "5")]
    pub mask_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoSubtitle {
    ///
    #[prost(string, tag = "1")]
    pub lan: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub lan_doc: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub subtitles: ::prost::alloc::vec::Vec<SubtitleItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewHerdDmElem {
    ///
    #[prost(string, tag = "1")]
    pub herd_msg: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub herd_start_cnt: i32,
    ///
    #[prost(int32, tag = "3")]
    pub herd_end_cnt: i32,
    ///
    #[prost(string, tag = "4")]
    pub regex_rule: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub start_progress: i32,
    ///
    #[prost(int32, tag = "6")]
    pub end_progress: i32,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AvatarType {
    ///
    None = 0,
    ///
    Nft = 1,
}
impl AvatarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AvatarTypeNone",
            Self::Nft => "AvatarTypeNFT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AvatarTypeNone" => Some(Self::None),
            "AvatarTypeNFT" => Some(Self::Nft),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BubbleType {
    ///
    None = 0,
    ///
    ClickButton = 1,
    ///
    DmSettingPanel = 2,
}
impl BubbleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "BubbleTypeNone",
            Self::ClickButton => "BubbleTypeClickButton",
            Self::DmSettingPanel => "BubbleTypeDmSettingPanel",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BubbleTypeNone" => Some(Self::None),
            "BubbleTypeClickButton" => Some(Self::ClickButton),
            "BubbleTypeDmSettingPanel" => Some(Self::DmSettingPanel),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CheckboxType {
    ///
    None = 0,
    ///
    Encourage = 1,
    ///
    ColorDm = 2,
}
impl CheckboxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CheckboxTypeNone",
            Self::Encourage => "CheckboxTypeEncourage",
            Self::ColorDm => "CheckboxTypeColorDM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CheckboxTypeNone" => Some(Self::None),
            "CheckboxTypeEncourage" => Some(Self::Encourage),
            "CheckboxTypeColorDM" => Some(Self::ColorDm),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DmColorfulType {
    ///
    NoneType = 0,
    ///
    VipGradualColor = 60001,
}
impl DmColorfulType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoneType => "NoneType",
            Self::VipGradualColor => "VipGradualColor",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NoneType" => Some(Self::NoneType),
            "VipGradualColor" => Some(Self::VipGradualColor),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DmFromType {
    ///
    DmFromUnknown = 0,
    ///
    DmFromNormal = 1,
    ///
    DmFromCmd = 2,
    ///
    DmFromLive = 3,
}
impl DmFromType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DmFromUnknown => "DmFromUnknown",
            Self::DmFromNormal => "DmFromNormal",
            Self::DmFromCmd => "DmFromCmd",
            Self::DmFromLive => "DmFromLive",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DmFromUnknown" => Some(Self::DmFromUnknown),
            "DmFromNormal" => Some(Self::DmFromNormal),
            "DmFromCmd" => Some(Self::DmFromCmd),
            "DmFromLive" => Some(Self::DmFromLive),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DmMaskWallBizType {
    ///
    Unknown = 0,
    ///
    Ogv = 1,
    ///
    BizPic = 2,
    ///
    Mute = 3,
    ///
    Record = 4,
    ///
    Cloud = 5,
    ///
    Aigc = 6,
}
impl DmMaskWallBizType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Ogv => "OGV",
            Self::BizPic => "BizPic",
            Self::Mute => "Mute",
            Self::Record => "Record",
            Self::Cloud => "Cloud",
            Self::Aigc => "AIGC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "OGV" => Some(Self::Ogv),
            "BizPic" => Some(Self::BizPic),
            "Mute" => Some(Self::Mute),
            "Record" => Some(Self::Record),
            "Cloud" => Some(Self::Cloud),
            "AIGC" => Some(Self::Aigc),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DmMaskWallContentType {
    ///
    Unknown = 0,
    ///
    Text = 1,
    ///
    Pic = 2,
}
impl DmMaskWallContentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "DmMaskWallContentTypeUnknown",
            Self::Text => "DmMaskWallContentTypeText",
            Self::Pic => "DmMaskWallContentTypePic",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DmMaskWallContentTypeUnknown" => Some(Self::Unknown),
            "DmMaskWallContentTypeText" => Some(Self::Text),
            "DmMaskWallContentTypePic" => Some(Self::Pic),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExposureType {
    ///
    None = 0,
    ///
    DmSend = 1,
}
impl ExposureType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ExposureTypeNone",
            Self::DmSend => "ExposureTypeDMSend",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ExposureTypeNone" => Some(Self::None),
            "ExposureTypeDMSend" => Some(Self::DmSend),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PostPanelBizType {
    ///
    None = 0,
    ///
    Encourage = 1,
    ///
    ColorDm = 2,
    ///
    Nftdm = 3,
    ///
    FragClose = 4,
    ///
    Recommend = 5,
    ///
    PlotLeak = 6,
    ///
    AntiHarassment = 7,
}
impl PostPanelBizType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "PostPanelBizTypeNone",
            Self::Encourage => "PostPanelBizTypeEncourage",
            Self::ColorDm => "PostPanelBizTypeColorDM",
            Self::Nftdm => "PostPanelBizTypeNFTDM",
            Self::FragClose => "PostPanelBizTypeFragClose",
            Self::Recommend => "PostPanelBizTypeRecommend",
            Self::PlotLeak => "PostPanelBizTypePlotLeak",
            Self::AntiHarassment => "PostPanelBizTypeAntiHarassment",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PostPanelBizTypeNone" => Some(Self::None),
            "PostPanelBizTypeEncourage" => Some(Self::Encourage),
            "PostPanelBizTypeColorDM" => Some(Self::ColorDm),
            "PostPanelBizTypeNFTDM" => Some(Self::Nftdm),
            "PostPanelBizTypeFragClose" => Some(Self::FragClose),
            "PostPanelBizTypeRecommend" => Some(Self::Recommend),
            "PostPanelBizTypePlotLeak" => Some(Self::PlotLeak),
            "PostPanelBizTypeAntiHarassment" => Some(Self::AntiHarassment),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PostStatus {
    ///
    Normal = 0,
    ///
    Closed = 1,
}
impl PostStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "PostStatusNormal",
            Self::Closed => "PostStatusClosed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PostStatusNormal" => Some(Self::Normal),
            "PostStatusClosed" => Some(Self::Closed),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RenderType {
    ///
    None = 0,
    ///
    Single = 1,
    ///
    Rotation = 2,
}
impl RenderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "RenderTypeNone",
            Self::Single => "RenderTypeSingle",
            Self::Rotation => "RenderTypeRotation",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RenderTypeNone" => Some(Self::None),
            "RenderTypeSingle" => Some(Self::Single),
            "RenderTypeRotation" => Some(Self::Rotation),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubtitleAiStatus {
    ///
    None = 0,
    ///
    Exposure = 1,
    ///
    Assist = 2,
}
impl SubtitleAiStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Exposure => "Exposure",
            Self::Assist => "Assist",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "None" => Some(Self::None),
            "Exposure" => Some(Self::Exposure),
            "Assist" => Some(Self::Assist),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubtitleAiType {
    ///
    Normal = 0,
    ///
    Translate = 1,
}
impl SubtitleAiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "Normal",
            Self::Translate => "Translate",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Normal" => Some(Self::Normal),
            "Translate" => Some(Self::Translate),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubtitleRole {
    ///
    Default = 0,
    ///
    Main = 1,
    ///
    Secondary = 2,
}
impl SubtitleRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "Default",
            Self::Main => "Main",
            Self::Secondary => "Secondary",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Default" => Some(Self::Default),
            "Main" => Some(Self::Main),
            "Secondary" => Some(Self::Secondary),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubtitleType {
    ///
    Cc = 0,
    ///
    Ai = 1,
}
impl SubtitleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Cc => "CC",
            Self::Ai => "AI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CC" => Some(Self::Cc),
            "AI" => Some(Self::Ai),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ToastFunctionType {
    ///
    None = 0,
    ///
    PostPanel = 1,
}
impl ToastFunctionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ToastFunctionTypeNone",
            Self::PostPanel => "ToastFunctionTypePostPanel",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ToastFunctionTypeNone" => Some(Self::None),
            "ToastFunctionTypePostPanel" => Some(Self::PostPanel),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod dm_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct DmClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DmClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DmClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DmClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn dm_expo_report(
            &mut self,
            request: impl tonic::IntoRequest<super::DmExpoReportReq>,
        ) -> std::result::Result<
            tonic::Response<super::DmExpoReportRes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.community.service.dm.v1.DM/DmExpoReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.community.service.dm.v1.DM",
                        "DmExpoReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dm_player_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DmPlayerConfigReq>,
        ) -> std::result::Result<tonic::Response<super::Response>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.community.service.dm.v1.DM/DmPlayerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.community.service.dm.v1.DM",
                        "DmPlayerConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dm_seg_mobile(
            &mut self,
            request: impl tonic::IntoRequest<super::DmSegMobileReq>,
        ) -> std::result::Result<
            tonic::Response<super::DmSegMobileReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.community.service.dm.v1.DM/DmSegMobile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.community.service.dm.v1.DM", "DmSegMobile"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dm_seg_ott(
            &mut self,
            request: impl tonic::IntoRequest<super::DmSegOttReq>,
        ) -> std::result::Result<tonic::Response<super::DmSegOttReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.community.service.dm.v1.DM/DmSegOtt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.community.service.dm.v1.DM", "DmSegOtt"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dm_seg_sdk(
            &mut self,
            request: impl tonic::IntoRequest<super::DmSegSdkReq>,
        ) -> std::result::Result<tonic::Response<super::DmSegSdkReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.community.service.dm.v1.DM/DmSegSDK",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.community.service.dm.v1.DM", "DmSegSDK"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dm_view(
            &mut self,
            request: impl tonic::IntoRequest<super::DmViewReq>,
        ) -> std::result::Result<tonic::Response<super::DmViewReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.community.service.dm.v1.DM/DmView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.community.service.dm.v1.DM", "DmView"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod dm_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DmServer.
    #[async_trait]
    pub trait Dm: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn dm_expo_report(
            &self,
            request: tonic::Request<super::DmExpoReportReq>,
        ) -> std::result::Result<tonic::Response<super::DmExpoReportRes>, tonic::Status>;
        ///
        async fn dm_player_config(
            &self,
            request: tonic::Request<super::DmPlayerConfigReq>,
        ) -> std::result::Result<tonic::Response<super::Response>, tonic::Status>;
        ///
        async fn dm_seg_mobile(
            &self,
            request: tonic::Request<super::DmSegMobileReq>,
        ) -> std::result::Result<
            tonic::Response<super::DmSegMobileReply>,
            tonic::Status,
        >;
        ///
        async fn dm_seg_ott(
            &self,
            request: tonic::Request<super::DmSegOttReq>,
        ) -> std::result::Result<tonic::Response<super::DmSegOttReply>, tonic::Status>;
        ///
        async fn dm_seg_sdk(
            &self,
            request: tonic::Request<super::DmSegSdkReq>,
        ) -> std::result::Result<tonic::Response<super::DmSegSdkReply>, tonic::Status>;
        ///
        async fn dm_view(
            &self,
            request: tonic::Request<super::DmViewReq>,
        ) -> std::result::Result<tonic::Response<super::DmViewReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct DmServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> DmServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for DmServer<T>
    where
        T: Dm,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.community.service.dm.v1.DM/DmExpoReport" => {
                    #[allow(non_camel_case_types)]
                    struct DmExpoReportSvc<T: Dm>(pub Arc<T>);
                    impl<T: Dm> tonic::server::UnaryService<super::DmExpoReportReq>
                    for DmExpoReportSvc<T> {
                        type Response = super::DmExpoReportRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmExpoReportReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dm>::dm_expo_report(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmExpoReportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.community.service.dm.v1.DM/DmPlayerConfig" => {
                    #[allow(non_camel_case_types)]
                    struct DmPlayerConfigSvc<T: Dm>(pub Arc<T>);
                    impl<T: Dm> tonic::server::UnaryService<super::DmPlayerConfigReq>
                    for DmPlayerConfigSvc<T> {
                        type Response = super::Response;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmPlayerConfigReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dm>::dm_player_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmPlayerConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.community.service.dm.v1.DM/DmSegMobile" => {
                    #[allow(non_camel_case_types)]
                    struct DmSegMobileSvc<T: Dm>(pub Arc<T>);
                    impl<T: Dm> tonic::server::UnaryService<super::DmSegMobileReq>
                    for DmSegMobileSvc<T> {
                        type Response = super::DmSegMobileReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmSegMobileReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dm>::dm_seg_mobile(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmSegMobileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.community.service.dm.v1.DM/DmSegOtt" => {
                    #[allow(non_camel_case_types)]
                    struct DmSegOttSvc<T: Dm>(pub Arc<T>);
                    impl<T: Dm> tonic::server::UnaryService<super::DmSegOttReq>
                    for DmSegOttSvc<T> {
                        type Response = super::DmSegOttReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmSegOttReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dm>::dm_seg_ott(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmSegOttSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.community.service.dm.v1.DM/DmSegSDK" => {
                    #[allow(non_camel_case_types)]
                    struct DmSegSDKSvc<T: Dm>(pub Arc<T>);
                    impl<T: Dm> tonic::server::UnaryService<super::DmSegSdkReq>
                    for DmSegSDKSvc<T> {
                        type Response = super::DmSegSdkReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmSegSdkReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dm>::dm_seg_sdk(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmSegSDKSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.community.service.dm.v1.DM/DmView" => {
                    #[allow(non_camel_case_types)]
                    struct DmViewSvc<T: Dm>(pub Arc<T>);
                    impl<T: Dm> tonic::server::UnaryService<super::DmViewReq>
                    for DmViewSvc<T> {
                        type Response = super::DmViewReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmViewReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dm>::dm_view(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmViewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for DmServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.community.service.dm.v1.DM";
    impl<T> tonic::server::NamedService for DmServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}

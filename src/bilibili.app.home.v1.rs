// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArcContentPool {
    ///
    #[prost(message, repeated, tag = "1")]
    pub show_arcs: ::prost::alloc::vec::Vec<ArcInfo>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub backup_arcs: ::prost::alloc::vec::Vec<ArcInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArcInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub rec_meta: ::core::option::Option<RecentRecommendMetaInfo>,
    ///
    #[prost(int64, tag = "2")]
    pub duration_sec: i64,
    ///
    #[prost(int64, tag = "3")]
    pub progress_sec: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Badge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "BgStyle", tag = "6")]
    pub bg_style: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectRatingGuide {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub goto_button: ::core::option::Option<PopupButton>,
    ///
    #[prost(message, optional, tag = "3")]
    pub feedback_button: ::core::option::Option<PopupButton>,
    ///
    #[prost(message, optional, tag = "4")]
    pub cancel_button: ::core::option::Option<PopupButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavContentPool {
    ///
    #[prost(message, repeated, tag = "1")]
    pub show_favs: ::prost::alloc::vec::Vec<FavInfo>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub backup_favs: ::prost::alloc::vec::Vec<FavInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub rec_meta: ::core::option::Option<RecentRecommendMetaInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HalfWatchedVideo {
    ///
    #[prost(message, optional, tag = "1")]
    pub module_info: ::core::option::Option<ModuleInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub arc_content_pool: ::core::option::Option<ArcContentPool>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomePopupReq {
    ///
    #[prost(bool, tag = "1")]
    pub cold_start: bool,
    ///
    #[prost(message, optional, tag = "2")]
    pub rupcp: ::core::option::Option<RemindUsePcClientPopupParams>,
    ///
    #[prost(message, optional, tag = "3")]
    pub rgpp: ::core::option::Option<RatingGuidePopupParams>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomePopupRes {
    ///
    #[prost(message, optional, tag = "1")]
    pub remind_use_pc_client: ::core::option::Option<PopupBasicInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub rating_guide: ::core::option::Option<RatingGuidePopup>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IconItem {
    ///
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub red_dot: ::core::option::Option<RedDot>,
    ///
    #[prost(bool, tag = "6")]
    pub fixure: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MineSelection {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<IconItem>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MineSelectionContentReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MineSelectionContentRes {
    ///
    #[prost(message, optional, tag = "1")]
    pub mine_selection: ::core::option::Option<MineSelection>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MineSelectionOptionItemsReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MineSelectionOptionItemsRes {
    ///
    #[prost(message, repeated, tag = "1")]
    pub sections: ::prost::alloc::vec::Vec<SimpleMineSection>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MineSelectionOptionUpdateReq {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub item_ids: ::prost::alloc::vec::Vec<i64>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MineSelectionOptionUpdateRes {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub more: ::core::option::Option<More>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub pos: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct More {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopupBasicInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub confirm_button: ::core::option::Option<PopupButton>,
    ///
    #[prost(message, optional, tag = "5")]
    pub cancel_button: ::core::option::Option<PopupButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopupButton {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RatingGuidePopup {
    ///
    #[prost(message, optional, tag = "1")]
    pub direct_rating_guide: ::core::option::Option<DirectRatingGuide>,
    ///
    #[prost(message, optional, tag = "2")]
    pub rating_then_guide: ::core::option::Option<RatingThenGuide>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RatingGuidePopupParams {
    ///
    #[prost(int32, tag = "1")]
    pub show_count: i32,
    ///
    #[prost(int64, tag = "2")]
    pub like_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RatingPopup {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RatingThenGuide {
    ///
    #[prost(message, optional, tag = "1")]
    pub rating_popup: ::core::option::Option<RatingPopup>,
    ///
    #[prost(message, optional, tag = "2")]
    pub guide_popup: ::core::option::Option<PopupBasicInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecentFav {
    ///
    #[prost(message, optional, tag = "1")]
    pub module_info: ::core::option::Option<ModuleInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub fav_content_pool: ::core::option::Option<FavContentPool>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecentRecommendMetaInfo {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub add_time: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<Badge>,
    ///
    #[prost(enumeration = "RecType", tag = "7")]
    pub rec_type: i32,
    ///
    #[prost(enumeration = "RecentRecReasonEnum", tag = "8")]
    pub rec_reason_enum: i32,
    ///
    #[prost(string, tag = "9")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub add_time_sec: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecentReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecentRes {
    ///
    #[prost(message, optional, tag = "1")]
    pub mine_selection: ::core::option::Option<MineSelection>,
    ///
    #[prost(message, optional, tag = "2")]
    pub recent_used: ::core::option::Option<RecentUsed>,
    ///
    #[prost(message, optional, tag = "3")]
    pub half_watched_videos: ::core::option::Option<HalfWatchedVideo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub to_view: ::core::option::Option<ToView>,
    ///
    #[prost(message, optional, tag = "5")]
    pub recent_fav: ::core::option::Option<RecentFav>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecentUsed {
    ///
    #[prost(message, optional, tag = "1")]
    pub module_info: ::core::option::Option<ModuleInfo>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<IconItem>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RedDot {
    ///
    #[prost(bool, tag = "1")]
    pub show: bool,
    ///
    #[prost(int64, tag = "2")]
    pub num: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemindUsePcClientPopupParams {
    ///
    #[prost(bool, tag = "1")]
    pub has_installed_pc_client: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveVideoReq {
    ///
    #[prost(enumeration = "ModuleType", tag = "1")]
    pub module_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
    ///
    #[prost(enumeration = "RecentRecReasonEnum", tag = "3")]
    pub rec_reason_enum: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveVideoRes {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleMineSection {
    ///
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<IconItem>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TabExtraInfo {
    ///
    #[prost(bool, tag = "1")]
    pub switch_to_mine_config_bubble: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToView {
    ///
    #[prost(message, optional, tag = "1")]
    pub module_info: ::core::option::Option<ModuleInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub arc_content_pool: ::core::option::Option<ArcContentPool>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopLeftTabReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopLeftTabRes {
    ///
    #[prost(int32, repeated, tag = "1")]
    pub tabs: ::prost::alloc::vec::Vec<i32>,
    ///
    #[prost(enumeration = "Tab", tag = "2")]
    pub default_tab: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub extra: ::core::option::Option<TabExtraInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopLeftTabUpdateReq {
    ///
    #[prost(enumeration = "TopLeftGoto", tag = "1")]
    pub tab_goto: i32,
    ///
    #[prost(enumeration = "TabSelection", tag = "2")]
    pub tab_selection: i32,
    ///
    #[prost(enumeration = "TabUpdateSource", tag = "3")]
    pub source: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopLeftTabUpdateRes {}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BgStyle {
    ///
    Unknown = 0,
    ///
    Fill = 1,
    ///
    Stroke = 2,
    ///
    FillAndStroke = 3,
    ///
    NoFillAndNoStroke = 4,
}
impl BgStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "BG_STYLE_UNKNOWN",
            Self::Fill => "BG_STYLE_FILL",
            Self::Stroke => "BG_STYLE_STROKE",
            Self::FillAndStroke => "BG_STYLE_FILL_AND_STROKE",
            Self::NoFillAndNoStroke => "BG_STYLE_NO_FILL_AND_NO_STROKE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BG_STYLE_UNKNOWN" => Some(Self::Unknown),
            "BG_STYLE_FILL" => Some(Self::Fill),
            "BG_STYLE_STROKE" => Some(Self::Stroke),
            "BG_STYLE_FILL_AND_STROKE" => Some(Self::FillAndStroke),
            "BG_STYLE_NO_FILL_AND_NO_STROKE" => Some(Self::NoFillAndNoStroke),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModuleType {
    ///
    Unknown = 0,
    ///
    Toview = 1,
    ///
    RecentFav = 2,
    ///
    HalfWatchedVideo = 3,
}
impl ModuleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MODULE_TYPE_UNKNOWN",
            Self::Toview => "MODULE_TYPE_TOVIEW",
            Self::RecentFav => "MODULE_TYPE_RECENT_FAV",
            Self::HalfWatchedVideo => "MODULE_TYPE_HALF_WATCHED_VIDEO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODULE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "MODULE_TYPE_TOVIEW" => Some(Self::Toview),
            "MODULE_TYPE_RECENT_FAV" => Some(Self::RecentFav),
            "MODULE_TYPE_HALF_WATCHED_VIDEO" => Some(Self::HalfWatchedVideo),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecType {
    ///
    Unknown = 0,
    ///
    Ugc = 1,
    ///
    Ogv = 2,
    ///
    Season = 3,
    ///
    FavFolder = 4,
}
impl RecType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "REC_TYPE_UNKNOWN",
            Self::Ugc => "REC_TYPE_UGC",
            Self::Ogv => "REC_TYPE_OGV",
            Self::Season => "REC_TYPE_SEASON",
            Self::FavFolder => "REC_TYPE_FAV_FOLDER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REC_TYPE_UNKNOWN" => Some(Self::Unknown),
            "REC_TYPE_UGC" => Some(Self::Ugc),
            "REC_TYPE_OGV" => Some(Self::Ogv),
            "REC_TYPE_SEASON" => Some(Self::Season),
            "REC_TYPE_FAV_FOLDER" => Some(Self::FavFolder),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecentRecReasonEnum {
    ///
    RecentRecReasonUnknown = 0,
    ///
    RecentRecReasonToview = 1,
    /// @Deprecated
    RecentRecReasonHistory = 2,
    ///
    RecentRecReasonFavFolder = 21,
    ///
    RecentRecReasonFavDetail = 22,
    ///
    RecentRecReasonDeepWatchingHalf = 31,
    ///
    RecentRecReasonLookBackHalf = 32,
    ///
    RecentRecReasonLookBackMoreHalf = 33,
    ///
    RecentRecReasonLookBackMore = 34,
}
impl RecentRecReasonEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RecentRecReasonUnknown => "RECENT_REC_REASON_UNKNOWN",
            Self::RecentRecReasonToview => "RECENT_REC_REASON_TOVIEW",
            Self::RecentRecReasonHistory => "RECENT_REC_REASON_HISTORY",
            Self::RecentRecReasonFavFolder => "RECENT_REC_REASON_FAV_FOLDER",
            Self::RecentRecReasonFavDetail => "RECENT_REC_REASON_FAV_DETAIL",
            Self::RecentRecReasonDeepWatchingHalf => {
                "RECENT_REC_REASON_DEEP_WATCHING_HALF"
            }
            Self::RecentRecReasonLookBackHalf => "RECENT_REC_REASON_LOOK_BACK_HALF",
            Self::RecentRecReasonLookBackMoreHalf => {
                "RECENT_REC_REASON_LOOK_BACK_MORE_HALF"
            }
            Self::RecentRecReasonLookBackMore => "RECENT_REC_REASON_LOOK_BACK_MORE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECENT_REC_REASON_UNKNOWN" => Some(Self::RecentRecReasonUnknown),
            "RECENT_REC_REASON_TOVIEW" => Some(Self::RecentRecReasonToview),
            "RECENT_REC_REASON_HISTORY" => Some(Self::RecentRecReasonHistory),
            "RECENT_REC_REASON_FAV_FOLDER" => Some(Self::RecentRecReasonFavFolder),
            "RECENT_REC_REASON_FAV_DETAIL" => Some(Self::RecentRecReasonFavDetail),
            "RECENT_REC_REASON_DEEP_WATCHING_HALF" => {
                Some(Self::RecentRecReasonDeepWatchingHalf)
            }
            "RECENT_REC_REASON_LOOK_BACK_HALF" => Some(Self::RecentRecReasonLookBackHalf),
            "RECENT_REC_REASON_LOOK_BACK_MORE_HALF" => {
                Some(Self::RecentRecReasonLookBackMoreHalf)
            }
            "RECENT_REC_REASON_LOOK_BACK_MORE" => Some(Self::RecentRecReasonLookBackMore),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Tab {
    ///
    Unknown = 0,
    ///
    Listen = 1,
    ///
    Story = 2,
    ///
    Recent = 3,
}
impl Tab {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TAB_UNKNOWN",
            Self::Listen => "TAB_LISTEN",
            Self::Story => "TAB_STORY",
            Self::Recent => "TAB_RECENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAB_UNKNOWN" => Some(Self::Unknown),
            "TAB_LISTEN" => Some(Self::Listen),
            "TAB_STORY" => Some(Self::Story),
            "TAB_RECENT" => Some(Self::Recent),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabSelection {
    ///
    TsUnknown = 0,
    ///
    TsOnlyListen = 1,
    ///
    TsOnlyStory = 2,
    ///
    TsOnlyRecent = 3,
    ///
    TsAll = 4,
}
impl TabSelection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TsUnknown => "TS_UNKNOWN",
            Self::TsOnlyListen => "TS_ONLY_LISTEN",
            Self::TsOnlyStory => "TS_ONLY_STORY",
            Self::TsOnlyRecent => "TS_ONLY_RECENT",
            Self::TsAll => "TS_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TS_UNKNOWN" => Some(Self::TsUnknown),
            "TS_ONLY_LISTEN" => Some(Self::TsOnlyListen),
            "TS_ONLY_STORY" => Some(Self::TsOnlyStory),
            "TS_ONLY_RECENT" => Some(Self::TsOnlyRecent),
            "TS_ALL" => Some(Self::TsAll),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabUpdateSource {
    ///
    SourceRecent = 0,
    ///
    SourceGame = 1,
}
impl TabUpdateSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SourceRecent => "SOURCE_RECENT",
            Self::SourceGame => "SOURCE_GAME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOURCE_RECENT" => Some(Self::SourceRecent),
            "SOURCE_GAME" => Some(Self::SourceGame),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TopLeftGoto {
    ///
    GotoUnknown = 0,
    ///
    GotoMine = 1,
    ///
    GotoRecent = 2,
}
impl TopLeftGoto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GotoUnknown => "GOTO_UNKNOWN",
            Self::GotoMine => "GOTO_MINE",
            Self::GotoRecent => "GOTO_RECENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GOTO_UNKNOWN" => Some(Self::GotoUnknown),
            "GOTO_MINE" => Some(Self::GotoMine),
            "GOTO_RECENT" => Some(Self::GotoRecent),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod home_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct HomeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> HomeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HomeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HomeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn home_popup(
            &mut self,
            request: impl tonic::IntoRequest<super::HomePopupReq>,
        ) -> std::result::Result<tonic::Response<super::HomePopupRes>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/HomePopup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.home.v1.Home", "HomePopup"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn mine_selection_content(
            &mut self,
            request: impl tonic::IntoRequest<super::MineSelectionContentReq>,
        ) -> std::result::Result<
            tonic::Response<super::MineSelectionContentRes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/MineSelectionContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.home.v1.Home", "MineSelectionContent"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn mine_selection_option_items(
            &mut self,
            request: impl tonic::IntoRequest<super::MineSelectionOptionItemsReq>,
        ) -> std::result::Result<
            tonic::Response<super::MineSelectionOptionItemsRes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/MineSelectionOptionItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.home.v1.Home",
                        "MineSelectionOptionItems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn mine_selection_option_update(
            &mut self,
            request: impl tonic::IntoRequest<super::MineSelectionOptionUpdateReq>,
        ) -> std::result::Result<
            tonic::Response<super::MineSelectionOptionUpdateRes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/MineSelectionOptionUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.home.v1.Home",
                        "MineSelectionOptionUpdate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn recent(
            &mut self,
            request: impl tonic::IntoRequest<super::RecentReq>,
        ) -> std::result::Result<tonic::Response<super::RecentRes>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/Recent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.home.v1.Home", "Recent"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn remove_video(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveVideoReq>,
        ) -> std::result::Result<tonic::Response<super::RemoveVideoRes>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/RemoveVideo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.home.v1.Home", "RemoveVideo"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn top_left_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::TopLeftTabReq>,
        ) -> std::result::Result<tonic::Response<super::TopLeftTabRes>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/TopLeftTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.home.v1.Home", "TopLeftTab"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn top_left_tab_update(
            &mut self,
            request: impl tonic::IntoRequest<super::TopLeftTabUpdateReq>,
        ) -> std::result::Result<
            tonic::Response<super::TopLeftTabUpdateRes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.home.v1.Home/TopLeftTabUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.home.v1.Home", "TopLeftTabUpdate"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod home_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with HomeServer.
    #[async_trait]
    pub trait Home: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn home_popup(
            &self,
            request: tonic::Request<super::HomePopupReq>,
        ) -> std::result::Result<tonic::Response<super::HomePopupRes>, tonic::Status>;
        ///
        async fn mine_selection_content(
            &self,
            request: tonic::Request<super::MineSelectionContentReq>,
        ) -> std::result::Result<
            tonic::Response<super::MineSelectionContentRes>,
            tonic::Status,
        >;
        ///
        async fn mine_selection_option_items(
            &self,
            request: tonic::Request<super::MineSelectionOptionItemsReq>,
        ) -> std::result::Result<
            tonic::Response<super::MineSelectionOptionItemsRes>,
            tonic::Status,
        >;
        ///
        async fn mine_selection_option_update(
            &self,
            request: tonic::Request<super::MineSelectionOptionUpdateReq>,
        ) -> std::result::Result<
            tonic::Response<super::MineSelectionOptionUpdateRes>,
            tonic::Status,
        >;
        ///
        async fn recent(
            &self,
            request: tonic::Request<super::RecentReq>,
        ) -> std::result::Result<tonic::Response<super::RecentRes>, tonic::Status>;
        ///
        async fn remove_video(
            &self,
            request: tonic::Request<super::RemoveVideoReq>,
        ) -> std::result::Result<tonic::Response<super::RemoveVideoRes>, tonic::Status>;
        ///
        async fn top_left_tab(
            &self,
            request: tonic::Request<super::TopLeftTabReq>,
        ) -> std::result::Result<tonic::Response<super::TopLeftTabRes>, tonic::Status>;
        ///
        async fn top_left_tab_update(
            &self,
            request: tonic::Request<super::TopLeftTabUpdateReq>,
        ) -> std::result::Result<
            tonic::Response<super::TopLeftTabUpdateRes>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct HomeServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> HomeServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for HomeServer<T>
    where
        T: Home,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.home.v1.Home/HomePopup" => {
                    #[allow(non_camel_case_types)]
                    struct HomePopupSvc<T: Home>(pub Arc<T>);
                    impl<T: Home> tonic::server::UnaryService<super::HomePopupReq>
                    for HomePopupSvc<T> {
                        type Response = super::HomePopupRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HomePopupReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::home_popup(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HomePopupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/MineSelectionContent" => {
                    #[allow(non_camel_case_types)]
                    struct MineSelectionContentSvc<T: Home>(pub Arc<T>);
                    impl<
                        T: Home,
                    > tonic::server::UnaryService<super::MineSelectionContentReq>
                    for MineSelectionContentSvc<T> {
                        type Response = super::MineSelectionContentRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MineSelectionContentReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::mine_selection_content(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MineSelectionContentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/MineSelectionOptionItems" => {
                    #[allow(non_camel_case_types)]
                    struct MineSelectionOptionItemsSvc<T: Home>(pub Arc<T>);
                    impl<
                        T: Home,
                    > tonic::server::UnaryService<super::MineSelectionOptionItemsReq>
                    for MineSelectionOptionItemsSvc<T> {
                        type Response = super::MineSelectionOptionItemsRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MineSelectionOptionItemsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::mine_selection_option_items(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MineSelectionOptionItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/MineSelectionOptionUpdate" => {
                    #[allow(non_camel_case_types)]
                    struct MineSelectionOptionUpdateSvc<T: Home>(pub Arc<T>);
                    impl<
                        T: Home,
                    > tonic::server::UnaryService<super::MineSelectionOptionUpdateReq>
                    for MineSelectionOptionUpdateSvc<T> {
                        type Response = super::MineSelectionOptionUpdateRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MineSelectionOptionUpdateReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::mine_selection_option_update(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MineSelectionOptionUpdateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/Recent" => {
                    #[allow(non_camel_case_types)]
                    struct RecentSvc<T: Home>(pub Arc<T>);
                    impl<T: Home> tonic::server::UnaryService<super::RecentReq>
                    for RecentSvc<T> {
                        type Response = super::RecentRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RecentReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::recent(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RecentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/RemoveVideo" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveVideoSvc<T: Home>(pub Arc<T>);
                    impl<T: Home> tonic::server::UnaryService<super::RemoveVideoReq>
                    for RemoveVideoSvc<T> {
                        type Response = super::RemoveVideoRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveVideoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::remove_video(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveVideoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/TopLeftTab" => {
                    #[allow(non_camel_case_types)]
                    struct TopLeftTabSvc<T: Home>(pub Arc<T>);
                    impl<T: Home> tonic::server::UnaryService<super::TopLeftTabReq>
                    for TopLeftTabSvc<T> {
                        type Response = super::TopLeftTabRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TopLeftTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::top_left_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TopLeftTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.home.v1.Home/TopLeftTabUpdate" => {
                    #[allow(non_camel_case_types)]
                    struct TopLeftTabUpdateSvc<T: Home>(pub Arc<T>);
                    impl<T: Home> tonic::server::UnaryService<super::TopLeftTabUpdateReq>
                    for TopLeftTabUpdateSvc<T> {
                        type Response = super::TopLeftTabUpdateRes;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TopLeftTabUpdateReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Home>::top_left_tab_update(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TopLeftTabUpdateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for HomeServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.home.v1.Home";
    impl<T> tonic::server::NamedService for HomeServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}

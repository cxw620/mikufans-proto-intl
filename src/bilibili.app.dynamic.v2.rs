// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdParam {
    ///
    #[prost(string, tag = "1")]
    pub ad_extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionArticle {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub cover: ::core::option::Option<MdlDynDrawItem>,
    ///
    #[prost(string, tag = "3")]
    pub desc_text_left: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc_text_right: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub card_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionCommon {
    ///
    #[prost(string, tag = "1")]
    pub head_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub desc_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub button: ::core::option::Option<AdditionalButton>,
    ///
    #[prost(string, tag = "8")]
    pub head_icon: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ImageStyle", tag = "9")]
    pub style: i32,
    ///
    #[prost(string, tag = "10")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub card_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionEsport {
    ///
    #[prost(enumeration = "EspaceStyle", tag = "1")]
    pub style: i32,
    ///
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "addition_esport::Item", tags = "2")]
    pub item: ::core::option::Option<addition_esport::Item>,
}
/// Nested message and enum types in `AdditionEsport`.
pub mod addition_esport {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        AdditionEsportMoba(super::AdditionEsportMoba),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionEsportMoba {
    ///
    #[prost(string, tag = "1")]
    pub head_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub match_team: ::prost::alloc::vec::Vec<MatchTeam>,
    ///
    #[prost(message, optional, tag = "4")]
    pub addition_esport_moba_status: ::core::option::Option<AdditionEsportMobaStatus>,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub button: ::core::option::Option<AdditionalButton>,
    ///
    #[prost(string, tag = "7")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub head_icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionEsportMobaStatus {
    ///
    #[prost(message, repeated, tag = "1")]
    pub addition_esport_moba_status_desc: ::prost::alloc::vec::Vec<
        AdditionEsportMobaStatusDesc,
    >,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub status: i32,
    ///
    #[prost(string, tag = "4")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub night_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionEsportMobaStatusDesc {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub night_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionGoods {
    ///
    #[prost(string, tag = "1")]
    pub rcmd_desc: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub goods_items: ::prost::alloc::vec::Vec<GoodsItem>,
    ///
    #[prost(string, tag = "3")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub source_type: i32,
    ///
    #[prost(enumeration = "GoodsJumpType", tag = "7")]
    pub jump_type: i32,
    ///
    #[prost(string, tag = "8")]
    pub app_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub ad_mark_icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionLiveRoom {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(message, optional, tag = "4")]
    pub desc_text_upper: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(string, tag = "5")]
    pub desc_text_lower: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub card_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionMusic {
    ///
    #[prost(message, optional, tag = "1")]
    pub music_card: ::core::option::Option<MdlDynMusic>,
    ///
    #[prost(string, tag = "2")]
    pub card_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionUp {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub desc_text1: ::core::option::Option<HighlightText>,
    ///
    #[prost(string, tag = "3")]
    pub desc_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub button: ::core::option::Option<AdditionalButton>,
    ///
    #[prost(string, tag = "6")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub reserve_total: i64,
    ///
    #[prost(message, optional, tag = "8")]
    pub act_skin: ::core::option::Option<AdditionalActSkin>,
    ///
    #[prost(int64, tag = "9")]
    pub rid: i64,
    ///
    #[prost(enumeration = "ReserveRelationLotteryType", tag = "10")]
    pub lottery_type: i32,
    ///
    #[prost(message, optional, tag = "11")]
    pub desc_text3: ::core::option::Option<HighlightText>,
    ///
    #[prost(int64, tag = "12")]
    pub up_mid: i64,
    ///
    #[prost(message, optional, tag = "13")]
    pub user_info: ::core::option::Option<AdditionUserInfo>,
    ///
    #[prost(string, tag = "14")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "15")]
    pub show_text2: bool,
    ///
    #[prost(int64, tag = "16")]
    pub dyn_type: i64,
    ///
    #[prost(string, tag = "17")]
    pub business_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "18")]
    pub badge_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "19")]
    pub is_premiere: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionUgc {
    ///
    #[prost(string, tag = "1")]
    pub head_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub desc_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub duration: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub line_feed: bool,
    ///
    #[prost(string, tag = "9")]
    pub card_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionUserInfo {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVote {
    ///
    #[prost(string, tag = "1")]
    pub image_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub button_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVote2 {
    ///
    #[prost(enumeration = "AdditionVoteType", tag = "1")]
    pub addition_vote_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub vote_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub deadline: i64,
    ///
    #[prost(string, tag = "6")]
    pub open_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub close_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub voted_text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "AdditionVoteState", tag = "9")]
    pub state: i32,
    ///
    #[prost(int32, tag = "13")]
    pub biz_type: i32,
    ///
    #[prost(int64, tag = "14")]
    pub total: i64,
    ///
    #[prost(string, tag = "15")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub tips: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "17")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "18")]
    pub is_voted: bool,
    ///
    #[prost(int32, tag = "19")]
    pub choice_cnt: i32,
    ///
    #[prost(bool, tag = "20")]
    pub defaule_select_share: bool,
    ///
    #[prost(message, optional, tag = "21")]
    pub only_fans_vote: ::core::option::Option<OnlyFansVoteProperty>,
    ///
    #[prost(int64, tag = "22")]
    pub vote_owner_mid: i64,
    ///
    #[prost(oneof = "addition_vote2::Item", tags = "10, 11, 12")]
    pub item: ::core::option::Option<addition_vote2::Item>,
}
/// Nested message and enum types in `AdditionVote2`.
pub mod addition_vote2 {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "10")]
        AdditionVoteWord(super::AdditionVoteWord),
        ///
        #[prost(message, tag = "11")]
        AdditionVotePic(super::AdditionVotePic),
        ///
        #[prost(message, tag = "12")]
        AdditionVoteDefaule(super::AdditionVoteDefaule),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVoteDefaule {
    ///
    #[prost(string, repeated, tag = "1")]
    pub cover: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVotePic {
    ///
    #[prost(message, repeated, tag = "1")]
    pub item: ::prost::alloc::vec::Vec<AdditionVotePicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVotePicItem {
    ///
    #[prost(int32, tag = "1")]
    pub opt_idx: i32,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub is_vote: bool,
    ///
    #[prost(int32, tag = "4")]
    pub total: i32,
    ///
    #[prost(double, tag = "5")]
    pub persent: f64,
    ///
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "7")]
    pub is_max_option: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVoteWord {
    ///
    #[prost(message, repeated, tag = "1")]
    pub item: ::prost::alloc::vec::Vec<AdditionVoteWordItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionVoteWordItem {
    ///
    #[prost(int32, tag = "1")]
    pub opt_idx: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub is_vote: bool,
    ///
    #[prost(int32, tag = "4")]
    pub total: i32,
    ///
    #[prost(double, tag = "5")]
    pub persent: f64,
    ///
    #[prost(bool, tag = "6")]
    pub is_max_option: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalActSkin {
    ///
    #[prost(string, tag = "1")]
    pub svga: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub last_image: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub play_times: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalButton {
    ///
    #[prost(enumeration = "AddButtonType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub jump_style: ::core::option::Option<AdditionalButtonStyle>,
    ///
    #[prost(string, tag = "3")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub uncheck: ::core::option::Option<AdditionalButtonStyle>,
    ///
    #[prost(message, optional, tag = "5")]
    pub check: ::core::option::Option<AdditionalButtonStyle>,
    ///
    #[prost(enumeration = "AdditionalButtonStatus", tag = "6")]
    pub status: i32,
    ///
    #[prost(enumeration = "AdditionalButtonClickType", tag = "7")]
    pub click_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalButtonInteractive {
    ///
    #[prost(string, tag = "1")]
    pub popups: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub confirm: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cancel: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalButtonShare {
    ///
    #[prost(enumeration = "AdditionalShareShowType", tag = "1")]
    pub show: i32,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalButtonStyle {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub interactive: ::core::option::Option<AdditionalButtonInteractive>,
    ///
    #[prost(enumeration = "AddButtonBgStyle", tag = "4")]
    pub bg_style: i32,
    ///
    #[prost(string, tag = "5")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "DisableState", tag = "6")]
    pub disable: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub share: ::core::option::Option<AdditionalButtonShare>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalPgc {
    ///
    #[prost(string, tag = "1")]
    pub head_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub desc_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub button: ::core::option::Option<AdditionalButton>,
    ///
    #[prost(string, tag = "8")]
    pub head_icon: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ImageStyle", tag = "9")]
    pub style: i32,
    ///
    #[prost(string, tag = "10")]
    pub r#type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlumniDynamicsReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlumniDynamicsReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub first_time: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int32, tag = "4")]
    pub local_time: i32,
    ///
    #[prost(int32, tag = "5")]
    pub page: i32,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "6")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorBadge {
    ///
    #[prost(enumeration = "AuthorBadgeStyle", tag = "1")]
    pub badge_style: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub badge: ::core::option::Option<IconBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicUserInfoV2 {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub avatar: ::core::option::Option<
        super::super::super::dagw::component::avatar::v1::AvatarItem,
    >,
    ///
    #[prost(int32, tag = "5")]
    pub level: i32,
    ///
    #[prost(int32, tag = "6")]
    pub is_senior_member: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(string, tag = "8")]
    pub jump_uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(string, tag = "10")]
    pub name_sub_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ButtonWithSubTitle {
    ///
    #[prost(string, tag = "1")]
    pub btn_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub btn_sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub jump_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ButtonWithSubscribeParam {
    ///
    #[prost(string, tag = "1")]
    pub btn_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub btn_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub subscribe_param: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusBannerInfo {
    ///
    #[prost(string, tag = "1")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub jump_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusBillBoardReply {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub help_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub build_time: i64,
    ///
    #[prost(string, tag = "5")]
    pub version_code: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub list: ::prost::alloc::vec::Vec<OfficialItem>,
    ///
    #[prost(string, tag = "7")]
    pub share_uri: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bind_notice: i32,
    ///
    #[prost(string, tag = "9")]
    pub update_toast: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub campus_id: i64,
    ///
    #[prost(message, optional, tag = "11")]
    pub open_progress: ::core::option::Option<CampusFeatureProgress>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusBillBoardReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub version_code: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "4")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusBillboardInternalReq {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub version_code: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusEntryTabReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusEntryTabResp {
    ///
    #[prost(enumeration = "CampusEntryType", tag = "1")]
    pub entry_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusFeatureProgress {
    ///
    #[prost(int64, tag = "1")]
    pub progress_full: i64,
    ///
    #[prost(int64, tag = "2")]
    pub progress_achieved: i64,
    ///
    #[prost(string, tag = "3")]
    pub desc_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc1: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub btn: ::core::option::Option<CampusLabel>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusFeedbackInfo {
    ///
    #[prost(int32, tag = "1")]
    pub biz_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub biz_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusFeedbackReply {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusFeedbackReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<CampusFeedbackInfo>,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from: i32,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "3")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusHomePagesReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub top: ::core::option::Option<CampusRcmdTop>,
    ///
    #[prost(message, optional, tag = "2")]
    pub campus_top: ::core::option::Option<CampusTop>,
    ///
    #[prost(int32, tag = "3")]
    pub page_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusHomePagesReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "3")]
    pub lat: f64,
    ///
    #[prost(double, tag = "4")]
    pub lng: f64,
    ///
    #[prost(message, optional, tag = "5")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(enumeration = "CampusHomePageType", tag = "6")]
    pub page_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusHomeRcmdTopic {
    ///
    #[prost(message, optional, tag = "1")]
    pub title: ::core::option::Option<ModuleTitle>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<TopicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusInfo {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub online: i64,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusLabel {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMateLikeListReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<ModuleAuthor>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusMateLikeListReq {
    ///
    #[prost(int64, tag = "1")]
    pub dynamic_id: i64,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngBadge {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub badge_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub upload_hint_msg: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngBasicInfo {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub hint_msg: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngDetailReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CampusMngItem>,
    ///
    #[prost(string, tag = "2")]
    pub top_hint_bar_msg: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bottom_submit_hint_msg: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "5")]
    pub campus_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusMngDetailReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngItem {
    ///
    #[prost(enumeration = "CampusMngAuditStatus", tag = "1")]
    pub audit_status: i32,
    ///
    #[prost(string, tag = "2")]
    pub audit_message: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusMngItemType", tag = "3")]
    pub item_type: i32,
    ///
    #[prost(string, tag = "4")]
    pub mng_item_id: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub is_del: bool,
    ///
    #[prost(oneof = "campus_mng_item::Item", tags = "6, 7, 8, 9")]
    pub item: ::core::option::Option<campus_mng_item::Item>,
}
/// Nested message and enum types in `CampusMngItem`.
pub mod campus_mng_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "6")]
        BasicInfo(super::CampusMngBasicInfo),
        ///
        #[prost(message, tag = "7")]
        Badge(super::CampusMngBadge),
        ///
        #[prost(message, tag = "8")]
        Slogan(super::CampusMngSlogan),
        ///
        #[prost(message, tag = "9")]
        Quiz(super::CampusMngQuiz),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngQuiz {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub more_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(string, tag = "3")]
    pub add_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub submit_label: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub quiz_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngQuizDetail {
    ///
    #[prost(int64, tag = "1")]
    pub quiz_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub question: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub correct_answer: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "4")]
    pub wrong_answer_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(enumeration = "CampusMngAuditStatus", tag = "5")]
    pub audit_status: i32,
    ///
    #[prost(string, tag = "6")]
    pub audit_message: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngQuizOperateReply {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub quiz: ::prost::alloc::vec::Vec<CampusMngQuizDetail>,
    ///
    #[prost(int64, tag = "3")]
    pub quiz_total: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngQuizOperateReq {
    ///
    #[prost(enumeration = "CampusMngQuizAction", tag = "1")]
    pub action: i32,
    ///
    #[prost(int64, tag = "2")]
    pub campus_id: i64,
    ///
    #[prost(message, repeated, tag = "3")]
    pub quiz: ::prost::alloc::vec::Vec<CampusMngQuizDetail>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngSlogan {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub slogan: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub input_hint_msg: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngSubmitReply {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusMngSubmitReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(message, repeated, tag = "2")]
    pub modified_items: ::prost::alloc::vec::Vec<CampusMngItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusNoticeInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub button: ::core::option::Option<CampusLabel>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdFeedReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub guide_bar: ::core::option::Option<GuideBarInfo>,
    ///
    #[prost(bool, tag = "4")]
    pub has_more: bool,
    ///
    #[prost(bool, tag = "5")]
    pub update: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdFeedReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub first_time: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int32, tag = "4")]
    pub local_time: i32,
    ///
    #[prost(int32, tag = "5")]
    pub page: i32,
    ///
    #[prost(int32, tag = "6")]
    pub scroll: i32,
    ///
    #[prost(string, tag = "7")]
    pub view_dyn_id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "8")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<CampusRcmdItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<RcmdItem>,
    ///
    #[prost(int64, tag = "3")]
    pub campus_id: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub entry_label: ::core::option::Option<CampusLabel>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub top: ::core::option::Option<CampusRcmdTop>,
    ///
    #[prost(message, optional, tag = "2")]
    pub rcmd: ::core::option::Option<CampusRcmdInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub campus_top: ::core::option::Option<CampusTop>,
    ///
    #[prost(int32, tag = "4")]
    pub page_type: i32,
    ///
    #[prost(int32, tag = "5")]
    pub jump_home_pop: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "3")]
    pub lat: f64,
    ///
    #[prost(double, tag = "4")]
    pub lng: f64,
    ///
    #[prost(message, optional, tag = "5")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "6")]
    pub from_type: i32,
    ///
    #[prost(enumeration = "CampusHomePageType", tag = "7")]
    pub page_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRcmdTop {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub button: ::core::option::Option<RcmdTopButton>,
    ///
    #[prost(message, optional, tag = "7")]
    pub switch_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(message, optional, tag = "8")]
    pub notice_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(string, tag = "9")]
    pub desc2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub desc3: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub invite_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(message, optional, tag = "12")]
    pub reserve_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(int64, tag = "13")]
    pub reserve_number: i64,
    ///
    #[prost(int64, tag = "14")]
    pub max_reserve: i64,
    ///
    #[prost(message, optional, tag = "15")]
    pub school_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(message, optional, tag = "16")]
    pub mng_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(message, optional, tag = "17")]
    pub rcmd_topic: ::core::option::Option<CampusHomeRcmdTopic>,
    ///
    #[prost(bool, tag = "18")]
    pub audit_before_open: bool,
    ///
    #[prost(string, tag = "19")]
    pub audit_message: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusRecommendReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<RcmdItem>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusRecommendReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub page_no: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(enumeration = "CampusRcmdReqFrom", tag = "4")]
    pub from: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusRedDotReply {
    ///
    #[prost(int32, tag = "1")]
    pub red_dot: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusRedDotReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusShowTabInfo {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusTabType", tag = "3")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "4")]
    pub red_dot: i32,
    ///
    #[prost(string, tag = "5")]
    pub icon_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusSquareReply {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<RcmdCampusBrief>,
    ///
    #[prost(message, optional, tag = "3")]
    pub button: ::core::option::Option<CampusLabel>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampusSquareReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(double, tag = "2")]
    pub lat: f64,
    ///
    #[prost(double, tag = "3")]
    pub lng: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusTop {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub tabs: ::prost::alloc::vec::Vec<CampusShowTabInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub switch_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(string, tag = "5")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub banner: ::prost::alloc::vec::Vec<CampusBannerInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub invite_label: ::core::option::Option<CampusLabel>,
    ///
    #[prost(message, optional, tag = "8")]
    pub notice: ::core::option::Option<CampusNoticeInfo>,
    ///
    #[prost(message, optional, tag = "9")]
    pub topic_square: ::core::option::Option<TopicSquareInfo>,
    ///
    #[prost(string, tag = "10")]
    pub campus_badge: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub campus_background: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub campus_motto: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "13")]
    pub mng_entry: ::core::option::Option<CampusLabel>,
    ///
    #[prost(string, tag = "14")]
    pub campus_intro: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "15")]
    pub campus_name_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub bottom_left_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusTopicRcmdFeedReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "4")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub join_discuss: ::core::option::Option<IconButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusTopicRcmdFeedReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int32, tag = "4")]
    pub local_time: i32,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "5")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CampusWaterFlowItem {
    ///
    #[prost(enumeration = "WfItemType", tag = "1")]
    pub item_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub wh_ratio: ::core::option::Option<super::common::ItemWhRatio>,
    ///
    #[prost(oneof = "campus_water_flow_item::FlowItem", tags = "3")]
    pub flow_item: ::core::option::Option<campus_water_flow_item::FlowItem>,
}
/// Nested message and enum types in `CampusWaterFlowItem`.
pub mod campus_water_flow_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FlowItem {
        ///
        #[prost(message, tag = "3")]
        ItemDefault(super::WfItemDefault),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardParagraph {
    ///
    #[prost(message, optional, tag = "1")]
    pub additional_card: ::core::option::Option<ModuleAdditional>,
    ///
    #[prost(enumeration = "LinkNodeType", tag = "2")]
    pub biz_type: i32,
    ///
    #[prost(string, tag = "3")]
    pub biz_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardVideoDynList {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(int64, tag = "2")]
    pub update_num: i64,
    ///
    #[prost(string, tag = "3")]
    pub history_offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub update_baseline: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub has_more: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardVideoFollowList {
    ///
    #[prost(string, tag = "1")]
    pub view_all_link: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<FollowListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardVideoUpList {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<UpListItem>,
    ///
    #[prost(string, tag = "3")]
    pub footprint: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub show_live_num: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub more_label: ::core::option::Option<UpListMoreLabel>,
    ///
    #[prost(int32, tag = "6")]
    pub title_switch: i32,
    ///
    #[prost(bool, tag = "7")]
    pub show_more_label: bool,
    ///
    #[prost(bool, tag = "8")]
    pub show_in_personal: bool,
    ///
    #[prost(bool, tag = "9")]
    pub show_more_button: bool,
    ///
    #[prost(message, repeated, tag = "10")]
    pub list_second: ::prost::alloc::vec::Vec<UpListItem>,
    ///
    #[prost(bool, tag = "11")]
    pub has_more_list: bool,
    ///
    #[prost(string, tag = "12")]
    pub more_list_offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelInfo {
    ///
    #[prost(int64, tag = "1")]
    pub channel_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub channel_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub is_atten: bool,
    ///
    #[prost(string, tag = "5")]
    pub type_icon: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub items: ::prost::alloc::vec::Vec<RcmdItem>,
    ///
    #[prost(string, tag = "7")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub jump_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmtShowItem {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub uname: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub comment: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeParagraph {
    ///
    #[prost(string, tag = "1")]
    pub code_lang: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub code_content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub popup_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bar_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bar_notice: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub btn_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColoredText {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub color: ::core::option::Option<Colors>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Colors {
    ///
    #[prost(string, tag = "1")]
    pub color_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub color_night: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommentDetail {
    ///
    #[prost(bool, tag = "1")]
    pub can_modify: bool,
    ///
    #[prost(int64, tag = "2")]
    pub status: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommonShareCardInfo {
    ///
    #[prost(int64, tag = "1")]
    pub sketch_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub biz_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub biz_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    ///
    #[prost(bool, tag = "1")]
    pub story_vertical_exp: bool,
    ///
    #[prost(int64, tag = "2")]
    pub detail_view_bits: i64,
    ///
    #[prost(map = "string, string", tag = "3")]
    pub extra_router_kvs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CooperationStaffListReq {
    ///
    #[prost(string, tag = "1")]
    pub oid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CooperationStaffListResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub up_list: ::prost::alloc::vec::Vec<CooperationUpInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CooperationUpInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub user_info: ::core::option::Option<BasicUserInfoV2>,
    ///
    #[prost(string, tag = "2")]
    pub up_role: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoverIconWithText {
    ///
    #[prost(enumeration = "CoverIcon", tag = "1")]
    pub icon: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub icon_checked: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreationClassification {
    ///
    #[prost(string, tag = "1")]
    pub classification_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub count: i64,
    ///
    #[prost(string, tag = "3")]
    pub classification_type: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub is_chosen: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreationItemAction {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub action_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "creation_item_action::CreationAction", tag = "3")]
    pub action_type: i32,
    ///
    #[prost(string, tag = "4")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub remain_edit_times: i64,
    ///
    #[prost(message, optional, tag = "6")]
    pub confirmation_toast: ::core::option::Option<ThreePointDefaultToast>,
    ///
    #[prost(message, optional, tag = "7")]
    pub visibility_change: ::core::option::Option<ThreePointVisibilityChange>,
}
/// Nested message and enum types in `CreationItemAction`.
pub mod creation_item_action {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreationAction {
        ///
        Invalid = 0,
        ///
        Delete = 1,
        ///
        EditDyn = 2,
        ///
        JumpUrl = 3,
        ///
        RetractCv = 4,
        ///
        EditCv = 5,
        ///
        VisibilityChange = 6,
    }
    impl CreationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "CREATION_ACTION_INVALID",
                Self::Delete => "CREATION_ACTION_DELETE",
                Self::EditDyn => "CREATION_ACTION_EDIT_DYN",
                Self::JumpUrl => "CREATION_ACTION_JUMP_URL",
                Self::RetractCv => "CREATION_ACTION_RETRACT_CV",
                Self::EditCv => "CREATION_ACTION_EDIT_CV",
                Self::VisibilityChange => "CREATION_ACTION_VISIBILITY_CHANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATION_ACTION_INVALID" => Some(Self::Invalid),
                "CREATION_ACTION_DELETE" => Some(Self::Delete),
                "CREATION_ACTION_EDIT_DYN" => Some(Self::EditDyn),
                "CREATION_ACTION_JUMP_URL" => Some(Self::JumpUrl),
                "CREATION_ACTION_RETRACT_CV" => Some(Self::RetractCv),
                "CREATION_ACTION_EDIT_CV" => Some(Self::EditCv),
                "CREATION_ACTION_VISIBILITY_CHANGE" => Some(Self::VisibilityChange),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreationSortType {
    ///
    #[prost(string, tag = "1")]
    pub sort_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub sort_type: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub is_chosen: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecoCardFan {
    ///
    #[prost(int32, tag = "1")]
    pub is_fan: i32,
    ///
    #[prost(int32, tag = "2")]
    pub number: i32,
    ///
    #[prost(string, tag = "3")]
    pub number_str: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub color_format: ::core::option::Option<DecoCardFanNumColorFormat>,
    ///
    #[prost(string, tag = "6")]
    pub num_prefix: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecoCardFanNumColorFormat {
    ///
    #[prost(string, tag = "1")]
    pub start_point: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub end_point: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "3")]
    pub colors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(int64, repeated, tag = "4")]
    pub gradients: ::prost::alloc::vec::Vec<i64>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecorateCard {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub card_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub fan: ::core::option::Option<DecoCardFan>,
    ///
    #[prost(message, optional, tag = "5")]
    pub vas_deco_card: ::core::option::Option<
        super::super::super::vas::garb::service::UserCard,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Description {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "DescType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "EmojiType", tag = "4")]
    pub emoji_type: i32,
    ///
    #[prost(string, tag = "5")]
    pub goods_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub icon_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub icon_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub rid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub goods: ::core::option::Option<ModuleDescGoods>,
    ///
    #[prost(string, tag = "10")]
    pub orig_text: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "11")]
    pub emoji_size: i32,
    ///
    #[prost(message, optional, tag = "12")]
    pub emoji_size_spec: ::core::option::Option<EmojiSizeSpec>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dimension {
    ///
    #[prost(int64, tag = "1")]
    pub height: i64,
    ///
    #[prost(int64, tag = "2")]
    pub width: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rotate: i64,
    ///
    #[prost(bool, tag = "4")]
    pub force_horizontal: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynAdditionCommonFollowReply {
    ///
    #[prost(enumeration = "AdditionalButtonStatus", tag = "1")]
    pub status: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynAdditionCommonFollowReq {
    ///
    #[prost(enumeration = "AdditionalButtonStatus", tag = "1")]
    pub status: i32,
    ///
    #[prost(string, tag = "2")]
    pub dyn_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub card_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynAllPersonalReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "4")]
    pub read_offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(message, optional, tag = "6")]
    pub addition_up: ::core::option::Option<TopAdditionUp>,
    ///
    #[prost(string, tag = "7")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub title_sub: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynAllPersonalReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub page: i32,
    ///
    #[prost(int32, tag = "4")]
    pub is_preload: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub playurl_param: ::core::option::Option<PlayurlParam>,
    ///
    #[prost(int32, tag = "6")]
    pub local_time: i32,
    ///
    #[prost(string, tag = "7")]
    pub footprint: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(string, tag = "10")]
    pub personal_extra: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub ad_param: ::core::option::Option<AdParam>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynAllReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub dynamic_list: ::core::option::Option<DynamicList>,
    ///
    #[prost(message, optional, tag = "2")]
    pub up_list: ::core::option::Option<CardVideoUpList>,
    ///
    #[prost(message, optional, tag = "3")]
    pub topic_list: ::core::option::Option<TopicList>,
    ///
    #[prost(message, optional, tag = "4")]
    pub unfollow: ::core::option::Option<Unfollow>,
    ///
    #[prost(message, optional, tag = "5")]
    pub region_rcmd: ::core::option::Option<DynRegionRcmd>,
    ///
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<Config>,
    ///
    #[prost(message, optional, tag = "7")]
    pub sort_config: ::core::option::Option<FeedSortConfig>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynAllReq {
    ///
    #[prost(string, tag = "1")]
    pub update_baseline: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub page: i32,
    ///
    #[prost(enumeration = "Refresh", tag = "4")]
    pub refresh_type: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub playurl_param: ::core::option::Option<PlayurlParam>,
    ///
    #[prost(string, tag = "6")]
    pub assist_baseline: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub rcmd_ups_param: ::core::option::Option<RcmdUPsParam>,
    ///
    #[prost(message, optional, tag = "9")]
    pub ad_param: ::core::option::Option<AdParam>,
    ///
    #[prost(int32, tag = "10")]
    pub cold_start: i32,
    ///
    #[prost(string, tag = "11")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "12")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "13")]
    pub tab_recall_uid: i64,
    ///
    #[prost(enumeration = "StyleType", tag = "14")]
    pub tab_recall_type: i32,
    ///
    #[prost(string, tag = "15")]
    pub tab_recall_extra: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "16")]
    pub req_sort_option: ::core::option::Option<FeedSortOptionReq>,
    ///
    #[prost(string, tag = "17")]
    pub bubble_recall_extra_when_show: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynAllUpdOffsetReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub read_offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub footprint: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub personal_extra: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynDetailReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynDetailReq {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "4")]
    pub rid: i64,
    ///
    #[prost(message, optional, tag = "5")]
    pub ad_param: ::core::option::Option<AdParam>,
    ///
    #[prost(string, tag = "6")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(string, tag = "8")]
    pub share_id: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub share_mode: i32,
    ///
    #[prost(int32, tag = "10")]
    pub local_time: i32,
    ///
    #[prost(string, tag = "11")]
    pub pattern: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "12")]
    pub config: ::core::option::Option<Config>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynDetailsReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynDetailsReq {
    ///
    #[prost(string, tag = "1")]
    pub dynamic_ids: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub playurl_param: ::core::option::Option<PlayurlParam>,
    ///
    #[prost(int32, tag = "3")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(message, optional, tag = "5")]
    pub config: ::core::option::Option<Config>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynFakeCardReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynFakeCardReq {
    ///
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynFeatureGate {
    ///
    #[prost(bool, tag = "1")]
    pub enhanced_interaction: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynFriendReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub dyn_list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynFriendReq {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynLightReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub dynamic_list: ::core::option::Option<DynamicList>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynLightReq {
    ///
    #[prost(string, tag = "1")]
    pub history_offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub page: i32,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int32, tag = "5")]
    pub local_time: i32,
    ///
    #[prost(enumeration = "LightFromType", tag = "6")]
    pub from_type: i32,
    ///
    #[prost(int64, tag = "7")]
    pub fake_uid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynMixUpListSearchReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<MixUpListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynMixUpListSearchReq {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynMixUpListViewMoreReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<MixUpListItem>,
    ///
    #[prost(string, tag = "2")]
    pub search_default_text: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub sort_types: ::prost::alloc::vec::Vec<SortType>,
    ///
    #[prost(bool, tag = "4")]
    pub show_more_sort_types: bool,
    ///
    #[prost(int32, tag = "5")]
    pub default_sort_type: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynMixUpListViewMoreReq {
    ///
    #[prost(int32, tag = "1")]
    pub sort_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRcmdReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub region_rcmd: ::core::option::Option<DynRegionRcmd>,
    ///
    #[prost(message, optional, tag = "2")]
    pub dynamic_list: ::core::option::Option<DynamicList>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynRcmdReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int32, tag = "2")]
    pub local_time: i32,
    ///
    #[prost(int64, tag = "3")]
    pub fake_uid: i64,
    ///
    #[prost(bool, tag = "4")]
    pub is_refresh: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRcmdUpExchangeReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub unfollow: ::core::option::Option<Unfollow>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRcmdUpExchangeReq {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub dislike_ts: i64,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRegionRcmd {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<DynRegionRcmdItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub opts: ::core::option::Option<RcmdOption>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRegionRcmdItem {
    ///
    #[prost(int64, tag = "1")]
    pub rid: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<ModuleRcmd>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynScreenTab {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub default_tab: bool,
    ///
    #[prost(bool, tag = "4")]
    pub strategy_show_on_entrance: bool,
    ///
    #[prost(bool, tag = "5")]
    pub strategy_show_on_refresh: bool,
    ///
    #[prost(bool, tag = "6")]
    pub strategy_show_on_pull_up: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynSearchReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub channel_info: ::core::option::Option<SearchChannel>,
    ///
    #[prost(message, optional, tag = "2")]
    pub search_topic: ::core::option::Option<SearchTopic>,
    ///
    #[prost(message, optional, tag = "3")]
    pub search_info: ::core::option::Option<SearchInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynSearchReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub page: i32,
    ///
    #[prost(int32, tag = "3")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynServerDetailsReply {
    ///
    #[prost(map = "int64, message", tag = "1")]
    pub items: ::std::collections::HashMap<i64, DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynServerDetailsReq {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub dynamic_ids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(int32, tag = "2")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(string, tag = "4")]
    pub mobi_app: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub device: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub buvid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub build: i64,
    ///
    #[prost(int64, tag = "8")]
    pub mid: i64,
    ///
    #[prost(string, tag = "9")]
    pub platform: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "10")]
    pub is_master: bool,
    ///
    #[prost(int64, repeated, tag = "11")]
    pub top_dynamic_ids: ::prost::alloc::vec::Vec<i64>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynSpaceReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub history_offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int32, tag = "4")]
    pub local_time: i32,
    ///
    #[prost(int64, tag = "5")]
    pub page: i64,
    ///
    #[prost(string, tag = "6")]
    pub from: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynSpaceRsp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub history_offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynSpaceSearchDetailsReply {
    ///
    #[prost(map = "int64, message", tag = "1")]
    pub items: ::std::collections::HashMap<i64, DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynSpaceSearchDetailsReq {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub dynamic_ids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(string, repeated, tag = "2")]
    pub search_words: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(int32, tag = "3")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(string, tag = "5")]
    pub mobi_app: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub device: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub buvid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub build: i64,
    ///
    #[prost(int64, tag = "9")]
    pub mid: i64,
    ///
    #[prost(string, tag = "10")]
    pub platform: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub ip: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "NetworkType", tag = "12")]
    pub net_type: i32,
    ///
    #[prost(enumeration = "TfType", tag = "13")]
    pub tf_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynTab {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bubble: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub red_point: i32,
    ///
    #[prost(int64, tag = "5")]
    pub city_id: i64,
    ///
    #[prost(int32, tag = "6")]
    pub is_popup: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub popup: ::core::option::Option<Popup>,
    ///
    #[prost(bool, tag = "8")]
    pub default_tab: bool,
    ///
    #[prost(string, tag = "9")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub anchor: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub internal_test: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ShowType", tag = "12")]
    pub r#type: i32,
    ///
    #[prost(message, optional, boxed, tag = "13")]
    pub back_up: ::core::option::Option<::prost::alloc::boxed::Box<DynTab>>,
    ///
    #[prost(string, tag = "14")]
    pub jump_home_pop: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynTabReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub dyn_tab: ::prost::alloc::vec::Vec<DynTab>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub screen_tab: ::prost::alloc::vec::Vec<DynScreenTab>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynTabReq {
    ///
    #[prost(int32, tag = "1")]
    pub teenagers_mode: i32,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynThumbReq {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub dyn_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub dyn_type: i64,
    ///
    #[prost(string, tag = "4")]
    pub rid: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ThumbType", tag = "5")]
    pub r#type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoPersonalReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "4")]
    pub read_offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(message, optional, tag = "6")]
    pub addition_up: ::core::option::Option<TopAdditionUp>,
    ///
    #[prost(string, tag = "7")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub title_sub: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoPersonalReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub page: i32,
    ///
    #[prost(int32, tag = "4")]
    pub is_preload: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub playurl_param: ::core::option::Option<PlayurlParam>,
    ///
    #[prost(int32, tag = "6")]
    pub local_time: i32,
    ///
    #[prost(string, tag = "7")]
    pub footprint: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "10")]
    pub pegasus_avid: i64,
    ///
    #[prost(string, tag = "11")]
    pub personal_extra: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub dynamic_list: ::core::option::Option<CardVideoDynList>,
    ///
    #[prost(message, optional, tag = "2")]
    pub video_up_list: ::core::option::Option<CardVideoUpList>,
    ///
    #[prost(message, optional, tag = "3")]
    pub video_follow_list: ::core::option::Option<CardVideoFollowList>,
    ///
    #[prost(message, optional, tag = "4")]
    pub sort_config: ::core::option::Option<FeedSortConfig>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoReq {
    ///
    #[prost(string, tag = "1")]
    pub update_baseline: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub page: i32,
    ///
    #[prost(enumeration = "Refresh", tag = "4")]
    pub refresh_type: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub playurl_param: ::core::option::Option<PlayurlParam>,
    ///
    #[prost(string, tag = "6")]
    pub assist_baseline: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub local_time: i32,
    ///
    #[prost(string, tag = "8")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(message, optional, tag = "10")]
    pub req_sort_option: ::core::option::Option<FeedSortOptionReq>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoUpdOffsetReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub read_offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub footprint: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub personal_extra: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVoteReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<AdditionVote2>,
    ///
    #[prost(string, tag = "2")]
    pub toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVoteReq {
    ///
    #[prost(int64, tag = "1")]
    pub vote_id: i64,
    ///
    #[prost(int64, repeated, tag = "2")]
    pub votes: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(enumeration = "VoteStatus", tag = "3")]
    pub status: i32,
    ///
    #[prost(string, tag = "4")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub share: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicItem {
    ///
    #[prost(enumeration = "DynamicType", tag = "1")]
    pub card_type: i32,
    ///
    #[prost(enumeration = "DynamicType", tag = "2")]
    pub item_type: i32,
    ///
    #[prost(message, repeated, tag = "3")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    ///
    #[prost(message, optional, tag = "4")]
    pub extend: ::core::option::Option<Extend>,
    ///
    #[prost(int32, tag = "5")]
    pub has_fold: i32,
    ///
    #[prost(string, tag = "6")]
    pub server_info: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicList {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(int64, tag = "2")]
    pub update_num: i64,
    ///
    #[prost(string, tag = "3")]
    pub history_offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub update_baseline: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub has_more: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmojiSizeSpec {
    ///
    #[prost(int64, tag = "1")]
    pub width: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmoteNode {
    ///
    #[prost(message, optional, tag = "1")]
    pub raw_text: ::core::option::Option<WordNode>,
    ///
    #[prost(string, tag = "2")]
    pub emote_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub emote_width: ::core::option::Option<EmoteSize>,
    ///
    #[prost(bool, tag = "4")]
    pub is_inline_img: bool,
    ///
    #[prost(message, optional, tag = "5")]
    pub inline_img_cfg: ::core::option::Option<ImgInlineCfg>,
    ///
    #[prost(bool, tag = "6")]
    pub allow_animated: bool,
    ///
    #[prost(enumeration = "EmoteClickAction", tag = "7")]
    pub click_action: i32,
    ///
    #[prost(string, tag = "8")]
    pub preview_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub preview_name_jump_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub emote_url_dark: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmoteSize {
    ///
    #[prost(double, tag = "1")]
    pub width: f64,
    ///
    #[prost(int32, tag = "2")]
    pub emoji_size: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoCommon {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub poi_type: i32,
    ///
    #[prost(enumeration = "DynExtendType", tag = "5")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "6")]
    pub sub_module: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub action_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub action_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub rid: i64,
    ///
    #[prost(bool, tag = "10")]
    pub is_show_light: bool,
    ///
    #[prost(enumeration = "ext_info_common::ExtTagStyle", tag = "11")]
    pub tag_style: i32,
    ///
    #[prost(string, tag = "12")]
    pub extend_report_tag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExtInfoCommon`.
pub mod ext_info_common {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtTagStyle {
        ///
        Default = 0,
        ///
        PureText = 1,
    }
    impl ExtTagStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "EXT_TAG_STYLE_DEFAULT",
                Self::PureText => "EXT_TAG_STYLE_PURE_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXT_TAG_STYLE_DEFAULT" => Some(Self::Default),
                "EXT_TAG_STYLE_PURE_TEXT" => Some(Self::PureText),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoGame {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoHot {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoLbs {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub poi_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoOgv {
    ///
    #[prost(message, repeated, tag = "1")]
    pub info_ogv: ::prost::alloc::vec::Vec<InfoOgv>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoTopic {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Extend {
    ///
    #[prost(string, tag = "1")]
    pub dyn_id_str: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub business_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub orig_dyn_id_str: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub orig_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub orig_img_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub orig_desc: ::prost::alloc::vec::Vec<Description>,
    ///
    #[prost(message, repeated, tag = "7")]
    pub desc: ::prost::alloc::vec::Vec<Description>,
    ///
    #[prost(enumeration = "DynamicType", tag = "8")]
    pub orig_dyn_type: i32,
    ///
    #[prost(string, tag = "9")]
    pub share_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub share_scene: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "11")]
    pub is_fast_share: bool,
    ///
    #[prost(int32, tag = "12")]
    pub r_type: i32,
    ///
    #[prost(int64, tag = "13")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "14")]
    pub uid: i64,
    ///
    #[prost(string, tag = "15")]
    pub card_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "16")]
    pub source_content: ::core::option::Option<::prost_types::Any>,
    ///
    #[prost(string, tag = "17")]
    pub orig_face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "18")]
    pub reply: ::core::option::Option<ExtendReply>,
    ///
    #[prost(string, tag = "19")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "20")]
    pub opus_summary: ::core::option::Option<ModuleOpusSummary>,
    ///
    #[prost(message, optional, tag = "21")]
    pub only_fans_property: ::core::option::Option<OnlyFansProperty>,
    ///
    #[prost(message, optional, tag = "22")]
    pub feature_gate: ::core::option::Option<DynFeatureGate>,
    ///
    #[prost(bool, tag = "23")]
    pub is_in_audit: bool,
    ///
    #[prost(map = "string, string", tag = "24")]
    pub history_report: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    ///
    #[prost(string, tag = "25")]
    pub report_metric_data: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "26")]
    pub desc_text_opus: ::core::option::Option<TextParagraph>,
    ///
    #[prost(bool, tag = "27")]
    pub is_preview_only: bool,
    ///
    #[prost(message, optional, tag = "28")]
    pub repost_extra_info: ::core::option::Option<RepostExtraInfo>,
    ///
    #[prost(message, optional, tag = "29")]
    pub manga_property: ::core::option::Option<MangaProperty>,
    ///
    #[prost(string, tag = "30")]
    pub up_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "31")]
    pub up_face: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "DynVisibilityStatus", tag = "32")]
    pub desired_visibility_status: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendReply {
    ///
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<ExtendReplyParam>,
    ///
    #[prost(int64, tag = "3")]
    pub reply_biz_type: i64,
    ///
    #[prost(int64, tag = "4")]
    pub reply_biz_id: i64,
    ///
    #[prost(bool, tag = "5")]
    pub no_load_comment: bool,
    ///
    #[prost(string, tag = "6")]
    pub no_load_comment_hint_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendReplyParam {
    ///
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedFilterReply {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedFilterReq {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub tab: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(message, optional, tag = "5")]
    pub ad_param: ::core::option::Option<AdParam>,
    ///
    #[prost(int32, tag = "6")]
    pub cold_start: i32,
    ///
    #[prost(int64, tag = "7")]
    pub page: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedSortConfig {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub sort_options: ::prost::alloc::vec::Vec<FeedSortOption>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedSortOption {
    ///
    #[prost(string, tag = "1")]
    pub sort_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub sort_type: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub is_selected: bool,
    ///
    #[prost(bool, tag = "4")]
    pub no_auto_next_page_when_unsatisfied: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedSortOptionReq {
    ///
    #[prost(string, tag = "1")]
    pub sort_type: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_cold_refresh: bool,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FetchTabSettingReply {
    ///
    #[prost(enumeration = "HomePageTabSttingStatus", tag = "1")]
    pub status: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlowItemOpus {
    ///
    #[prost(message, optional, tag = "1")]
    pub cover_pic: ::core::option::Option<MdlDynDrawItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub cover_wh_ratio: ::core::option::Option<super::common::ItemWhRatio>,
    ///
    #[prost(message, optional, tag = "3")]
    pub bottom_left_text1: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(message, optional, tag = "4")]
    pub bottom_left_text2: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(message, optional, tag = "5")]
    pub text_paragraph: ::core::option::Option<Paragraph>,
    ///
    #[prost(message, optional, tag = "6")]
    pub top_right_badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(message, optional, tag = "7")]
    pub dark_cover_pic: ::core::option::Option<MdlDynDrawItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FollowListItem {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub new_ep: ::core::option::Option<NewEp>,
    ///
    #[prost(string, tag = "6")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub pos: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormulaNode {
    ///
    #[prost(message, optional, tag = "1")]
    pub latex_content: ::core::option::Option<WordNode>,
    ///
    #[prost(message, optional, tag = "2")]
    pub image_spec: ::core::option::Option<ImgInlineCfg>,
    ///
    #[prost(string, tag = "4")]
    pub img_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoodsItem {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub schema_package_name: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub source_type: i32,
    ///
    #[prost(string, tag = "4")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub jump_desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub brief: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub price: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub item_id: i64,
    ///
    #[prost(string, tag = "10")]
    pub schema_url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "11")]
    pub open_white_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(bool, tag = "12")]
    pub user_web_v2: bool,
    ///
    #[prost(string, tag = "13")]
    pub ad_mark: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub app_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "GoodsJumpType", tag = "15")]
    pub jump_type: i32,
    ///
    #[prost(string, tag = "16")]
    pub cm_cache_passthrough: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuideBarInfo {
    ///
    #[prost(int32, tag = "1")]
    pub show: i32,
    ///
    #[prost(int32, tag = "2")]
    pub page: i32,
    ///
    #[prost(int32, tag = "3")]
    pub position: i32,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub jump_page: i32,
    ///
    #[prost(int32, tag = "6")]
    pub jump_position: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighlightText {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "HighlightTextStyle", tag = "2")]
    pub text_style: i32,
    ///
    #[prost(string, tag = "3")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HomeSubscribeReply {
    ///
    #[prost(enumeration = "CampusOnlineStatus", tag = "1")]
    pub online: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeSubscribeReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IconBadge {
    ///
    #[prost(string, tag = "1")]
    pub icon_bg_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IconButton {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_head: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon_tail: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub jump_uri: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "RouterAction", tag = "5")]
    pub router_action: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSet {
    ///
    #[prost(string, tag = "1")]
    pub img_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub img_dark: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImgInlineCfg {
    ///
    #[prost(double, tag = "1")]
    pub width: f64,
    ///
    #[prost(double, tag = "2")]
    pub height: f64,
    ///
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Colors>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InfoOgv {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub sub_module: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractionFace {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractionItem {
    ///
    #[prost(enumeration = "LocalIconType", tag = "1")]
    pub icon_type: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub desc: ::prost::alloc::vec::Vec<Description>,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub comment_mid: i64,
    ///
    #[prost(message, repeated, tag = "7")]
    pub faces: ::prost::alloc::vec::Vec<InteractionFace>,
    ///
    #[prost(message, optional, tag = "8")]
    pub stat: ::core::option::Option<InteractionStat>,
    ///
    #[prost(string, tag = "9")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub tail_icon: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "11")]
    pub tail_desc: ::prost::alloc::vec::Vec<Description>,
    ///
    #[prost(map = "string, string", tag = "12")]
    pub extend_click_param: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractionStat {
    ///
    #[prost(int64, tag = "1")]
    pub like: i64,
    ///
    #[prost(int64, tag = "2")]
    pub forward: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LbsPoiDetail {
    ///
    #[prost(string, tag = "1")]
    pub poi: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(string, repeated, tag = "3")]
    pub base_pic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, repeated, tag = "4")]
    pub cover: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "5")]
    pub address: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LbsPoiReply {
    ///
    #[prost(bool, tag = "1")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub detail: ::core::option::Option<LbsPoiDetail>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LbsPoiReq {
    ///
    #[prost(string, tag = "1")]
    pub poi: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "Refresh", tag = "4")]
    pub refresh_type: i32,
    ///
    #[prost(int32, tag = "5")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LegacyTopicFeedReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub supported_sort_types: ::prost::alloc::vec::Vec<SortType>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub feed_card_filters: ::prost::alloc::vec::Vec<SortType>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LegacyTopicFeedReq {
    ///
    #[prost(int64, tag = "1")]
    pub topic_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub topic_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub sort_type: ::core::option::Option<SortType>,
    ///
    #[prost(message, optional, tag = "5")]
    pub card_filter: ::core::option::Option<SortType>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeAnimation {
    ///
    #[prost(string, tag = "1")]
    pub begin: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub proc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub end: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub like_icon_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub animation: ::core::option::Option<LikeAnimation>,
    ///
    #[prost(bool, tag = "2")]
    pub is_like: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeListReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<ModuleAuthor>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(int64, tag = "3")]
    pub total_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeListReq {
    ///
    #[prost(string, tag = "1")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rid: i64,
    ///
    #[prost(int64, tag = "4")]
    pub uid_offset: i64,
    ///
    #[prost(int32, tag = "5")]
    pub page: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeUser {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub uname: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineParagraph {
    ///
    #[prost(message, optional, tag = "1")]
    pub pic: ::core::option::Option<MdlDynDrawItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkNode {
    ///
    #[prost(message, optional, tag = "1")]
    pub show_text: ::core::option::Option<WordNode>,
    ///
    #[prost(string, tag = "2")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon_suffix: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub link_type: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "LinkNodeType", tag = "6")]
    pub link_type_enum: i32,
    ///
    #[prost(string, tag = "7")]
    pub biz_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub timestamp: i64,
    ///
    #[prost(message, optional, tag = "9")]
    pub goods_item: ::core::option::Option<GoodsItem>,
    ///
    #[prost(message, optional, tag = "10")]
    pub note_video_ts: ::core::option::Option<NoteVideoTs>,
    ///
    #[prost(message, optional, tag = "11")]
    pub biz_data: ::core::option::Option<::prost_types::Any>,
    ///
    #[prost(message, optional, tag = "12")]
    pub link_pics: ::core::option::Option<MdlDynDraw>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCreationReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub preference: ::core::option::Option<SelectedClassificationAndSortType>,
    ///
    #[prost(int32, tag = "2")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCreationResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub classifications: ::prost::alloc::vec::Vec<CreationClassification>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub sort_types: ::prost::alloc::vec::Vec<CreationSortType>,
    ///
    #[prost(message, optional, tag = "3")]
    pub next_page: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
    ///
    #[prost(message, repeated, tag = "4")]
    pub creation_list: ::prost::alloc::vec::Vec<OpusCreationItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFavReq {
    ///
    #[prost(int32, tag = "1")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFavResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<OpusFavItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub next_page: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveInfo {
    ///
    #[prost(int32, tag = "1")]
    pub is_living: i32,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "LiveState", tag = "3")]
    pub live_state: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LivePendant {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub pendant_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MangaLikeBrowserGuidance {
    ///
    #[prost(bool, tag = "1")]
    pub show_page_right_to_left_guidance: bool,
    ///
    #[prost(string, tag = "2")]
    pub page_right_to_left_guidance_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MangaLikePic {
    ///
    #[prost(message, optional, tag = "1")]
    pub pic: ::core::option::Option<ProtectedStaticResource>,
    ///
    #[prost(int64, tag = "2")]
    pub width: i64,
    ///
    #[prost(int64, tag = "3")]
    pub height: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MangaProperty {
    ///
    #[prost(int64, tag = "1")]
    pub ep_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub manga_id: i64,
    ///
    #[prost(bool, tag = "3")]
    pub is_premium_content: bool,
    ///
    #[prost(bool, tag = "4")]
    pub is_payment_needed: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchTeam {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub night_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynApplet {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub button_title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynArchive {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub avid: i64,
    ///
    #[prost(int64, tag = "8")]
    pub cid: i64,
    ///
    #[prost(enumeration = "MediaType", tag = "9")]
    pub media_type: i32,
    ///
    #[prost(message, optional, tag = "10")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(message, repeated, tag = "11")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(bool, tag = "12")]
    pub can_play: bool,
    ///
    #[prost(enumeration = "VideoType", tag = "13")]
    pub stype: i32,
    ///
    #[prost(bool, tag = "14")]
    pub is_p_g_c: bool,
    ///
    #[prost(string, tag = "15")]
    pub inline_u_r_l: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "16")]
    pub episode_id: i64,
    ///
    #[prost(int32, tag = "17")]
    pub sub_type: i32,
    ///
    #[prost(int64, tag = "18")]
    pub pgc_season_id: i64,
    ///
    #[prost(string, tag = "19")]
    pub play_icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "20")]
    pub duration: i64,
    ///
    #[prost(string, tag = "21")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "22")]
    pub is_preview: bool,
    ///
    #[prost(message, repeated, tag = "23")]
    pub badge_category: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(bool, tag = "24")]
    pub is_feature: bool,
    ///
    #[prost(enumeration = "ReserveType", tag = "25")]
    pub reserve_type: i32,
    ///
    #[prost(string, tag = "26")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "27")]
    pub view: i32,
    ///
    #[prost(bool, tag = "28")]
    pub show_premiere_badge: bool,
    ///
    #[prost(bool, tag = "29")]
    pub premiere_card: bool,
    ///
    #[prost(bool, tag = "30")]
    pub show_progress: bool,
    ///
    #[prost(int64, tag = "31")]
    pub part_duration: i64,
    ///
    #[prost(int64, tag = "32")]
    pub part_progress: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynArticle {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "5")]
    pub covers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "6")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub template_i_d: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynChargingArchive {
    ///
    #[prost(message, optional, tag = "1")]
    pub archive_info: ::core::option::Option<MdlDynArchive>,
    ///
    #[prost(bool, tag = "2")]
    pub has_permission: bool,
    ///
    #[prost(bool, tag = "3")]
    pub can_inline: bool,
    ///
    #[prost(string, tag = "4")]
    pub charging_bundle_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub cfg_preview_end_toast_countdown: i64,
    ///
    #[prost(int64, tag = "6")]
    pub cfg_normal_inline_toast_duration: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub video_bottom_text_upper: ::core::option::Option<OneLineText>,
    ///
    #[prost(message, optional, tag = "8")]
    pub video_bottom_text_lower: ::core::option::Option<OneLineText>,
    ///
    #[prost(string, tag = "9")]
    pub archive_cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub archive_title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub act_btn: ::core::option::Option<IconButton>,
    ///
    #[prost(message, optional, tag = "12")]
    pub text_normal_inline_toast: ::core::option::Option<OneLineText>,
    ///
    #[prost(message, optional, tag = "13")]
    pub text_append_preview_end_toast: ::core::option::Option<OneLineText>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynCommon {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub biz_type: i32,
    ///
    #[prost(int64, tag = "8")]
    pub sketch_i_d: i64,
    ///
    #[prost(enumeration = "MdlDynCommonType", tag = "9")]
    pub style: i32,
    ///
    #[prost(message, repeated, tag = "10")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(message, optional, tag = "11")]
    pub button: ::core::option::Option<AdditionalButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynCourBatch {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text2: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(string, tag = "7")]
    pub play_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub can_play: bool,
    ///
    #[prost(bool, tag = "9")]
    pub is_preview: bool,
    ///
    #[prost(string, tag = "10")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "13")]
    pub avid: i64,
    ///
    #[prost(int64, tag = "14")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "15")]
    pub epid: i64,
    ///
    #[prost(int64, tag = "16")]
    pub duration: i64,
    ///
    #[prost(int64, tag = "17")]
    pub season_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynCourSeason {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(string, tag = "7")]
    pub play_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub can_play: bool,
    ///
    #[prost(bool, tag = "9")]
    pub is_preview: bool,
    ///
    #[prost(int64, tag = "10")]
    pub avid: i64,
    ///
    #[prost(int64, tag = "11")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "12")]
    pub epid: i64,
    ///
    #[prost(int64, tag = "13")]
    pub duration: i64,
    ///
    #[prost(int64, tag = "14")]
    pub season_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynCourUp {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text1: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(string, tag = "7")]
    pub play_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub can_play: bool,
    ///
    #[prost(bool, tag = "9")]
    pub is_preview: bool,
    ///
    #[prost(int64, tag = "10")]
    pub avid: i64,
    ///
    #[prost(int64, tag = "11")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "12")]
    pub epid: i64,
    ///
    #[prost(int64, tag = "13")]
    pub duration: i64,
    ///
    #[prost(int64, tag = "14")]
    pub season_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynDraw {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<MdlDynDrawItem>,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub id: i64,
    ///
    #[prost(bool, tag = "4")]
    pub is_draw_first: bool,
    ///
    #[prost(bool, tag = "5")]
    pub is_big_cover: bool,
    ///
    #[prost(bool, tag = "6")]
    pub is_article_cover: bool,
    ///
    #[prost(bool, tag = "7")]
    pub unfold_all: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynDrawItem {
    ///
    #[prost(string, tag = "1")]
    pub src: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub width: i64,
    ///
    #[prost(int64, tag = "3")]
    pub height: i64,
    ///
    #[prost(float, tag = "4")]
    pub size: f32,
    ///
    #[prost(message, repeated, tag = "5")]
    pub tags: ::prost::alloc::vec::Vec<MdlDynDrawTag>,
    ///
    #[prost(string, tag = "6")]
    pub src_dark: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "7")]
    pub is_live_photo: bool,
    ///
    #[prost(string, tag = "8")]
    pub live_video_url: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "9")]
    pub live_video_size: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynDrawTag {
    ///
    #[prost(enumeration = "MdlDynDrawTagType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<MdlDynDrawTagItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynDrawTagItem {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub x: i64,
    ///
    #[prost(int64, tag = "4")]
    pub y: i64,
    ///
    #[prost(int32, tag = "5")]
    pub orientation: i32,
    ///
    #[prost(int32, tag = "6")]
    pub source: i32,
    ///
    #[prost(int64, tag = "7")]
    pub item_id: i64,
    ///
    #[prost(int64, tag = "8")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "9")]
    pub tid: i64,
    ///
    #[prost(string, tag = "10")]
    pub poi: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub schema_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynForward {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<DynamicItem>,
    ///
    #[prost(int32, tag = "2")]
    pub rtype: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynLive {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_label2: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "LiveState", tag = "7")]
    pub live_state: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(enumeration = "ReserveType", tag = "9")]
    pub reserve_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynLiveRcmd {
    ///
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ReserveType", tag = "2")]
    pub reserve_type: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub pendant: ::core::option::Option<LivePendant>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynMedialist {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub cover_type: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(string, tag = "8")]
    pub cover_bottom_right_icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynMusic {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub up_id: i64,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub label1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub upper: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynPgc {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "8")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "9")]
    pub epid: i64,
    ///
    #[prost(int64, tag = "10")]
    pub aid: i64,
    ///
    #[prost(enumeration = "MediaType", tag = "11")]
    pub media_type: i32,
    ///
    #[prost(enumeration = "VideoSubType", tag = "12")]
    pub sub_type: i32,
    ///
    #[prost(bool, tag = "13")]
    pub is_preview: bool,
    ///
    #[prost(message, optional, tag = "14")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(message, repeated, tag = "15")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(bool, tag = "16")]
    pub can_play: bool,
    ///
    #[prost(message, optional, tag = "17")]
    pub season: ::core::option::Option<PgcSeason>,
    ///
    #[prost(string, tag = "18")]
    pub play_icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "19")]
    pub duration: i64,
    ///
    #[prost(string, tag = "20")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "21")]
    pub badge_category: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(bool, tag = "22")]
    pub is_feature: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynShareChargingQa {
    ///
    #[prost(message, optional, tag = "1")]
    pub background_img: ::core::option::Option<ImageSet>,
    ///
    #[prost(message, optional, tag = "2")]
    pub left_icon_img: ::core::option::Option<ImageSet>,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub jump_button: ::core::option::Option<IconButton>,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub share_card_meta_info: ::core::option::Option<CommonShareCardInfo>,
    ///
    #[prost(string, tag = "7")]
    pub title_prefix_bold: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynSubscription {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub ad_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub ad_title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(string, tag = "8")]
    pub tips: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynSubscriptionNew {
    ///
    #[prost(enumeration = "MdlDynSubscriptionNewStyle", tag = "1")]
    pub style: i32,
    ///
    #[prost(oneof = "mdl_dyn_subscription_new::Item", tags = "2, 3")]
    pub item: ::core::option::Option<mdl_dyn_subscription_new::Item>,
}
/// Nested message and enum types in `MdlDynSubscriptionNew`.
pub mod mdl_dyn_subscription_new {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        DynSubscription(super::MdlDynSubscription),
        ///
        #[prost(message, tag = "3")]
        DynLiveRcmd(super::MdlDynLiveRcmd),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynTopicSet {
    ///
    #[prost(message, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<TopicItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub more_btn: ::core::option::Option<IconButton>,
    ///
    #[prost(int64, tag = "3")]
    pub topic_set_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub push_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MdlDynUgcSeason {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub id: i64,
    ///
    #[prost(string, tag = "8")]
    pub inline_u_r_l: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "9")]
    pub can_play: bool,
    ///
    #[prost(string, tag = "10")]
    pub play_icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "11")]
    pub avid: i64,
    ///
    #[prost(int64, tag = "12")]
    pub cid: i64,
    ///
    #[prost(message, optional, tag = "13")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(int64, tag = "14")]
    pub duration: i64,
    ///
    #[prost(string, tag = "15")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "16")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MixUpListItem {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub special_attention: i32,
    ///
    #[prost(int32, tag = "3")]
    pub reddot_state: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub live_info: ::core::option::Option<MixUpListLiveItem>,
    ///
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub official: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "8")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(message, optional, tag = "9")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(int32, tag = "10")]
    pub premiere_state: i32,
    ///
    #[prost(string, tag = "11")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "12")]
    pub avatar: ::core::option::Option<
        super::super::super::dagw::component::avatar::v1::AvatarItem,
    >,
    ///
    #[prost(message, optional, tag = "13")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MixUpListLiveItem {
    ///
    #[prost(bool, tag = "1")]
    pub status: bool,
    ///
    #[prost(int64, tag = "2")]
    pub room_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    ///
    #[prost(enumeration = "DynModuleType", tag = "1")]
    pub module_type: i32,
    ///
    #[prost(
        oneof = "module::ModuleItem",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44"
    )]
    pub module_item: ::core::option::Option<module::ModuleItem>,
}
/// Nested message and enum types in `Module`.
pub mod module {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModuleItem {
        ///
        #[prost(message, tag = "2")]
        ModuleAuthor(super::ModuleAuthor),
        ///
        #[prost(message, tag = "3")]
        ModuleDispute(super::ModuleDispute),
        ///
        #[prost(message, tag = "4")]
        ModuleDesc(super::ModuleDesc),
        ///
        #[prost(message, tag = "5")]
        ModuleDynamic(super::ModuleDynamic),
        ///
        #[prost(message, tag = "6")]
        ModuleLikeUser(super::ModuleLikeUser),
        ///
        #[prost(message, tag = "7")]
        ModuleExtend(super::ModuleExtend),
        ///
        #[prost(message, tag = "8")]
        ModuleAdditional(super::ModuleAdditional),
        ///
        #[prost(message, tag = "9")]
        ModuleStat(super::ModuleStat),
        ///
        #[prost(message, tag = "10")]
        ModuleFold(super::ModuleFold),
        ///
        #[prost(message, tag = "11")]
        ModuleComment(super::ModuleComment),
        ///
        #[prost(message, tag = "12")]
        ModuleInteraction(super::ModuleInteraction),
        ///
        #[prost(message, tag = "13")]
        ModuleAuthorForward(super::ModuleAuthorForward),
        ///
        #[prost(message, tag = "14")]
        ModuleAd(super::ModuleAd),
        ///
        #[prost(message, tag = "15")]
        ModuleBanner(super::ModuleBanner),
        ///
        #[prost(message, tag = "16")]
        ModuleItemNull(super::ModuleItemNull),
        ///
        #[prost(message, tag = "17")]
        ModuleShareInfo(super::ModuleShareInfo),
        ///
        #[prost(message, tag = "18")]
        ModuleRecommend(super::ModuleRecommend),
        ///
        #[prost(message, tag = "19")]
        ModuleTop(super::ModuleTop),
        ///
        #[prost(message, tag = "20")]
        ModuleButtom(super::ModuleButtom),
        ///
        #[prost(message, tag = "21")]
        ModuleStatForward(super::ModuleStat),
        ///
        #[prost(message, tag = "22")]
        ModuleStory(super::ModuleStory),
        ///
        #[prost(message, tag = "23")]
        ModuleTopic(super::ModuleTopic),
        ///
        #[prost(message, tag = "24")]
        ModuleTopicDetailsExt(super::ModuleTopicDetailsExt),
        ///
        #[prost(message, tag = "25")]
        ModuleTopTag(super::ModuleTopTag),
        ///
        #[prost(message, tag = "26")]
        ModuleTopicBrief(super::ModuleTopicBrief),
        ///
        #[prost(message, tag = "27")]
        ModuleTitle(super::ModuleTitle),
        ///
        #[prost(message, tag = "28")]
        ModuleButton(super::ModuleButton),
        ///
        #[prost(message, tag = "29")]
        ModuleNotice(super::ModuleNotice),
        ///
        #[prost(message, tag = "30")]
        ModuleOpusSummary(super::ModuleOpusSummary),
        ///
        #[prost(message, tag = "31")]
        ModuleCopyright(super::ModuleCopyright),
        ///
        #[prost(message, tag = "32")]
        ModuleParagraph(super::ModuleParagraph),
        ///
        #[prost(message, tag = "33")]
        ModuleBlocked(super::ModuleBlocked),
        ///
        #[prost(message, tag = "34")]
        ModuleTextNotice(super::ModuleTextNotice),
        ///
        #[prost(message, tag = "35")]
        ModuleOpusCollection(super::ModuleOpusCollection),
        ///
        #[prost(message, tag = "36")]
        ModuleOnetimeNotice(super::ModuleOnetimeNotice),
        ///
        #[prost(message, tag = "37")]
        ModuleSneakingAd(super::ModuleSneakingAd),
        ///
        #[prost(message, tag = "38")]
        ModuleMangaHorizontalPagePicContent(super::ModuleMangaHorizontalPagePicContent),
        ///
        #[prost(message, tag = "39")]
        ModuleMangaVerticalSlidePicContent(super::ModuleMangaVerticalSlidePicContent),
        ///
        #[prost(message, tag = "40")]
        ModuleMangaCoverPicContent(super::ModuleMangaCoverPicContent),
        ///
        #[prost(message, tag = "41")]
        ModuleAuthorForSubscribe(super::ModuleAuthorForSubscribe),
        ///
        #[prost(message, tag = "42")]
        ModuleAuthorSlim(super::ModuleAuthorSlim),
        ///
        #[prost(message, tag = "43")]
        ModuleMangaCollection(super::ModuleMangaCollection),
        ///
        #[prost(message, tag = "44")]
        ModuleCooperation(super::ModuleCooperation),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAd {
    ///
    #[prost(message, optional, tag = "1")]
    pub source_content: ::core::option::Option<::prost_types::Any>,
    ///
    #[prost(message, optional, tag = "2")]
    pub module_author: ::core::option::Option<ModuleAuthor>,
    ///
    #[prost(int32, tag = "3")]
    pub ad_content_type: i32,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text3: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAdditional {
    ///
    #[prost(enumeration = "AdditionalType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "7")]
    pub rid: i64,
    ///
    #[prost(bool, tag = "11")]
    pub need_write_calender: bool,
    ///
    #[prost(
        oneof = "module_additional::Item",
        tags = "2, 3, 4, 5, 6, 8, 9, 10, 12, 13, 14"
    )]
    pub item: ::core::option::Option<module_additional::Item>,
}
/// Nested message and enum types in `ModuleAdditional`.
pub mod module_additional {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        Pgc(super::AdditionalPgc),
        ///
        #[prost(message, tag = "3")]
        Goods(super::AdditionGoods),
        ///
        #[prost(message, tag = "4")]
        Vote(super::AdditionVote),
        ///
        #[prost(message, tag = "5")]
        Common(super::AdditionCommon),
        ///
        #[prost(message, tag = "6")]
        Esport(super::AdditionEsport),
        ///
        #[prost(message, tag = "8")]
        Vote2(super::AdditionVote2),
        ///
        #[prost(message, tag = "9")]
        Ugc(super::AdditionUgc),
        ///
        #[prost(message, tag = "10")]
        Up(super::AdditionUp),
        ///
        #[prost(message, tag = "12")]
        Article(super::AdditionArticle),
        ///
        #[prost(message, tag = "13")]
        Live(super::AdditionLiveRoom),
        ///
        #[prost(message, tag = "14")]
        Music(super::AdditionMusic),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub ptime_label_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<UserInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub decorate_card: ::core::option::Option<DecorateCard>,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub tp_list: ::prost::alloc::vec::Vec<ThreePointItem>,
    ///
    #[prost(enumeration = "ModuleAuthorBadgeType", tag = "7")]
    pub badge_type: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub badge_button: ::core::option::Option<ModuleAuthorBadgeButton>,
    ///
    #[prost(int32, tag = "9")]
    pub attend: i32,
    ///
    #[prost(message, optional, tag = "10")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(message, optional, tag = "11")]
    pub weight: ::core::option::Option<Weight>,
    ///
    #[prost(bool, tag = "12")]
    pub show_follow: bool,
    ///
    #[prost(bool, tag = "13")]
    pub is_top: bool,
    ///
    #[prost(string, tag = "14")]
    pub ptime_location_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "15")]
    pub show_level: bool,
    ///
    #[prost(message, optional, tag = "16")]
    pub only_fans: ::core::option::Option<OnlyFans>,
    ///
    #[prost(message, optional, tag = "17")]
    pub author_badge: ::core::option::Option<AuthorBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthorBadgeButton {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub state: i32,
    ///
    #[prost(int64, tag = "4")]
    pub id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthorForSubscribe {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub subscribe_btn: ::core::option::Option<SubscribeButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthorForward {
    ///
    #[prost(message, repeated, tag = "1")]
    pub title: ::prost::alloc::vec::Vec<ModuleAuthorForwardTitle>,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub uid: i64,
    ///
    #[prost(string, tag = "4")]
    pub ptime_label_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub show_follow: bool,
    ///
    #[prost(string, tag = "6")]
    pub face_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(message, repeated, tag = "8")]
    pub tp_list: ::prost::alloc::vec::Vec<ThreePointItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthorForwardTitle {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthorSlim {
    ///
    #[prost(message, optional, tag = "1")]
    pub user_info: ::core::option::Option<BasicUserInfoV2>,
    ///
    #[prost(string, tag = "2")]
    pub ptime_label_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBanner {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ModuleBannerType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "4")]
    pub dislike_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub dislike_icon: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "module_banner::Item", tags = "3")]
    pub item: ::core::option::Option<module_banner::Item>,
}
/// Nested message and enum types in `ModuleBanner`.
pub mod module_banner {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "3")]
        User(super::ModuleBannerUser),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBannerUser {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<ModuleBannerUserItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBannerUserItem {
    ///
    #[prost(string, tag = "1")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub uid: i64,
    ///
    #[prost(enumeration = "LiveState", tag = "4")]
    pub live_state: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub official: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "6")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(string, tag = "7")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub button: ::core::option::Option<AdditionalButton>,
    ///
    #[prost(string, tag = "9")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub relation: ::core::option::Option<Relation>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBlocked {
    ///
    #[prost(message, optional, tag = "1")]
    pub icon: ::core::option::Option<ImageSet>,
    ///
    #[prost(message, optional, tag = "2")]
    pub bg_img: ::core::option::Option<ImageSet>,
    ///
    #[prost(string, tag = "3")]
    pub hint_message: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub act_btn: ::core::option::Option<IconButton>,
    ///
    #[prost(enumeration = "MdlBlockedStyle", tag = "5")]
    pub block_style: i32,
    ///
    #[prost(string, tag = "6")]
    pub sub_hint_message: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub video_bottom_text_upper: ::core::option::Option<OneLineText>,
    ///
    #[prost(message, optional, tag = "8")]
    pub video_bottom_text_lower: ::core::option::Option<OneLineText>,
    ///
    #[prost(string, tag = "9")]
    pub archive_title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub hint_message_one_line: ::core::option::Option<OneLineText>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleButtom {
    ///
    #[prost(message, optional, tag = "1")]
    pub module_stat: ::core::option::Option<ModuleStat>,
    ///
    #[prost(bool, tag = "2")]
    pub comment_box: bool,
    ///
    #[prost(string, tag = "3")]
    pub comment_box_msg: ::prost::alloc::string::String,
    ///
    #[prost(int32, repeated, tag = "4")]
    pub interaction_icons: ::prost::alloc::vec::Vec<i32>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub faces: ::prost::alloc::vec::Vec<InteractionFace>,
}
/// Nested message and enum types in `ModuleButtom`.
pub mod module_buttom {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractionIcon {
        ///
        IconInvalid = 0,
        ///
        IconForward = 1,
        ///
        IconComment = 2,
        ///
        IconFavorite = 3,
        ///
        IconLike = 4,
    }
    impl InteractionIcon {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::IconInvalid => "ICON_INVALID",
                Self::IconForward => "ICON_FORWARD",
                Self::IconComment => "ICON_COMMENT",
                Self::IconFavorite => "ICON_FAVORITE",
                Self::IconLike => "ICON_LIKE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ICON_INVALID" => Some(Self::IconInvalid),
                "ICON_FORWARD" => Some(Self::IconForward),
                "ICON_COMMENT" => Some(Self::IconComment),
                "ICON_FAVORITE" => Some(Self::IconFavorite),
                "ICON_LIKE" => Some(Self::IconLike),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleButton {
    ///
    #[prost(message, optional, tag = "1")]
    pub btn: ::core::option::Option<IconButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleComment {
    ///
    #[prost(message, repeated, tag = "1")]
    pub cmt_show_item: ::prost::alloc::vec::Vec<CmtShowItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleCooperation {
    ///
    #[prost(string, tag = "1")]
    pub oid: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub up_list: ::prost::alloc::vec::Vec<CooperationUpInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub more_btn: ::core::option::Option<IconButton>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub tp_list: ::prost::alloc::vec::Vec<ThreePointItem>,
    ///
    #[prost(string, tag = "5")]
    pub float_title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleCopyright {
    ///
    #[prost(string, tag = "1")]
    pub left_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub right_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDesc {
    ///
    #[prost(message, repeated, tag = "1")]
    pub desc: ::prost::alloc::vec::Vec<Description>,
    ///
    #[prost(string, tag = "2")]
    pub jump_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDescGoods {
    ///
    #[prost(int32, tag = "1")]
    pub source_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub schema_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub item_id: i64,
    ///
    #[prost(string, repeated, tag = "5")]
    pub open_white_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(bool, tag = "6")]
    pub user_web_v2: bool,
    ///
    #[prost(string, tag = "7")]
    pub ad_mark: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub schema_package_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "GoodsJumpType", tag = "9")]
    pub jump_type: i32,
    ///
    #[prost(string, tag = "10")]
    pub app_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDispute {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDynamic {
    ///
    #[prost(enumeration = "ModuleDynamicType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(
        oneof = "module_dynamic::ModuleItem",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21"
    )]
    pub module_item: ::core::option::Option<module_dynamic::ModuleItem>,
}
/// Nested message and enum types in `ModuleDynamic`.
pub mod module_dynamic {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModuleItem {
        ///
        #[prost(message, tag = "2")]
        DynArchive(super::MdlDynArchive),
        ///
        #[prost(message, tag = "3")]
        DynPgc(super::MdlDynPgc),
        ///
        #[prost(message, tag = "4")]
        DynCourSeason(super::MdlDynCourSeason),
        ///
        #[prost(message, tag = "5")]
        DynCourBatch(super::MdlDynCourBatch),
        ///
        #[prost(message, tag = "6")]
        DynForward(super::MdlDynForward),
        ///
        #[prost(message, tag = "7")]
        DynDraw(super::MdlDynDraw),
        ///
        #[prost(message, tag = "8")]
        DynArticle(super::MdlDynArticle),
        ///
        #[prost(message, tag = "9")]
        DynMusic(super::MdlDynMusic),
        ///
        #[prost(message, tag = "10")]
        DynCommon(super::MdlDynCommon),
        ///
        #[prost(message, tag = "11")]
        DynCommonLive(super::MdlDynLive),
        ///
        #[prost(message, tag = "12")]
        DynMedialist(super::MdlDynMedialist),
        ///
        #[prost(message, tag = "13")]
        DynApplet(super::MdlDynApplet),
        ///
        #[prost(message, tag = "14")]
        DynSubscription(super::MdlDynSubscription),
        ///
        #[prost(message, tag = "15")]
        DynLiveRcmd(super::MdlDynLiveRcmd),
        ///
        #[prost(message, tag = "16")]
        DynUgcSeason(super::MdlDynUgcSeason),
        ///
        #[prost(message, tag = "17")]
        DynSubscriptionNew(super::MdlDynSubscriptionNew),
        ///
        #[prost(message, tag = "18")]
        DynCourBatchUp(super::MdlDynCourUp),
        ///
        #[prost(message, tag = "19")]
        DynTopicSet(super::MdlDynTopicSet),
        ///
        #[prost(message, tag = "20")]
        DynChargingArchive(super::MdlDynChargingArchive),
        ///
        #[prost(message, tag = "21")]
        DynShareChargingQa(super::MdlDynShareChargingQa),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleExtend {
    ///
    #[prost(message, repeated, tag = "1")]
    pub extend: ::prost::alloc::vec::Vec<ModuleExtendItem>,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleExtendItem {
    ///
    #[prost(enumeration = "DynExtendType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(oneof = "module_extend_item::Extend", tags = "2, 3, 4, 5, 6, 7")]
    pub extend: ::core::option::Option<module_extend_item::Extend>,
}
/// Nested message and enum types in `ModuleExtendItem`.
pub mod module_extend_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Extend {
        ///
        #[prost(message, tag = "2")]
        ExtInfoTopic(super::ExtInfoTopic),
        ///
        #[prost(message, tag = "3")]
        ExtInfoLbs(super::ExtInfoLbs),
        ///
        #[prost(message, tag = "4")]
        ExtInfoHot(super::ExtInfoHot),
        ///
        #[prost(message, tag = "5")]
        ExtInfoGame(super::ExtInfoGame),
        ///
        #[prost(message, tag = "6")]
        ExtInfoCommon(super::ExtInfoCommon),
        ///
        #[prost(message, tag = "7")]
        ExtInfoOgv(super::ExtInfoOgv),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleFold {
    ///
    #[prost(enumeration = "FoldType", tag = "1")]
    pub fold_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub fold_ids: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub fold_users: ::prost::alloc::vec::Vec<UserInfo>,
    ///
    #[prost(message, optional, tag = "5")]
    pub topic_merged_resource: ::core::option::Option<TopicMergedResource>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleInteraction {
    ///
    #[prost(message, repeated, tag = "1")]
    pub interaction_item: ::prost::alloc::vec::Vec<InteractionItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleItemNull {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleLikeUser {
    ///
    #[prost(message, repeated, tag = "1")]
    pub like_users: ::prost::alloc::vec::Vec<LikeUser>,
    ///
    #[prost(string, tag = "2")]
    pub display_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMangaCollection {
    ///
    #[prost(string, tag = "1")]
    pub title_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sub_text_left: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub sub_text_right: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub subscribe_btn: ::core::option::Option<SubscribeButton>,
    ///
    #[prost(message, optional, tag = "6")]
    pub manga_collection_info: ::core::option::Option<OpusCollection>,
    ///
    #[prost(string, tag = "7")]
    pub float_btn_prev_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub float_btn_next_link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMangaCoverPicContent {
    ///
    #[prost(message, optional, tag = "1")]
    pub manga_pic: ::core::option::Option<MangaLikePic>,
    ///
    #[prost(enumeration = "MangaLikePicClickAction", tag = "2")]
    pub pic_click_action: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMangaHorizontalPagePicContent {
    ///
    #[prost(enumeration = "MangaLikePageDirection", tag = "1")]
    pub page_direction: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub manga_pics: ::prost::alloc::vec::Vec<MangaLikePic>,
    ///
    #[prost(enumeration = "MangaLikePicClickAction", tag = "3")]
    pub pic_click_action: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub browser_guidance: ::core::option::Option<MangaLikeBrowserGuidance>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleMangaVerticalSlidePicContent {
    ///
    #[prost(message, optional, tag = "1")]
    pub manga_pic: ::core::option::Option<MangaLikePic>,
    ///
    #[prost(enumeration = "MangaLikePicClickAction", tag = "2")]
    pub pic_click_action: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleNotice {
    ///
    #[prost(string, tag = "1")]
    pub identity: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub notice_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleOnetimeNotice {
    ///
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub text_notice: ::core::option::Option<TextParagraph>,
    ///
    #[prost(string, tag = "3")]
    pub jump_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleOpusCollection {
    ///
    #[prost(message, optional, tag = "1")]
    pub collection_info: ::core::option::Option<OpusCollection>,
    ///
    #[prost(string, tag = "2")]
    pub title_upper: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title_prefix_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub total_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleOpusSummary {
    ///
    #[prost(message, optional, tag = "1")]
    pub title: ::core::option::Option<Paragraph>,
    ///
    #[prost(message, optional, tag = "2")]
    pub summary: ::core::option::Option<Paragraph>,
    ///
    #[prost(string, tag = "3")]
    pub summary_jump_btn_text: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub covers: ::prost::alloc::vec::Vec<MdlDynDrawItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleParagraph {
    ///
    #[prost(message, optional, tag = "1")]
    pub paragraph: ::core::option::Option<Paragraph>,
    ///
    #[prost(bool, tag = "2")]
    pub is_article_title: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub para_spacing: ::core::option::Option<ParaSpacing>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRcmd {
    ///
    #[prost(message, optional, tag = "1")]
    pub author: ::core::option::Option<RcmdAuthor>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<RcmdItem>,
    ///
    #[prost(string, tag = "3")]
    pub server_info: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRecommend {
    ///
    #[prost(string, tag = "1")]
    pub module_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub tag: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub ad: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleShareInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub share_channels: ::prost::alloc::vec::Vec<ShareChannel>,
    ///
    #[prost(string, tag = "3")]
    pub share_origin: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub oid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub sid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleSneakingAd {
    ///
    #[prost(string, tag = "1")]
    pub client_action_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleStat {
    ///
    #[prost(int64, tag = "1")]
    pub repost: i64,
    ///
    #[prost(int64, tag = "2")]
    pub like: i64,
    ///
    #[prost(int64, tag = "3")]
    pub reply: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub like_info: ::core::option::Option<LikeInfo>,
    ///
    #[prost(bool, tag = "5")]
    pub no_comment: bool,
    ///
    #[prost(bool, tag = "6")]
    pub no_forward: bool,
    ///
    #[prost(string, tag = "7")]
    pub reply_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub no_comment_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub no_forward_text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub favorite: i64,
    ///
    #[prost(bool, tag = "11")]
    pub is_favorite: bool,
    ///
    #[prost(bool, tag = "12")]
    pub no_like: bool,
    ///
    #[prost(string, tag = "13")]
    pub no_like_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleStory {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<StoryItem>,
    ///
    #[prost(bool, tag = "3")]
    pub show_publish_entrance: bool,
    ///
    #[prost(int64, tag = "4")]
    pub fold_state: i64,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub publish_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTextNotice {
    ///
    #[prost(message, optional, tag = "1")]
    pub notice: ::core::option::Option<OneLineText>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTitle {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub right_btn: ::core::option::Option<IconButton>,
    ///
    #[prost(int32, tag = "3")]
    pub title_style: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTop {
    ///
    #[prost(message, repeated, tag = "1")]
    pub tp_list: ::prost::alloc::vec::Vec<ThreePointItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub archive: ::core::option::Option<MdlDynArchive>,
    ///
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<ModuleAuthor>,
    ///
    #[prost(bool, tag = "4")]
    pub hidden_nav_bar: bool,
    ///
    #[prost(message, optional, tag = "5")]
    pub subscribe_author: ::core::option::Option<ModuleAuthorForSubscribe>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTopTag {
    ///
    #[prost(string, tag = "1")]
    pub tag_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTopic {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTopicBrief {
    ///
    #[prost(message, optional, tag = "1")]
    pub topic: ::core::option::Option<TopicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleTopicDetailsExt {
    ///
    #[prost(string, tag = "1")]
    pub comment_guide: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NftInfo {
    ///
    #[prost(enumeration = "NftRegionType", tag = "1")]
    pub region_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub region_icon: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "NftShowStatus", tag = "3")]
    pub region_show_status: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nameplate {
    ///
    #[prost(int64, tag = "1")]
    pub nid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub image_small: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub level: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub condition: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewEp {
    ///
    #[prost(int32, tag = "1")]
    pub id: i32,
    ///
    #[prost(string, tag = "2")]
    pub index_show: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoReply {}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NoteVideoTs {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub status: i64,
    ///
    #[prost(int64, tag = "4")]
    pub index: i64,
    ///
    #[prost(int64, tag = "5")]
    pub seconds: i64,
    ///
    #[prost(int64, tag = "6")]
    pub cid_count: i64,
    ///
    #[prost(string, tag = "7")]
    pub key: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub epid: i64,
    ///
    #[prost(string, tag = "10")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialAccountInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub author: ::core::option::Option<UserInfo>,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(string, tag = "5")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub desc_text2: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialAccountsReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<OfficialAccountInfo>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(int64, tag = "3")]
    pub offset: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialAccountsReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub offset: i64,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "4")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialDynamicsReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<OfficialItem>,
    ///
    #[prost(int64, tag = "2")]
    pub offset: i64,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialDynamicsReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub offset: i64,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "4")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialItem {
    ///
    #[prost(enumeration = "RcmdType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(oneof = "official_item::RcmdItem", tags = "2, 3")]
    pub rcmd_item: ::core::option::Option<official_item::RcmdItem>,
}
/// Nested message and enum types in `OfficialItem`.
pub mod official_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RcmdItem {
        ///
        #[prost(message, tag = "2")]
        RcmdArchive(super::OfficialRcmdArchive),
        ///
        #[prost(message, tag = "3")]
        RcmdDynamic(super::OfficialRcmdDynamic),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialRcmdArchive {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover_right_text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CoverIcon", tag = "4")]
    pub desc_icon1: i32,
    ///
    #[prost(string, tag = "5")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CoverIcon", tag = "6")]
    pub desc_icon2: i32,
    ///
    #[prost(string, tag = "7")]
    pub desc_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub reason: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "9")]
    pub show_three_point: bool,
    ///
    #[prost(string, tag = "10")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "11")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "12")]
    pub mid: i64,
    ///
    #[prost(string, tag = "13")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "14")]
    pub dynamic_id: i64,
    ///
    #[prost(int64, tag = "15")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialRcmdDynamic {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover_right_top_text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CoverIcon", tag = "4")]
    pub desc_icon1: i32,
    ///
    #[prost(string, tag = "5")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CoverIcon", tag = "6")]
    pub desc_icon2: i32,
    ///
    #[prost(string, tag = "7")]
    pub desc_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub reason: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub dynamic_id: i64,
    ///
    #[prost(int64, tag = "11")]
    pub mid: i64,
    ///
    #[prost(string, tag = "12")]
    pub user_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "13")]
    pub rid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialVerify {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub is_atten: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneLineText {
    ///
    #[prost(message, repeated, tag = "1")]
    pub texts: ::prost::alloc::vec::Vec<TextWithPriority>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyFans {
    ///
    #[prost(bool, tag = "1")]
    pub is_only_fans: bool,
    ///
    #[prost(message, optional, tag = "2")]
    pub badge: ::core::option::Option<IconBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyFansProperty {
    ///
    #[prost(bool, tag = "1")]
    pub has_privilege: bool,
    ///
    #[prost(bool, tag = "2")]
    pub is_only_fans: bool,
    ///
    #[prost(bool, tag = "3")]
    pub allow_download: bool,
    ///
    #[prost(string, tag = "4")]
    pub embed_cashier_link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyFansVoteProperty {
    ///
    #[prost(bool, tag = "1")]
    pub is_only_fans_vote: bool,
    ///
    #[prost(bool, tag = "2")]
    pub has_vote_permission: bool,
    ///
    #[prost(string, tag = "3")]
    pub vote_btn_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub vote_btn_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub vote_annotation_part1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub vote_annotation_part2: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusCollection {
    ///
    #[prost(int64, tag = "1")]
    pub collection_id: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub title: ::core::option::Option<OneLineText>,
    ///
    #[prost(string, tag = "3")]
    pub detail_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub intro: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "5")]
    pub all_items: ::prost::alloc::vec::Vec<OpusCollectionItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusCollectionDetailReq {
    ///
    #[prost(string, tag = "1")]
    pub collection_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub selected_opus_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub selected_oid_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub selected_oid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub local_time: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusCollectionDetailResp {
    ///
    #[prost(string, tag = "1")]
    pub collection_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub collection_cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub collection_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub sub_title_part1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub sub_title_part2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub collection_intro: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "8")]
    pub item_list: ::prost::alloc::vec::Vec<OpusCollectionItem>,
    ///
    #[prost(int64, tag = "9")]
    pub total_cnt: i64,
    ///
    #[prost(message, optional, tag = "10")]
    pub author_info: ::core::option::Option<BasicUserInfoV2>,
    ///
    #[prost(message, optional, tag = "11")]
    pub bottom_button: ::core::option::Option<ButtonWithSubTitle>,
    ///
    #[prost(message, optional, tag = "12")]
    pub subscribe_btn: ::core::option::Option<SubscribeButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusCollectionItem {
    ///
    #[prost(int64, tag = "1")]
    pub opus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub pub_time: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub is_selected_highlight: bool,
    ///
    #[prost(string, tag = "6")]
    pub prefix_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub collection_item_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub collection_item_oid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusCollectionWithCover {
    ///
    #[prost(message, optional, tag = "1")]
    pub collection_info: ::core::option::Option<OpusCollection>,
    ///
    #[prost(string, tag = "2")]
    pub cover_pic: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub cover_bottom_text: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(string, tag = "4")]
    pub sub_title_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusCreationItem {
    ///
    #[prost(enumeration = "OpusType", tag = "1")]
    pub opus_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub cover_pic: ::core::option::Option<MdlDynDrawItem>,
    ///
    #[prost(message, optional, tag = "3")]
    pub cover_top_right_badge: ::core::option::Option<VideoBadge>,
    ///
    #[prost(message, optional, tag = "4")]
    pub text_paragraph: ::core::option::Option<Paragraph>,
    ///
    #[prost(message, optional, tag = "5")]
    pub hint_text: ::core::option::Option<ColoredText>,
    ///
    #[prost(string, tag = "6")]
    pub bottom_text: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "7")]
    pub stats: ::prost::alloc::vec::Vec<CoverIconWithText>,
    ///
    #[prost(message, repeated, tag = "8")]
    pub tp_list: ::prost::alloc::vec::Vec<CreationItemAction>,
    ///
    #[prost(message, optional, tag = "9")]
    pub extend: ::core::option::Option<Extend>,
    ///
    #[prost(message, optional, tag = "10")]
    pub visibility_status: ::core::option::Option<CoverIconWithText>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusDetailReq {
    ///
    #[prost(enumeration = "OpusType", tag = "1")]
    pub opus_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub dyn_type: i64,
    ///
    #[prost(string, tag = "4")]
    pub share_id: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub share_mode: i32,
    ///
    #[prost(int32, tag = "10")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "11")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(message, optional, tag = "12")]
    pub config: ::core::option::Option<Config>,
    ///
    #[prost(message, optional, tag = "13")]
    pub ad_param: ::core::option::Option<AdParam>,
    ///
    #[prost(string, tag = "14")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "15")]
    pub pattern: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusDetailResp {
    ///
    #[prost(message, optional, tag = "1")]
    pub opus_item: ::core::option::Option<OpusItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusFavItem {
    ///
    #[prost(int64, tag = "1")]
    pub opus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub card_uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub cover_pic: ::core::option::Option<MdlDynDrawItem>,
    ///
    #[prost(message, optional, tag = "4")]
    pub text_paragraph: ::core::option::Option<Paragraph>,
    ///
    #[prost(message, optional, tag = "5")]
    pub bottom_text: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(string, tag = "6")]
    pub click_toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusFlowItem {
    ///
    #[prost(enumeration = "FlowItemType", tag = "1")]
    pub item_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub extend: ::core::option::Option<Extend>,
    ///
    #[prost(oneof = "opus_flow_item::Data", tags = "4")]
    pub data: ::core::option::Option<opus_flow_item::Data>,
}
/// Nested message and enum types in `OpusFlowItem`.
pub mod opus_flow_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        ///
        #[prost(message, tag = "4")]
        FlowItemOpus(super::FlowItemOpus),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusItem {
    ///
    #[prost(int64, tag = "1")]
    pub opus_id: i64,
    ///
    #[prost(enumeration = "OpusType", tag = "2")]
    pub opus_type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub oid: i64,
    ///
    #[prost(message, repeated, tag = "4")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    ///
    #[prost(message, optional, tag = "5")]
    pub extend: ::core::option::Option<Extend>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusSpaceFlowReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_mid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub local_time: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusSpaceFlowResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub item_list: ::prost::alloc::vec::Vec<OpusFlowItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub next_page: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
    ///
    #[prost(message, optional, tag = "3")]
    pub host_up_opus_collection: ::core::option::Option<SectionOpusCollection>,
    ///
    #[prost(message, optional, tag = "4")]
    pub host_up_note_nav_bar: ::core::option::Option<SectionNoteNavigationBar>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PgcSeason {
    ///
    #[prost(int32, tag = "1")]
    pub is_finish: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParaSpacing {
    ///
    #[prost(double, tag = "1")]
    pub spacing_before_para: f64,
    ///
    #[prost(double, tag = "2")]
    pub spacing_after_para: f64,
    ///
    #[prost(double, tag = "3")]
    pub line_spacing: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Paragraph {
    ///
    #[prost(enumeration = "paragraph::ParagraphType", tag = "1")]
    pub para_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub para_format: ::core::option::Option<paragraph::ParagraphFormat>,
    ///
    #[prost(oneof = "paragraph::Content", tags = "3, 4, 5, 6, 7")]
    pub content: ::core::option::Option<paragraph::Content>,
}
/// Nested message and enum types in `Paragraph`.
pub mod paragraph {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListFormat {
        ///
        #[prost(int32, tag = "1")]
        pub level: i32,
        ///
        #[prost(int32, tag = "2")]
        pub order: i32,
        ///
        #[prost(string, tag = "3")]
        pub theme: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParagraphFormat {
        ///
        #[prost(enumeration = "ParagraphAlign", tag = "1")]
        pub align: i32,
        ///
        #[prost(message, optional, tag = "2")]
        pub list_format: ::core::option::Option<ListFormat>,
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParagraphAlign {
        ///
        Left = 0,
        ///
        Middle = 1,
        ///
        Right = 2,
    }
    impl ParagraphAlign {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Left => "LEFT",
                Self::Middle => "MIDDLE",
                Self::Right => "RIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LEFT" => Some(Self::Left),
                "MIDDLE" => Some(Self::Middle),
                "RIGHT" => Some(Self::Right),
                _ => None,
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParagraphType {
        ///
        InvalidParagraphType = 0,
        ///
        Text = 1,
        ///
        Pictures = 2,
        ///
        Line = 3,
        ///
        Reference = 4,
        ///
        SortedList = 5,
        ///
        UnsortedList = 6,
        ///
        LinkCard = 7,
        ///
        Code = 8,
    }
    impl ParagraphType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InvalidParagraphType => "INVALID_ParagraphType",
                Self::Text => "TEXT",
                Self::Pictures => "PICTURES",
                Self::Line => "LINE",
                Self::Reference => "REFERENCE",
                Self::SortedList => "SORTED_LIST",
                Self::UnsortedList => "UNSORTED_LIST",
                Self::LinkCard => "LINK_CARD",
                Self::Code => "CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_ParagraphType" => Some(Self::InvalidParagraphType),
                "TEXT" => Some(Self::Text),
                "PICTURES" => Some(Self::Pictures),
                "LINE" => Some(Self::Line),
                "REFERENCE" => Some(Self::Reference),
                "SORTED_LIST" => Some(Self::SortedList),
                "UNSORTED_LIST" => Some(Self::UnsortedList),
                "LINK_CARD" => Some(Self::LinkCard),
                "CODE" => Some(Self::Code),
                _ => None,
            }
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        ///
        #[prost(message, tag = "3")]
        Text(super::TextParagraph),
        ///
        #[prost(message, tag = "4")]
        Pic(super::PicParagraph),
        ///
        #[prost(message, tag = "5")]
        Line(super::LineParagraph),
        ///
        #[prost(message, tag = "6")]
        LinkCard(super::CardParagraph),
        ///
        #[prost(message, tag = "7")]
        Code(super::CodeParagraph),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PicParagraph {
    ///
    #[prost(message, optional, tag = "1")]
    pub pics: ::core::option::Option<MdlDynDraw>,
    ///
    #[prost(enumeration = "pic_paragraph::PicParagraphStyle", tag = "2")]
    pub style: i32,
}
/// Nested message and enum types in `PicParagraph`.
pub mod pic_paragraph {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PicParagraphStyle {
        ///
        InvalidPicParagraphStyle = 0,
        ///
        NineCell = 1,
        ///
        BigScroll = 2,
    }
    impl PicParagraphStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InvalidPicParagraphStyle => "INVALID_PicParagraphStyle",
                Self::NineCell => "NINE_CELL",
                Self::BigScroll => "BIG_SCROLL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_PicParagraphStyle" => Some(Self::InvalidPicParagraphStyle),
                "NINE_CELL" => Some(Self::NineCell),
                "BIG_SCROLL" => Some(Self::BigScroll),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayurlParam {
    ///
    #[prost(int32, tag = "1")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "2")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "3")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "4")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "5")]
    pub fourk: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Popup {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtectedStaticResource {
    ///
    #[prost(string, tag = "1")]
    pub res_url: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_already_signed: bool,
    ///
    #[prost(string, tag = "3")]
    pub sign_param: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickConsumeMoreAvatarListReply {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(message, repeated, tag = "3")]
    pub up_list: ::prost::alloc::vec::Vec<UpListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickConsumeMoreAvatarListReq {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdArchive {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CoverIcon", tag = "3")]
    pub cover_left_icon1: i32,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "6")]
    pub is_pgc: bool,
    ///
    #[prost(int64, tag = "7")]
    pub aid: i64,
    ///
    #[prost(message, optional, tag = "8")]
    pub badge: ::core::option::Option<IconBadge>,
    ///
    #[prost(enumeration = "CoverIcon", tag = "9")]
    pub cover_left_icon2: i32,
    ///
    #[prost(string, tag = "10")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CoverIcon", tag = "11")]
    pub cover_left_icon3: i32,
    ///
    #[prost(string, tag = "12")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "15")]
    pub rcmd_reason: ::core::option::Option<RcmdReason>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdAuthor {
    ///
    #[prost(message, optional, tag = "1")]
    pub author: ::core::option::Option<UserInfo>,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub relation: ::core::option::Option<Relation>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdCampusBrief {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub campus_badge: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdItem {
    ///
    #[prost(enumeration = "RcmdType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(oneof = "rcmd_item::RcmdItem", tags = "2")]
    pub rcmd_item: ::core::option::Option<rcmd_item::RcmdItem>,
}
/// Nested message and enum types in `RcmdItem`.
pub mod rcmd_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RcmdItem {
        ///
        #[prost(message, tag = "2")]
        RcmdArchive(super::RcmdArchive),
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RcmdOption {
    ///
    #[prost(bool, tag = "1")]
    pub show_title: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdReason {
    ///
    #[prost(string, tag = "1")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "RcmdReasonStyle", tag = "2")]
    pub style: i32,
    ///
    #[prost(string, tag = "3")]
    pub rcmd_reason: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub up_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdTopButton {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RcmdUPsParam {
    ///
    #[prost(int64, tag = "1")]
    pub dislike_ts: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionListItem {
    ///
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<UserInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(string, tag = "3")]
    pub act_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub rcmd_reason: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionListReply {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub reaction_list: ::prost::alloc::vec::Vec<ReactionListItem>,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub has_more: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactionListReq {
    ///
    #[prost(int64, tag = "1")]
    pub dynamic_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rid: i64,
    ///
    #[prost(string, tag = "4")]
    pub offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    ///
    #[prost(enumeration = "RelationStatus", tag = "1")]
    pub status: i32,
    ///
    #[prost(int32, tag = "2")]
    pub is_follow: i32,
    ///
    #[prost(int32, tag = "3")]
    pub is_followed: i32,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepostExtraInfo {
    ///
    #[prost(string, tag = "1")]
    pub adcm_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepostListReq {
    ///
    #[prost(string, tag = "1")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rid: i64,
    ///
    #[prost(string, tag = "4")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "RepostType", tag = "6")]
    pub repost_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepostListRsp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(int64, tag = "4")]
    pub total_count: i64,
    ///
    #[prost(enumeration = "RepostType", tag = "5")]
    pub repost_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchoolRecommendReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CampusInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchoolRecommendReq {
    ///
    #[prost(float, tag = "1")]
    pub lat: f32,
    ///
    #[prost(float, tag = "2")]
    pub lng: f32,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "3")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchoolSearchReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CampusInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub toast: ::core::option::Option<SearchToast>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchoolSearchReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchChannel {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub more_button: ::core::option::Option<SearchTopicButton>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub channels: ::prost::alloc::vec::Vec<ChannelInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "3")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub total: i64,
    ///
    #[prost(bool, tag = "5")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchToast {
    ///
    #[prost(string, tag = "1")]
    pub desc_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc_text2: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTopic {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub more_button: ::core::option::Option<SearchTopicButton>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<SearchTopicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTopicButton {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub jump_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTopicItem {
    ///
    #[prost(int64, tag = "1")]
    pub topic_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub topic_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "5")]
    pub is_activity: bool,
    ///
    #[prost(string, tag = "6")]
    pub tag_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub desc_long: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub tag_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SectionNoteNavigationBar {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub right_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub jump_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SectionOpusCollection {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub all_collections: ::prost::alloc::vec::Vec<OpusCollectionWithCover>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectedClassificationAndSortType {
    ///
    #[prost(string, tag = "1")]
    pub chosen_classification_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub chosen_sort_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetDecisionReq {
    ///
    #[prost(int32, tag = "1")]
    pub result: i32,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRecentCampusReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "3")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareChannel {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub channel: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub reserve: ::core::option::Option<ShareReserve>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReserve {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub qr_code_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub qr_code_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub qr_code_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub user_info: ::core::option::Option<AdditionUserInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignResourcesReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub to_be_signed_res: ::prost::alloc::vec::Vec<ProtectedStaticResource>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignResourcesResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub signed_res: ::prost::alloc::vec::Vec<SignedStaticResource>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedStaticResource {
    ///
    #[prost(string, tag = "1")]
    pub signed_res_url: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_succeed: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SortType {
    ///
    #[prost(int32, tag = "1")]
    pub sort_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub sort_type_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoryArchive {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub dimension: ::core::option::Option<Dimension>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoryItem {
    ///
    #[prost(message, optional, tag = "1")]
    pub author: ::core::option::Option<UserInfo>,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub status: i64,
    ///
    #[prost(enumeration = "RcmdType", tag = "4")]
    pub r#type: i32,
    ///
    #[prost(oneof = "story_item::RcmdItem", tags = "5")]
    pub rcmd_item: ::core::option::Option<story_item::RcmdItem>,
}
/// Nested message and enum types in `StoryItem`.
pub mod story_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RcmdItem {
        ///
        #[prost(message, tag = "5")]
        StoryArchive(super::StoryArchive),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeButton {
    ///
    #[prost(string, tag = "1")]
    pub subscription_identifier: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_subscribed: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub subscribed_style: ::core::option::Option<ButtonWithSubscribeParam>,
    ///
    #[prost(message, optional, tag = "4")]
    pub not_subscribed_style: ::core::option::Option<ButtonWithSubscribeParam>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCampusReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub campus_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "3")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionClickReq {
    ///
    #[prost(string, tag = "1")]
    pub subscribe_param: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionClickResp {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextNode {
    ///
    #[prost(enumeration = "text_node::TextNodeType", tag = "1")]
    pub node_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub raw_text: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "text_node::Text", tags = "3, 4, 5, 6")]
    pub text: ::core::option::Option<text_node::Text>,
}
/// Nested message and enum types in `TextNode`.
pub mod text_node {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TextNodeType {
        ///
        InvalidTextNodeType = 0,
        ///
        Words = 1,
        ///
        Emote = 2,
        ///
        AtTextNodeType = 3,
        ///
        BizLink = 4,
        ///
        Formula = 5,
    }
    impl TextNodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InvalidTextNodeType => "INVALID_TextNodeType",
                Self::Words => "WORDS",
                Self::Emote => "EMOTE",
                Self::AtTextNodeType => "AT_TextNodeType",
                Self::BizLink => "BIZ_LINK",
                Self::Formula => "FORMULA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_TextNodeType" => Some(Self::InvalidTextNodeType),
                "WORDS" => Some(Self::Words),
                "EMOTE" => Some(Self::Emote),
                "AT_TextNodeType" => Some(Self::AtTextNodeType),
                "BIZ_LINK" => Some(Self::BizLink),
                "FORMULA" => Some(Self::Formula),
                _ => None,
            }
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Text {
        ///
        #[prost(message, tag = "3")]
        Word(super::WordNode),
        ///
        #[prost(message, tag = "4")]
        Emote(super::EmoteNode),
        ///
        #[prost(message, tag = "5")]
        Link(super::LinkNode),
        ///
        #[prost(message, tag = "6")]
        Formula(super::FormulaNode),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextParagraph {
    ///
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<TextNode>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextWithPriority {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub priority: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointAttention {
    ///
    #[prost(string, tag = "1")]
    pub attention_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub attention_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub not_attention_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub not_attention_text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ThreePointAttentionStatus", tag = "5")]
    pub status: i32,
    ///
    #[prost(string, tag = "6")]
    pub subscribe_oid: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointAutoPlay {
    ///
    #[prost(string, tag = "1")]
    pub open_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub open_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub close_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub close_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub open_text_v2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub close_text_v2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub only_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub only_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub open_icon_v2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub close_icon_v2: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointComment {
    ///
    #[prost(message, optional, tag = "1")]
    pub up_selection: ::core::option::Option<CommentDetail>,
    ///
    #[prost(message, optional, tag = "2")]
    pub up_close: ::core::option::Option<CommentDetail>,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointDefault {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub toast: ::core::option::Option<ThreePointDefaultToast>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointDefaultToast {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointDislike {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub feedback_biz_value: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointDynCoin {
    ///
    #[prost(bool, tag = "1")]
    pub had_coin: bool,
    ///
    #[prost(int64, tag = "2")]
    pub coin_num: i64,
    ///
    #[prost(string, tag = "3")]
    pub coin_business: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub oid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointDynEdit {
    ///
    #[prost(int64, tag = "1")]
    pub dyn_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub origin_id: i64,
    ///
    #[prost(bool, tag = "3")]
    pub is_origin_deleted: bool,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointFavorite {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub id: i64,
    ///
    #[prost(bool, tag = "4")]
    pub is_favourite: bool,
    ///
    #[prost(string, tag = "5")]
    pub cancel_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cancel_title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointHide {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub interactive: ::core::option::Option<ThreePointHideInteractive>,
    ///
    #[prost(int64, tag = "4")]
    pub blook_fid: i64,
    ///
    #[prost(string, tag = "5")]
    pub blook_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointHideInteractive {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub confirm: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cancel: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub toast: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointItem {
    ///
    #[prost(enumeration = "ThreePointType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(
        oneof = "three_point_item::Item",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"
    )]
    pub item: ::core::option::Option<three_point_item::Item>,
}
/// Nested message and enum types in `ThreePointItem`.
pub mod three_point_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        Default(super::ThreePointDefault),
        ///
        #[prost(message, tag = "3")]
        AutoPlayer(super::ThreePointAutoPlay),
        ///
        #[prost(message, tag = "4")]
        Share(super::ThreePointShare),
        ///
        #[prost(message, tag = "5")]
        Attention(super::ThreePointAttention),
        ///
        #[prost(message, tag = "6")]
        Wait(super::ThreePointWait),
        ///
        #[prost(message, tag = "7")]
        Dislike(super::ThreePointDislike),
        ///
        #[prost(message, tag = "8")]
        Favorite(super::ThreePointFavorite),
        ///
        #[prost(message, tag = "9")]
        Top(super::ThreePointTop),
        ///
        #[prost(message, tag = "10")]
        Comment(super::ThreePointComment),
        ///
        #[prost(message, tag = "11")]
        Hide(super::ThreePointHide),
        ///
        #[prost(message, tag = "12")]
        TopicIrrelevant(super::ThreePointTopicIrrelevant),
        ///
        #[prost(message, tag = "13")]
        DynEdit(super::ThreePointDynEdit),
        ///
        #[prost(message, tag = "14")]
        Coin(super::ThreePointDynCoin),
        ///
        #[prost(message, tag = "15")]
        VisibilityChange(super::ThreePointVisibilityChange),
        ///
        #[prost(message, tag = "16")]
        TopicTop(super::ThreePointTopicTop),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointShare {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub channel: ::prost::alloc::vec::Vec<ThreePointShareChannel>,
    ///
    #[prost(string, tag = "4")]
    pub channel_name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub reserve: ::core::option::Option<ShareReserve>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointShareChannel {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointTop {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "TopType", tag = "3")]
    pub r#type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointTopicIrrelevant {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub topic_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub res_id: i64,
    ///
    #[prost(int64, tag = "6")]
    pub res_type: i64,
    ///
    #[prost(string, tag = "7")]
    pub reason: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointTopicTop {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "TopType", tag = "3")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "4")]
    pub topic_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointVisibilityChange {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub item_list: ::prost::alloc::vec::Vec<ThreePointVisibilityChangeItem>,
    ///
    #[prost(string, tag = "4")]
    pub obj_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointVisibilityChangeItem {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub is_selected: bool,
    ///
    #[prost(string, tag = "5")]
    pub visibility_change_action_unselected: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreePointWait {
    ///
    #[prost(string, tag = "1")]
    pub addition_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub addition_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub no_addition_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub no_addition_text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopAdditionUp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub up: ::prost::alloc::vec::Vec<AdditionUp>,
    ///
    #[prost(int32, tag = "2")]
    pub has_fold: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicButton {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub jump_uri: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub red_dot: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicItem {
    ///
    #[prost(int64, tag = "1")]
    pub topic_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub topic_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub desc2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub rcmd_desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub button: ::core::option::Option<IconButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicList {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub topic_list_item: ::prost::alloc::vec::Vec<TopicListItem>,
    ///
    #[prost(message, optional, tag = "3")]
    pub act_button: ::core::option::Option<TopicButton>,
    ///
    #[prost(message, optional, tag = "4")]
    pub more_button: ::core::option::Option<TopicButton>,
    ///
    #[prost(string, tag = "5")]
    pub server_info: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub exp_style: i32,
    ///
    #[prost(string, tag = "8")]
    pub title_icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub hint_message: ::core::option::Option<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicListItem {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub topic_id: i64,
    ///
    #[prost(string, tag = "4")]
    pub topic_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub pos: i64,
    ///
    #[prost(string, tag = "7")]
    pub server_info: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub head_icon_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub up_mid: i64,
    ///
    #[prost(string, tag = "10")]
    pub tail_icon_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub extension: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "12")]
    pub position: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicListReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<TopicItem>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub create_topic_btn: ::core::option::Option<IconButton>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicListReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "3")]
    pub from_type: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopicMergedResource {
    ///
    #[prost(int32, tag = "1")]
    pub merge_type: i32,
    ///
    #[prost(int32, tag = "2")]
    pub merged_res_cnt: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicRcmdCard {
    ///
    #[prost(int64, tag = "1")]
    pub topic_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub topic_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub button: ::core::option::Option<CampusLabel>,
    ///
    #[prost(string, tag = "5")]
    pub desc1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub desc2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub update_desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicSquareInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub button: ::core::option::Option<CampusLabel>,
    ///
    #[prost(message, optional, tag = "3")]
    pub rcmd: ::core::option::Option<TopicRcmdCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicSquareReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<TopicSquareInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopicSquareReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(enumeration = "CampusReqFromType", tag = "2")]
    pub from_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unfollow {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<UnfollowUserItem>,
    ///
    #[prost(string, tag = "3")]
    pub track_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnfollowMatchReq {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnfollowUserItem {
    ///
    #[prost(bool, tag = "1")]
    pub has_update: bool,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub uid: i64,
    ///
    #[prost(int32, tag = "5")]
    pub pos: i32,
    ///
    #[prost(enumeration = "LiveState", tag = "6")]
    pub live_state: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub official: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "8")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(string, tag = "9")]
    pub sign: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub button: ::core::option::Option<AdditionalButton>,
    ///
    #[prost(string, tag = "12")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpListItem {
    ///
    #[prost(bool, tag = "1")]
    pub has_update: bool,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub uid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub pos: i64,
    ///
    #[prost(enumeration = "UserItemType", tag = "6")]
    pub user_item_type: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub display_style_day: ::core::option::Option<UserItemStyle>,
    ///
    #[prost(message, optional, tag = "8")]
    pub display_style_night: ::core::option::Option<UserItemStyle>,
    ///
    #[prost(int64, tag = "9")]
    pub style_id: i64,
    ///
    #[prost(enumeration = "LiveState", tag = "10")]
    pub live_state: i32,
    ///
    #[prost(bool, tag = "11")]
    pub separator: bool,
    ///
    #[prost(string, tag = "12")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "13")]
    pub is_recall: bool,
    ///
    #[prost(message, optional, tag = "14")]
    pub update_icon: ::core::option::Option<IconBadge>,
    ///
    #[prost(string, tag = "15")]
    pub live_rcmd_reason: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub live_cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "17")]
    pub personal_extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "18")]
    pub update_icon_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "19")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "20")]
    pub text_badge: ::core::option::Option<UpListTextBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpListMoreLabel {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpListTextBadge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTabSettingReq {
    ///
    #[prost(enumeration = "HomePageTabSttingStatus", tag = "1")]
    pub status: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub official: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "5")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(message, optional, tag = "6")]
    pub live: ::core::option::Option<LiveInfo>,
    ///
    #[prost(string, tag = "7")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub pendant: ::core::option::Option<UserPendant>,
    ///
    #[prost(message, optional, tag = "9")]
    pub nameplate: ::core::option::Option<Nameplate>,
    ///
    #[prost(int32, tag = "10")]
    pub level: i32,
    ///
    #[prost(string, tag = "11")]
    pub sign: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "12")]
    pub face_nft: i32,
    ///
    #[prost(int32, tag = "13")]
    pub face_nft_new: i32,
    ///
    #[prost(message, optional, tag = "14")]
    pub nft_info: ::core::option::Option<NftInfo>,
    ///
    #[prost(int32, tag = "15")]
    pub is_senior_member: i32,
    ///
    #[prost(message, optional, tag = "16")]
    pub avatar: ::core::option::Option<
        super::super::super::dagw::component::avatar::v1::AvatarItem,
    >,
    ///
    #[prost(message, optional, tag = "17")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserItemStyle {
    ///
    #[prost(string, tag = "1")]
    pub rect_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub rect_text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub rect_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub rect_bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub outer_animation: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPendant {
    ///
    #[prost(int64, tag = "1")]
    pub pid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub expire: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoBadge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub border_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub border_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bg_style: i32,
    ///
    #[prost(int32, tag = "9")]
    pub bg_alpha: i32,
    ///
    #[prost(int32, tag = "10")]
    pub bg_alpha_night: i32,
    ///
    #[prost(string, tag = "11")]
    pub head_icon: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "IconResLocal", tag = "12")]
    pub head_icon_local: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipInfo {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "2")]
    pub status: i32,
    ///
    #[prost(int64, tag = "3")]
    pub due_date: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub label: ::core::option::Option<VipLabel>,
    ///
    #[prost(int32, tag = "5")]
    pub theme_type: i32,
    ///
    #[prost(int32, tag = "6")]
    pub avatar_subscript: i32,
    ///
    #[prost(string, tag = "7")]
    pub nickname_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipLabel {
    ///
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub label_theme: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WfItemDefault {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub bottom_left1: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(message, optional, tag = "4")]
    pub bottom_left2: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(message, optional, tag = "5")]
    pub bottom_right1: ::core::option::Option<CoverIconWithText>,
    ///
    #[prost(string, tag = "6")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub rcmd_reason: ::core::option::Option<RcmdReason>,
    ///
    #[prost(map = "string, string", tag = "8")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaterFlowRcmdReq {
    ///
    #[prost(int64, tag = "1")]
    pub campus_id: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<super::super::super::pagination::FeedPagination>,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(enumeration = "CampusRcmdReqFrom", tag = "4")]
    pub from: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaterFlowRcmdResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CampusWaterFlowItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub offset: ::core::option::Option<
        super::super::super::pagination::FeedPaginationReply,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Weight {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<WeightItem>,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightButton {
    ///
    #[prost(string, tag = "1")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightDislike {
    ///
    #[prost(string, tag = "1")]
    pub feed_back_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub feed_back_biz_value: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightItem {
    ///
    #[prost(enumeration = "WeightType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(oneof = "weight_item::Item", tags = "2, 3")]
    pub item: ::core::option::Option<weight_item::Item>,
}
/// Nested message and enum types in `WeightItem`.
pub mod weight_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        Button(super::WeightButton),
        ///
        #[prost(message, tag = "3")]
        Dislike(super::WeightDislike),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WordNode {
    ///
    #[prost(string, tag = "1")]
    pub words: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "2")]
    pub font_size: f64,
    ///
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Colors>,
    ///
    #[prost(message, optional, tag = "4")]
    pub style: ::core::option::Option<word_node::WordNodeStyle>,
    ///
    #[prost(message, optional, tag = "5")]
    pub underline_style: ::core::option::Option<word_node::UnderlineStyle>,
    ///
    #[prost(string, tag = "7")]
    pub font_level: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WordNode`.
pub mod word_node {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UnderlineStyle {
        ///
        #[prost(double, tag = "1")]
        pub underline_width: f64,
        ///
        #[prost(message, optional, tag = "2")]
        pub underline_color: ::core::option::Option<super::Colors>,
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct WordNodeStyle {
        ///
        #[prost(bool, tag = "1")]
        pub bold: bool,
        ///
        #[prost(bool, tag = "2")]
        pub italic: bool,
        ///
        #[prost(bool, tag = "3")]
        pub strikethrough: bool,
        ///
        #[prost(bool, tag = "4")]
        pub underline: bool,
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddButtonBgStyle {
    ///
    Fill = 0,
    ///
    Stroke = 1,
    ///
    Gray = 2,
}
impl AddButtonBgStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Fill => "fill",
            Self::Stroke => "stroke",
            Self::Gray => "gray",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "fill" => Some(Self::Fill),
            "stroke" => Some(Self::Stroke),
            "gray" => Some(Self::Gray),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddButtonType {
    ///
    BtNone = 0,
    ///
    BtJump = 1,
    ///
    BtButton = 2,
}
impl AddButtonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BtNone => "bt_none",
            Self::BtJump => "bt_jump",
            Self::BtButton => "bt_button",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bt_none" => Some(Self::BtNone),
            "bt_jump" => Some(Self::BtJump),
            "bt_button" => Some(Self::BtButton),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionVoteState {
    ///
    None = 0,
    ///
    Open = 1,
    ///
    Close = 2,
}
impl AdditionVoteState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "addition_vote_state_none",
            Self::Open => "addition_vote_state_open",
            Self::Close => "addition_vote_state_close",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "addition_vote_state_none" => Some(Self::None),
            "addition_vote_state_open" => Some(Self::Open),
            "addition_vote_state_close" => Some(Self::Close),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionVoteType {
    ///
    None = 0,
    ///
    Word = 1,
    ///
    Pic = 2,
    ///
    Default = 3,
}
impl AdditionVoteType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "addition_vote_type_none",
            Self::Word => "addition_vote_type_word",
            Self::Pic => "addition_vote_type_pic",
            Self::Default => "addition_vote_type_default",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "addition_vote_type_none" => Some(Self::None),
            "addition_vote_type_word" => Some(Self::Word),
            "addition_vote_type_pic" => Some(Self::Pic),
            "addition_vote_type_default" => Some(Self::Default),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionalButtonClickType {
    ///
    ClickNone = 0,
    ///
    ClickUp = 1,
}
impl AdditionalButtonClickType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ClickNone => "click_none",
            Self::ClickUp => "click_up",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "click_none" => Some(Self::ClickNone),
            "click_up" => Some(Self::ClickUp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionalButtonStatus {
    ///
    None = 0,
    ///
    Uncheck = 1,
    ///
    Check = 2,
}
impl AdditionalButtonStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "none",
            Self::Uncheck => "uncheck",
            Self::Check => "check",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "none" => Some(Self::None),
            "uncheck" => Some(Self::Uncheck),
            "check" => Some(Self::Check),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionalShareShowType {
    ///
    StNone = 0,
    ///
    StShow = 1,
}
impl AdditionalShareShowType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StNone => "st_none",
            Self::StShow => "st_show",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "st_none" => Some(Self::StNone),
            "st_show" => Some(Self::StShow),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionalType {
    ///
    AdditionalNone = 0,
    ///
    Pgc = 1,
    ///
    Goods = 2,
    ///
    Vote = 3,
    ///
    Common = 4,
    ///
    Esport = 5,
    ///
    UpRcmd = 6,
    ///
    Ugc = 7,
    ///
    UpReservation = 8,
    ///
    Article = 9,
    ///
    LiveRoom = 10,
    ///
    Music = 11,
}
impl AdditionalType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AdditionalNone => "additional_none",
            Self::Pgc => "additional_type_pgc",
            Self::Goods => "additional_type_goods",
            Self::Vote => "additional_type_vote",
            Self::Common => "additional_type_common",
            Self::Esport => "additional_type_esport",
            Self::UpRcmd => "additional_type_up_rcmd",
            Self::Ugc => "additional_type_ugc",
            Self::UpReservation => "additional_type_up_reservation",
            Self::Article => "additional_type_article",
            Self::LiveRoom => "additional_type_live_room",
            Self::Music => "additional_type_music",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "additional_none" => Some(Self::AdditionalNone),
            "additional_type_pgc" => Some(Self::Pgc),
            "additional_type_goods" => Some(Self::Goods),
            "additional_type_vote" => Some(Self::Vote),
            "additional_type_common" => Some(Self::Common),
            "additional_type_esport" => Some(Self::Esport),
            "additional_type_up_rcmd" => Some(Self::UpRcmd),
            "additional_type_ugc" => Some(Self::Ugc),
            "additional_type_up_reservation" => Some(Self::UpReservation),
            "additional_type_article" => Some(Self::Article),
            "additional_type_live_room" => Some(Self::LiveRoom),
            "additional_type_music" => Some(Self::Music),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthorBadgeStyle {
    ///
    Invalid = 0,
    ///
    GrayOutline = 1,
}
impl AuthorBadgeStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "AUTHOR_BADGE_STYLE_INVALID",
            Self::GrayOutline => "AUTHOR_BADGE_STYLE_GRAY_OUTLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTHOR_BADGE_STYLE_INVALID" => Some(Self::Invalid),
            "AUTHOR_BADGE_STYLE_GRAY_OUTLINE" => Some(Self::GrayOutline),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusEntryType {
    ///
    None = 0,
    ///
    EntryDynamic = 1,
    ///
    EntryHome = 2,
}
impl CampusEntryType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::EntryDynamic => "ENTRY_DYNAMIC",
            Self::EntryHome => "ENTRY_HOME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "ENTRY_DYNAMIC" => Some(Self::EntryDynamic),
            "ENTRY_HOME" => Some(Self::EntryHome),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusHomePageType {
    ///
    PageMajor = 0,
    ///
    PageSubordinate = 1,
    ///
    PageMajorDetail = 2,
}
impl CampusHomePageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PageMajor => "PAGE_MAJOR",
            Self::PageSubordinate => "PAGE_SUBORDINATE",
            Self::PageMajorDetail => "PAGE_MAJOR_DETAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAGE_MAJOR" => Some(Self::PageMajor),
            "PAGE_SUBORDINATE" => Some(Self::PageSubordinate),
            "PAGE_MAJOR_DETAIL" => Some(Self::PageMajorDetail),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusMngAuditStatus {
    ///
    CampusMngAuditNone = 0,
    ///
    CampusMngAuditInProcess = 1,
    ///
    CampusMngAuditFailed = 2,
}
impl CampusMngAuditStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CampusMngAuditNone => "campus_mng_audit_none",
            Self::CampusMngAuditInProcess => "campus_mng_audit_in_process",
            Self::CampusMngAuditFailed => "campus_mng_audit_failed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "campus_mng_audit_none" => Some(Self::CampusMngAuditNone),
            "campus_mng_audit_in_process" => Some(Self::CampusMngAuditInProcess),
            "campus_mng_audit_failed" => Some(Self::CampusMngAuditFailed),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusMngItemType {
    ///
    CampusMngNone = 0,
    ///
    CampusMngBasicInfo = 1,
    ///
    CampusMngBadge = 2,
    ///
    CampusMngSlogan = 3,
    ///
    CampusMngQuiz = 4,
}
impl CampusMngItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CampusMngNone => "campus_mng_none",
            Self::CampusMngBasicInfo => "campus_mng_basic_info",
            Self::CampusMngBadge => "campus_mng_badge",
            Self::CampusMngSlogan => "campus_mng_slogan",
            Self::CampusMngQuiz => "campus_mng_quiz",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "campus_mng_none" => Some(Self::CampusMngNone),
            "campus_mng_basic_info" => Some(Self::CampusMngBasicInfo),
            "campus_mng_badge" => Some(Self::CampusMngBadge),
            "campus_mng_slogan" => Some(Self::CampusMngSlogan),
            "campus_mng_quiz" => Some(Self::CampusMngQuiz),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusMngQuizAction {
    ///
    CampusMngQuizActList = 0,
    ///
    CampusMngQuizActAdd = 1,
    ///
    CampusMngQuizActDel = 2,
}
impl CampusMngQuizAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CampusMngQuizActList => "campus_mng_quiz_act_list",
            Self::CampusMngQuizActAdd => "campus_mng_quiz_act_add",
            Self::CampusMngQuizActDel => "campus_mng_quiz_act_del",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "campus_mng_quiz_act_list" => Some(Self::CampusMngQuizActList),
            "campus_mng_quiz_act_add" => Some(Self::CampusMngQuizActAdd),
            "campus_mng_quiz_act_del" => Some(Self::CampusMngQuizActDel),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusOnlineStatus {
    ///
    CampusOnlineOffline = 0,
    ///
    CampusOnlineOnline = 1,
}
impl CampusOnlineStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CampusOnlineOffline => "campus_online_offline",
            Self::CampusOnlineOnline => "campus_online_online",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "campus_online_offline" => Some(Self::CampusOnlineOffline),
            "campus_online_online" => Some(Self::CampusOnlineOnline),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusRcmdReqFrom {
    ///
    CampusRcmdFromUnknown = 0,
    ///
    CampusRcmdFromHomeUnOpen = 1,
    ///
    CampusRcmdFromVisitOther = 2,
    ///
    CampusRcmdFromHomeMoment = 3,
    ///
    CampusRcmdFromDynMoment = 4,
    ///
    CampusRcmdFromPageSubordinateMoment = 5,
}
impl CampusRcmdReqFrom {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CampusRcmdFromUnknown => "CAMPUS_RCMD_FROM_UNKNOWN",
            Self::CampusRcmdFromHomeUnOpen => "CAMPUS_RCMD_FROM_HOME_UN_OPEN",
            Self::CampusRcmdFromVisitOther => "CAMPUS_RCMD_FROM_VISIT_OTHER",
            Self::CampusRcmdFromHomeMoment => "CAMPUS_RCMD_FROM_HOME_MOMENT",
            Self::CampusRcmdFromDynMoment => "CAMPUS_RCMD_FROM_DYN_MOMENT",
            Self::CampusRcmdFromPageSubordinateMoment => {
                "CAMPUS_RCMD_FROM_PAGE_SUBORDINATE_MOMENT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAMPUS_RCMD_FROM_UNKNOWN" => Some(Self::CampusRcmdFromUnknown),
            "CAMPUS_RCMD_FROM_HOME_UN_OPEN" => Some(Self::CampusRcmdFromHomeUnOpen),
            "CAMPUS_RCMD_FROM_VISIT_OTHER" => Some(Self::CampusRcmdFromVisitOther),
            "CAMPUS_RCMD_FROM_HOME_MOMENT" => Some(Self::CampusRcmdFromHomeMoment),
            "CAMPUS_RCMD_FROM_DYN_MOMENT" => Some(Self::CampusRcmdFromDynMoment),
            "CAMPUS_RCMD_FROM_PAGE_SUBORDINATE_MOMENT" => {
                Some(Self::CampusRcmdFromPageSubordinateMoment)
            }
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusReqFromType {
    ///
    Dynamic = 0,
    ///
    Home = 1,
}
impl CampusReqFromType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Dynamic => "DYNAMIC",
            Self::Home => "HOME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DYNAMIC" => Some(Self::Dynamic),
            "HOME" => Some(Self::Home),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CampusTabType {
    ///
    CampusNone = 0,
    ///
    CampusSchool = 1,
    ///
    CampusDynamic = 2,
    ///
    CampusAccount = 3,
    ///
    CampusBillboard = 4,
    ///
    CampusTopic = 5,
    ///
    CampuesOther = 6,
}
impl CampusTabType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CampusNone => "campus_none",
            Self::CampusSchool => "campus_school",
            Self::CampusDynamic => "campus_dynamic",
            Self::CampusAccount => "campus_account",
            Self::CampusBillboard => "campus_billboard",
            Self::CampusTopic => "campus_topic",
            Self::CampuesOther => "campues_other",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "campus_none" => Some(Self::CampusNone),
            "campus_school" => Some(Self::CampusSchool),
            "campus_dynamic" => Some(Self::CampusDynamic),
            "campus_account" => Some(Self::CampusAccount),
            "campus_billboard" => Some(Self::CampusBillboard),
            "campus_topic" => Some(Self::CampusTopic),
            "campues_other" => Some(Self::CampuesOther),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoverIcon {
    ///
    None = 0,
    ///
    Play = 1,
    ///
    Danmaku = 2,
    ///
    Up = 3,
    ///
    Vt = 4,
    ///
    ViewCnt = 5,
    ///
    ThumbUp = 6,
    ///
    Reply = 7,
    ///
    Fav = 8,
    ///
    Coin = 9,
    ///
    SelfSeen = 10,
}
impl CoverIcon {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "cover_icon_none",
            Self::Play => "cover_icon_play",
            Self::Danmaku => "cover_icon_danmaku",
            Self::Up => "cover_icon_up",
            Self::Vt => "cover_icon_vt",
            Self::ViewCnt => "cover_icon_view_cnt",
            Self::ThumbUp => "cover_icon_thumb_up",
            Self::Reply => "cover_icon_reply",
            Self::Fav => "cover_icon_fav",
            Self::Coin => "cover_icon_coin",
            Self::SelfSeen => "cover_icon_self_seen",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "cover_icon_none" => Some(Self::None),
            "cover_icon_play" => Some(Self::Play),
            "cover_icon_danmaku" => Some(Self::Danmaku),
            "cover_icon_up" => Some(Self::Up),
            "cover_icon_vt" => Some(Self::Vt),
            "cover_icon_view_cnt" => Some(Self::ViewCnt),
            "cover_icon_thumb_up" => Some(Self::ThumbUp),
            "cover_icon_reply" => Some(Self::Reply),
            "cover_icon_fav" => Some(Self::Fav),
            "cover_icon_coin" => Some(Self::Coin),
            "cover_icon_self_seen" => Some(Self::SelfSeen),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DescType {
    ///
    None = 0,
    ///
    Text = 1,
    ///
    Aite = 2,
    ///
    Lottery = 3,
    ///
    Vote = 4,
    ///
    Topic = 5,
    ///
    Goods = 6,
    ///
    Bv = 7,
    ///
    Av = 8,
    ///
    Emoji = 9,
    ///
    User = 10,
    ///
    Cv = 11,
    ///
    Vc = 12,
    ///
    Web = 13,
    ///
    Taobao = 14,
    ///
    Mail = 15,
    ///
    OgvSeason = 16,
    ///
    OgvEp = 17,
    ///
    SearchWord = 18,
}
impl DescType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "desc_type_none",
            Self::Text => "desc_type_text",
            Self::Aite => "desc_type_aite",
            Self::Lottery => "desc_type_lottery",
            Self::Vote => "desc_type_vote",
            Self::Topic => "desc_type_topic",
            Self::Goods => "desc_type_goods",
            Self::Bv => "desc_type_bv",
            Self::Av => "desc_type_av",
            Self::Emoji => "desc_type_emoji",
            Self::User => "desc_type_user",
            Self::Cv => "desc_type_cv",
            Self::Vc => "desc_type_vc",
            Self::Web => "desc_type_web",
            Self::Taobao => "desc_type_taobao",
            Self::Mail => "desc_type_mail",
            Self::OgvSeason => "desc_type_ogv_season",
            Self::OgvEp => "desc_type_ogv_ep",
            Self::SearchWord => "desc_type_search_word",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "desc_type_none" => Some(Self::None),
            "desc_type_text" => Some(Self::Text),
            "desc_type_aite" => Some(Self::Aite),
            "desc_type_lottery" => Some(Self::Lottery),
            "desc_type_vote" => Some(Self::Vote),
            "desc_type_topic" => Some(Self::Topic),
            "desc_type_goods" => Some(Self::Goods),
            "desc_type_bv" => Some(Self::Bv),
            "desc_type_av" => Some(Self::Av),
            "desc_type_emoji" => Some(Self::Emoji),
            "desc_type_user" => Some(Self::User),
            "desc_type_cv" => Some(Self::Cv),
            "desc_type_vc" => Some(Self::Vc),
            "desc_type_web" => Some(Self::Web),
            "desc_type_taobao" => Some(Self::Taobao),
            "desc_type_mail" => Some(Self::Mail),
            "desc_type_ogv_season" => Some(Self::OgvSeason),
            "desc_type_ogv_ep" => Some(Self::OgvEp),
            "desc_type_search_word" => Some(Self::SearchWord),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DisableState {
    ///
    Highlight = 0,
    ///
    Gary = 1,
}
impl DisableState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Highlight => "highlight",
            Self::Gary => "gary",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "highlight" => Some(Self::Highlight),
            "gary" => Some(Self::Gary),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DynExtendType {
    ///
    DynExtTypeNone = 0,
    ///
    DynExtTypeTopic = 1,
    ///
    DynExtTypeLbs = 2,
    ///
    DynExtTypeHot = 3,
    ///
    DynExtTypeGame = 4,
    ///
    DynExtTypeCommon = 5,
    ///
    DynExtTypeBiliCut = 6,
    ///
    DynExtTypeOgv = 7,
    ///
    DynExtTypeAutoOgv = 8,
    ///
    DynExtTypeArticleTag = 9,
}
impl DynExtendType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DynExtTypeNone => "dyn_ext_type_none",
            Self::DynExtTypeTopic => "dyn_ext_type_topic",
            Self::DynExtTypeLbs => "dyn_ext_type_lbs",
            Self::DynExtTypeHot => "dyn_ext_type_hot",
            Self::DynExtTypeGame => "dyn_ext_type_game",
            Self::DynExtTypeCommon => "dyn_ext_type_common",
            Self::DynExtTypeBiliCut => "dyn_ext_type_biliCut",
            Self::DynExtTypeOgv => "dyn_ext_type_ogv",
            Self::DynExtTypeAutoOgv => "dyn_ext_type_auto_ogv",
            Self::DynExtTypeArticleTag => "dyn_ext_type_article_tag",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "dyn_ext_type_none" => Some(Self::DynExtTypeNone),
            "dyn_ext_type_topic" => Some(Self::DynExtTypeTopic),
            "dyn_ext_type_lbs" => Some(Self::DynExtTypeLbs),
            "dyn_ext_type_hot" => Some(Self::DynExtTypeHot),
            "dyn_ext_type_game" => Some(Self::DynExtTypeGame),
            "dyn_ext_type_common" => Some(Self::DynExtTypeCommon),
            "dyn_ext_type_biliCut" => Some(Self::DynExtTypeBiliCut),
            "dyn_ext_type_ogv" => Some(Self::DynExtTypeOgv),
            "dyn_ext_type_auto_ogv" => Some(Self::DynExtTypeAutoOgv),
            "dyn_ext_type_article_tag" => Some(Self::DynExtTypeArticleTag),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DynModuleType {
    ///
    ModuleNone = 0,
    ///
    ModuleAuthor = 1,
    ///
    ModuleDispute = 2,
    ///
    ModuleDesc = 3,
    ///
    ModuleDynamic = 4,
    ///
    ModuleForward = 5,
    ///
    ModuleLikeUser = 6,
    ///
    ModuleExtend = 7,
    ///
    ModuleAdditional = 8,
    ///
    ModuleStat = 9,
    ///
    ModuleFold = 10,
    ///
    ModuleComment = 11,
    ///
    ModuleInteraction = 12,
    ///
    ModuleAuthorForward = 13,
    ///
    ModuleAd = 14,
    ///
    ModuleBanner = 15,
    ///
    ModuleItemNull = 16,
    ///
    ModuleShareInfo = 17,
    ///
    ModuleRecommend = 18,
    ///
    ModuleStatForward = 19,
    ///
    ModuleTop = 20,
    ///
    ModuleBottom = 21,
    ///
    ModuleStory = 22,
    ///
    ModuleTopic = 23,
    ///
    ModuleTopicDetailsExt = 24,
    ///
    ModuleTopTag = 25,
    ///
    ModuleTopicBrief = 26,
    ///
    ModuleTitle = 27,
    ///
    ModuleButton = 28,
    ///
    ModuleNotice = 29,
    ///
    ModuleOpusSummary = 30,
    ///
    ModuleCopyright = 31,
    ///
    ModuleParagraph = 32,
    ///
    ModuleBlocked = 33,
    ///
    ModuleTextNotice = 34,
    ///
    ModuleOpusCollection = 35,
    ///
    ModuleOnetimeNotice = 36,
    ///
    ModuleSneakingAd = 37,
    ///
    ModuleMangaHorizontalPagePicContent = 38,
    ///
    ModuleMangaVerticalSlidePicContent = 39,
    ///
    ModuleMangaCoverPicContent = 40,
    ///
    ModuleAuthorForSubscribe = 41,
    ///
    ModuleAuthorSlim = 42,
    ///
    ModuleMangaCollection = 43,
    ///
    ModuleCooperation = 44,
}
impl DynModuleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ModuleNone => "module_none",
            Self::ModuleAuthor => "module_author",
            Self::ModuleDispute => "module_dispute",
            Self::ModuleDesc => "module_desc",
            Self::ModuleDynamic => "module_dynamic",
            Self::ModuleForward => "module_forward",
            Self::ModuleLikeUser => "module_likeUser",
            Self::ModuleExtend => "module_extend",
            Self::ModuleAdditional => "module_additional",
            Self::ModuleStat => "module_stat",
            Self::ModuleFold => "module_fold",
            Self::ModuleComment => "module_comment",
            Self::ModuleInteraction => "module_interaction",
            Self::ModuleAuthorForward => "module_author_forward",
            Self::ModuleAd => "module_ad",
            Self::ModuleBanner => "module_banner",
            Self::ModuleItemNull => "module_item_null",
            Self::ModuleShareInfo => "module_share_info",
            Self::ModuleRecommend => "module_recommend",
            Self::ModuleStatForward => "module_stat_forward",
            Self::ModuleTop => "module_top",
            Self::ModuleBottom => "module_bottom",
            Self::ModuleStory => "module_story",
            Self::ModuleTopic => "module_topic",
            Self::ModuleTopicDetailsExt => "module_topic_details_ext",
            Self::ModuleTopTag => "module_top_tag",
            Self::ModuleTopicBrief => "module_topic_brief",
            Self::ModuleTitle => "module_title",
            Self::ModuleButton => "module_button",
            Self::ModuleNotice => "module_notice",
            Self::ModuleOpusSummary => "module_opus_summary",
            Self::ModuleCopyright => "module_copyright",
            Self::ModuleParagraph => "module_paragraph",
            Self::ModuleBlocked => "module_blocked",
            Self::ModuleTextNotice => "module_text_notice",
            Self::ModuleOpusCollection => "module_opus_collection",
            Self::ModuleOnetimeNotice => "module_onetime_notice",
            Self::ModuleSneakingAd => "module_sneaking_ad",
            Self::ModuleMangaHorizontalPagePicContent => {
                "module_manga_horizontal_page_pic_content"
            }
            Self::ModuleMangaVerticalSlidePicContent => {
                "module_manga_vertical_slide_pic_content"
            }
            Self::ModuleMangaCoverPicContent => "module_manga_cover_pic_content",
            Self::ModuleAuthorForSubscribe => "module_author_for_subscribe",
            Self::ModuleAuthorSlim => "module_author_slim",
            Self::ModuleMangaCollection => "module_manga_collection",
            Self::ModuleCooperation => "module_cooperation",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "module_none" => Some(Self::ModuleNone),
            "module_author" => Some(Self::ModuleAuthor),
            "module_dispute" => Some(Self::ModuleDispute),
            "module_desc" => Some(Self::ModuleDesc),
            "module_dynamic" => Some(Self::ModuleDynamic),
            "module_forward" => Some(Self::ModuleForward),
            "module_likeUser" => Some(Self::ModuleLikeUser),
            "module_extend" => Some(Self::ModuleExtend),
            "module_additional" => Some(Self::ModuleAdditional),
            "module_stat" => Some(Self::ModuleStat),
            "module_fold" => Some(Self::ModuleFold),
            "module_comment" => Some(Self::ModuleComment),
            "module_interaction" => Some(Self::ModuleInteraction),
            "module_author_forward" => Some(Self::ModuleAuthorForward),
            "module_ad" => Some(Self::ModuleAd),
            "module_banner" => Some(Self::ModuleBanner),
            "module_item_null" => Some(Self::ModuleItemNull),
            "module_share_info" => Some(Self::ModuleShareInfo),
            "module_recommend" => Some(Self::ModuleRecommend),
            "module_stat_forward" => Some(Self::ModuleStatForward),
            "module_top" => Some(Self::ModuleTop),
            "module_bottom" => Some(Self::ModuleBottom),
            "module_story" => Some(Self::ModuleStory),
            "module_topic" => Some(Self::ModuleTopic),
            "module_topic_details_ext" => Some(Self::ModuleTopicDetailsExt),
            "module_top_tag" => Some(Self::ModuleTopTag),
            "module_topic_brief" => Some(Self::ModuleTopicBrief),
            "module_title" => Some(Self::ModuleTitle),
            "module_button" => Some(Self::ModuleButton),
            "module_notice" => Some(Self::ModuleNotice),
            "module_opus_summary" => Some(Self::ModuleOpusSummary),
            "module_copyright" => Some(Self::ModuleCopyright),
            "module_paragraph" => Some(Self::ModuleParagraph),
            "module_blocked" => Some(Self::ModuleBlocked),
            "module_text_notice" => Some(Self::ModuleTextNotice),
            "module_opus_collection" => Some(Self::ModuleOpusCollection),
            "module_onetime_notice" => Some(Self::ModuleOnetimeNotice),
            "module_sneaking_ad" => Some(Self::ModuleSneakingAd),
            "module_manga_horizontal_page_pic_content" => {
                Some(Self::ModuleMangaHorizontalPagePicContent)
            }
            "module_manga_vertical_slide_pic_content" => {
                Some(Self::ModuleMangaVerticalSlidePicContent)
            }
            "module_manga_cover_pic_content" => Some(Self::ModuleMangaCoverPicContent),
            "module_author_for_subscribe" => Some(Self::ModuleAuthorForSubscribe),
            "module_author_slim" => Some(Self::ModuleAuthorSlim),
            "module_manga_collection" => Some(Self::ModuleMangaCollection),
            "module_cooperation" => Some(Self::ModuleCooperation),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DynVisibilityStatus {
    ///
    DynVisibilityPublic = 0,
    ///
    DynVisibilitySelfSeenOnly = 1,
}
impl DynVisibilityStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DynVisibilityPublic => "DYN_VISIBILITY_PUBLIC",
            Self::DynVisibilitySelfSeenOnly => "DYN_VISIBILITY_SELF_SEEN_ONLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DYN_VISIBILITY_PUBLIC" => Some(Self::DynVisibilityPublic),
            "DYN_VISIBILITY_SELF_SEEN_ONLY" => Some(Self::DynVisibilitySelfSeenOnly),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DynamicType {
    ///
    DynNone = 0,
    ///
    Forward = 1,
    ///
    Av = 2,
    ///
    Pgc = 3,
    ///
    Courses = 4,
    ///
    Fold = 5,
    ///
    Word = 6,
    ///
    Draw = 7,
    ///
    Article = 8,
    ///
    Music = 9,
    ///
    CommonSquare = 10,
    ///
    CommonVertical = 11,
    ///
    Live = 12,
    ///
    Medialist = 13,
    ///
    CoursesSeason = 14,
    ///
    Ad = 15,
    ///
    Applet = 16,
    ///
    Subscription = 17,
    ///
    LiveRcmd = 18,
    ///
    Banner = 19,
    ///
    UgcSeason = 20,
    ///
    SubscriptionNew = 21,
    ///
    Story = 22,
    ///
    TopicRcmd = 23,
    ///
    CourUp = 24,
    ///
    TopicSet = 25,
    ///
    Notice = 26,
    ///
    TextNotice = 27,
    ///
    OnetimeNotice = 28,
    ///
    MangaEp = 29,
}
impl DynamicType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DynNone => "dyn_none",
            Self::Forward => "forward",
            Self::Av => "av",
            Self::Pgc => "pgc",
            Self::Courses => "courses",
            Self::Fold => "fold",
            Self::Word => "word",
            Self::Draw => "draw",
            Self::Article => "article",
            Self::Music => "music",
            Self::CommonSquare => "common_square",
            Self::CommonVertical => "common_vertical",
            Self::Live => "live",
            Self::Medialist => "medialist",
            Self::CoursesSeason => "courses_season",
            Self::Ad => "ad",
            Self::Applet => "applet",
            Self::Subscription => "subscription",
            Self::LiveRcmd => "live_rcmd",
            Self::Banner => "banner",
            Self::UgcSeason => "ugc_season",
            Self::SubscriptionNew => "subscription_new",
            Self::Story => "story",
            Self::TopicRcmd => "topic_rcmd",
            Self::CourUp => "cour_up",
            Self::TopicSet => "topic_set",
            Self::Notice => "notice",
            Self::TextNotice => "text_notice",
            Self::OnetimeNotice => "onetime_notice",
            Self::MangaEp => "manga_ep",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "dyn_none" => Some(Self::DynNone),
            "forward" => Some(Self::Forward),
            "av" => Some(Self::Av),
            "pgc" => Some(Self::Pgc),
            "courses" => Some(Self::Courses),
            "fold" => Some(Self::Fold),
            "word" => Some(Self::Word),
            "draw" => Some(Self::Draw),
            "article" => Some(Self::Article),
            "music" => Some(Self::Music),
            "common_square" => Some(Self::CommonSquare),
            "common_vertical" => Some(Self::CommonVertical),
            "live" => Some(Self::Live),
            "medialist" => Some(Self::Medialist),
            "courses_season" => Some(Self::CoursesSeason),
            "ad" => Some(Self::Ad),
            "applet" => Some(Self::Applet),
            "subscription" => Some(Self::Subscription),
            "live_rcmd" => Some(Self::LiveRcmd),
            "banner" => Some(Self::Banner),
            "ugc_season" => Some(Self::UgcSeason),
            "subscription_new" => Some(Self::SubscriptionNew),
            "story" => Some(Self::Story),
            "topic_rcmd" => Some(Self::TopicRcmd),
            "cour_up" => Some(Self::CourUp),
            "topic_set" => Some(Self::TopicSet),
            "notice" => Some(Self::Notice),
            "text_notice" => Some(Self::TextNotice),
            "onetime_notice" => Some(Self::OnetimeNotice),
            "manga_ep" => Some(Self::MangaEp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmojiType {
    ///
    EmojiNone = 0,
    ///
    EmojiOld = 1,
    ///
    EmojiNew = 2,
    ///
    Vip = 3,
}
impl EmojiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmojiNone => "emoji_none",
            Self::EmojiOld => "emoji_old",
            Self::EmojiNew => "emoji_new",
            Self::Vip => "vip",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "emoji_none" => Some(Self::EmojiNone),
            "emoji_old" => Some(Self::EmojiOld),
            "emoji_new" => Some(Self::EmojiNew),
            "vip" => Some(Self::Vip),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmoteClickAction {
    ///
    EmoteClickNone = 0,
    ///
    EmoteClickPopupPreview = 1,
}
impl EmoteClickAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmoteClickNone => "EMOTE_CLICK_NONE",
            Self::EmoteClickPopupPreview => "EMOTE_CLICK_POPUP_PREVIEW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOTE_CLICK_NONE" => Some(Self::EmoteClickNone),
            "EMOTE_CLICK_POPUP_PREVIEW" => Some(Self::EmoteClickPopupPreview),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EspaceStyle {
    ///
    Moba = 0,
}
impl EspaceStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Moba => "moba",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "moba" => Some(Self::Moba),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FlowItemType {
    ///
    Invalid = 0,
    ///
    Opus = 1,
}
impl FlowItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "FLOW_ITEM_TYPE_INVALID",
            Self::Opus => "FLOW_ITEM_TYPE_OPUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FLOW_ITEM_TYPE_INVALID" => Some(Self::Invalid),
            "FLOW_ITEM_TYPE_OPUS" => Some(Self::Opus),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FoldType {
    ///
    Zore = 0,
    ///
    Publish = 1,
    ///
    Frequent = 2,
    ///
    Unite = 3,
    ///
    Limit = 4,
    ///
    TopicMerged = 5,
}
impl FoldType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Zore => "FoldTypeZore",
            Self::Publish => "FoldTypePublish",
            Self::Frequent => "FoldTypeFrequent",
            Self::Unite => "FoldTypeUnite",
            Self::Limit => "FoldTypeLimit",
            Self::TopicMerged => "FoldTypeTopicMerged",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FoldTypeZore" => Some(Self::Zore),
            "FoldTypePublish" => Some(Self::Publish),
            "FoldTypeFrequent" => Some(Self::Frequent),
            "FoldTypeUnite" => Some(Self::Unite),
            "FoldTypeLimit" => Some(Self::Limit),
            "FoldTypeTopicMerged" => Some(Self::TopicMerged),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GoodsJumpType {
    ///
    GoodsNone = 0,
    ///
    GoodsSchema = 1,
    ///
    GoodsUrl = 2,
}
impl GoodsJumpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GoodsNone => "goods_none",
            Self::GoodsSchema => "goods_schema",
            Self::GoodsUrl => "goods_url",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "goods_none" => Some(Self::GoodsNone),
            "goods_schema" => Some(Self::GoodsSchema),
            "goods_url" => Some(Self::GoodsUrl),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HighlightTextStyle {
    ///
    StyleNone = 0,
    ///
    StyleHighlight = 1,
}
impl HighlightTextStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StyleNone => "style_none",
            Self::StyleHighlight => "style_highlight",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "style_none" => Some(Self::StyleNone),
            "style_highlight" => Some(Self::StyleHighlight),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HomePageTabSttingStatus {
    ///
    SettingInvalid = 0,
    ///
    SettingOpen = 1,
    ///
    SettingClose = 2,
}
impl HomePageTabSttingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettingInvalid => "SETTING_INVALID",
            Self::SettingOpen => "SETTING_OPEN",
            Self::SettingClose => "SETTING_CLOSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTING_INVALID" => Some(Self::SettingInvalid),
            "SETTING_OPEN" => Some(Self::SettingOpen),
            "SETTING_CLOSE" => Some(Self::SettingClose),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IconResLocal {
    ///
    None = 0,
    ///
    Live = 1,
}
impl IconResLocal {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ICON_RES_LOCAL_NONE",
            Self::Live => "ICON_RES_LOCAL_LIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ICON_RES_LOCAL_NONE" => Some(Self::None),
            "ICON_RES_LOCAL_LIVE" => Some(Self::Live),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImageStyle {
    ///
    AddStyleVertical = 0,
    ///
    AddStyleSquare = 1,
}
impl ImageStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AddStyleVertical => "add_style_vertical",
            Self::AddStyleSquare => "add_style_square",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "add_style_vertical" => Some(Self::AddStyleVertical),
            "add_style_square" => Some(Self::AddStyleSquare),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LightFromType {
    ///
    FromLogin = 0,
    ///
    FromUnlogin = 1,
}
impl LightFromType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FromLogin => "from_login",
            Self::FromUnlogin => "from_unlogin",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "from_login" => Some(Self::FromLogin),
            "from_unlogin" => Some(Self::FromUnlogin),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkNodeType {
    ///
    Invalid = 0,
    ///
    Video = 1,
    ///
    Reserve = 2,
    ///
    Vote = 3,
    ///
    Live = 4,
    ///
    Lottery = 5,
    ///
    Match = 6,
    ///
    Goods = 7,
    ///
    OgvSs = 8,
    ///
    OgvEp = 9,
    ///
    Manga = 10,
    ///
    Cheese = 11,
    ///
    VideoTs = 12,
    ///
    At = 13,
    ///
    HashTag = 14,
    ///
    Article = 15,
    ///
    Url = 16,
    ///
    Mail = 17,
    ///
    Lbs = 18,
    ///
    Activity = 19,
    ///
    AttachCardOfficialActivity = 20,
    ///
    Game = 21,
    ///
    Decoration = 22,
    ///
    UpTopic = 23,
    ///
    UpActivity = 24,
    ///
    UpMaoer = 25,
    ///
    MemberGoods = 26,
    ///
    OpenmallUpItems = 27,
    ///
    Search = 28,
    ///
    Music = 29,
    ///
    GptRcmdQuestion = 30,
    ///
    MemberTicket = 31,
    ///
    RepostPicUrl = 32,
    ///
    RepostPicDynUrl = 33,
    ///
    OgvFollowCard = 34,
    ///
    ArticleGoods = 35,
    ///
    ArticleTag = 36,
}
impl LinkNodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "INVALID",
            Self::Video => "VIDEO",
            Self::Reserve => "RESERVE",
            Self::Vote => "VOTE",
            Self::Live => "LIVE",
            Self::Lottery => "LOTTERY",
            Self::Match => "MATCH",
            Self::Goods => "GOODS",
            Self::OgvSs => "OGV_SS",
            Self::OgvEp => "OGV_EP",
            Self::Manga => "MANGA",
            Self::Cheese => "CHEESE",
            Self::VideoTs => "VIDEO_TS",
            Self::At => "AT",
            Self::HashTag => "HASH_TAG",
            Self::Article => "ARTICLE",
            Self::Url => "URL",
            Self::Mail => "MAIL",
            Self::Lbs => "LBS",
            Self::Activity => "ACTIVITY",
            Self::AttachCardOfficialActivity => "ATTACH_CARD_OFFICIAL_ACTIVITY",
            Self::Game => "GAME",
            Self::Decoration => "DECORATION",
            Self::UpTopic => "UP_TOPIC",
            Self::UpActivity => "UP_ACTIVITY",
            Self::UpMaoer => "UP_MAOER",
            Self::MemberGoods => "MEMBER_GOODS",
            Self::OpenmallUpItems => "OPENMALL_UP_ITEMS",
            Self::Search => "SEARCH",
            Self::Music => "MUSIC",
            Self::GptRcmdQuestion => "GPT_RCMD_QUESTION",
            Self::MemberTicket => "MEMBER_TICKET",
            Self::RepostPicUrl => "REPOST_PIC_URL",
            Self::RepostPicDynUrl => "REPOST_PIC_DYN_URL",
            Self::OgvFollowCard => "OGV_FOLLOW_CARD",
            Self::ArticleGoods => "ARTICLE_GOODS",
            Self::ArticleTag => "ARTICLE_TAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVALID" => Some(Self::Invalid),
            "VIDEO" => Some(Self::Video),
            "RESERVE" => Some(Self::Reserve),
            "VOTE" => Some(Self::Vote),
            "LIVE" => Some(Self::Live),
            "LOTTERY" => Some(Self::Lottery),
            "MATCH" => Some(Self::Match),
            "GOODS" => Some(Self::Goods),
            "OGV_SS" => Some(Self::OgvSs),
            "OGV_EP" => Some(Self::OgvEp),
            "MANGA" => Some(Self::Manga),
            "CHEESE" => Some(Self::Cheese),
            "VIDEO_TS" => Some(Self::VideoTs),
            "AT" => Some(Self::At),
            "HASH_TAG" => Some(Self::HashTag),
            "ARTICLE" => Some(Self::Article),
            "URL" => Some(Self::Url),
            "MAIL" => Some(Self::Mail),
            "LBS" => Some(Self::Lbs),
            "ACTIVITY" => Some(Self::Activity),
            "ATTACH_CARD_OFFICIAL_ACTIVITY" => Some(Self::AttachCardOfficialActivity),
            "GAME" => Some(Self::Game),
            "DECORATION" => Some(Self::Decoration),
            "UP_TOPIC" => Some(Self::UpTopic),
            "UP_ACTIVITY" => Some(Self::UpActivity),
            "UP_MAOER" => Some(Self::UpMaoer),
            "MEMBER_GOODS" => Some(Self::MemberGoods),
            "OPENMALL_UP_ITEMS" => Some(Self::OpenmallUpItems),
            "SEARCH" => Some(Self::Search),
            "MUSIC" => Some(Self::Music),
            "GPT_RCMD_QUESTION" => Some(Self::GptRcmdQuestion),
            "MEMBER_TICKET" => Some(Self::MemberTicket),
            "REPOST_PIC_URL" => Some(Self::RepostPicUrl),
            "REPOST_PIC_DYN_URL" => Some(Self::RepostPicDynUrl),
            "OGV_FOLLOW_CARD" => Some(Self::OgvFollowCard),
            "ARTICLE_GOODS" => Some(Self::ArticleGoods),
            "ARTICLE_TAG" => Some(Self::ArticleTag),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LiveState {
    ///
    LiveNone = 0,
    ///
    LiveLive = 1,
    ///
    LiveRotation = 2,
}
impl LiveState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LiveNone => "live_none",
            Self::LiveLive => "live_live",
            Self::LiveRotation => "live_rotation",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "live_none" => Some(Self::LiveNone),
            "live_live" => Some(Self::LiveLive),
            "live_rotation" => Some(Self::LiveRotation),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LocalIconType {
    ///
    LocalIconComment = 0,
    ///
    LocalIconLike = 1,
    ///
    LocalIconAvatar = 2,
    ///
    LocalIconCover = 3,
    ///
    LocalIconLikeAndForward = 4,
}
impl LocalIconType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LocalIconComment => "local_icon_comment",
            Self::LocalIconLike => "local_icon_like",
            Self::LocalIconAvatar => "local_icon_avatar",
            Self::LocalIconCover => "local_icon_cover",
            Self::LocalIconLikeAndForward => "local_icon_like_and_forward",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "local_icon_comment" => Some(Self::LocalIconComment),
            "local_icon_like" => Some(Self::LocalIconLike),
            "local_icon_avatar" => Some(Self::LocalIconAvatar),
            "local_icon_cover" => Some(Self::LocalIconCover),
            "local_icon_like_and_forward" => Some(Self::LocalIconLikeAndForward),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MangaLikePageDirection {
    ///
    PageDirectionInvalid = 0,
    ///
    PageDirectionLeftToRight = 1,
    ///
    PageDirectionRightToLeft = 2,
    ///
    PageDirectionLeftToRightRotate = 3,
}
impl MangaLikePageDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PageDirectionInvalid => "PAGE_DIRECTION_INVALID",
            Self::PageDirectionLeftToRight => "PAGE_DIRECTION_LEFT_TO_RIGHT",
            Self::PageDirectionRightToLeft => "PAGE_DIRECTION_RIGHT_TO_LEFT",
            Self::PageDirectionLeftToRightRotate => "PAGE_DIRECTION_LEFT_TO_RIGHT_ROTATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAGE_DIRECTION_INVALID" => Some(Self::PageDirectionInvalid),
            "PAGE_DIRECTION_LEFT_TO_RIGHT" => Some(Self::PageDirectionLeftToRight),
            "PAGE_DIRECTION_RIGHT_TO_LEFT" => Some(Self::PageDirectionRightToLeft),
            "PAGE_DIRECTION_LEFT_TO_RIGHT_ROTATE" => {
                Some(Self::PageDirectionLeftToRightRotate)
            }
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MangaLikePicClickAction {
    ///
    ClickActNone = 0,
    ///
    ClickActMangaBrowser = 1,
    ///
    ClickActNormalBrowser = 2,
}
impl MangaLikePicClickAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ClickActNone => "CLICK_ACT_NONE",
            Self::ClickActMangaBrowser => "CLICK_ACT_MANGA_BROWSER",
            Self::ClickActNormalBrowser => "CLICK_ACT_NORMAL_BROWSER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLICK_ACT_NONE" => Some(Self::ClickActNone),
            "CLICK_ACT_MANGA_BROWSER" => Some(Self::ClickActMangaBrowser),
            "CLICK_ACT_NORMAL_BROWSER" => Some(Self::ClickActNormalBrowser),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MdlBlockedStyle {
    ///
    BlockedStyleDefault = 0,
    ///
    BlockedStyleInAudit = 1,
    ///
    BlockedStyleOnlyFansList = 2,
    ///
    BlockedStyleOnlyFansVideo = 3,
    ///
    BlockedStyleMangaPurchase = 4,
}
impl MdlBlockedStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BlockedStyleDefault => "BLOCKED_STYLE_DEFAULT",
            Self::BlockedStyleInAudit => "BLOCKED_STYLE_IN_AUDIT",
            Self::BlockedStyleOnlyFansList => "BLOCKED_STYLE_ONLY_FANS_LIST",
            Self::BlockedStyleOnlyFansVideo => "BLOCKED_STYLE_ONLY_FANS_VIDEO",
            Self::BlockedStyleMangaPurchase => "BLOCKED_STYLE_MANGA_PURCHASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOCKED_STYLE_DEFAULT" => Some(Self::BlockedStyleDefault),
            "BLOCKED_STYLE_IN_AUDIT" => Some(Self::BlockedStyleInAudit),
            "BLOCKED_STYLE_ONLY_FANS_LIST" => Some(Self::BlockedStyleOnlyFansList),
            "BLOCKED_STYLE_ONLY_FANS_VIDEO" => Some(Self::BlockedStyleOnlyFansVideo),
            "BLOCKED_STYLE_MANGA_PURCHASE" => Some(Self::BlockedStyleMangaPurchase),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MdlDynCommonType {
    ///
    MdlDynCommonNone = 0,
    ///
    MdlDynCommonSquare = 1,
    ///
    MdlDynCommonVertica = 2,
}
impl MdlDynCommonType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MdlDynCommonNone => "mdl_dyn_common_none",
            Self::MdlDynCommonSquare => "mdl_dyn_common_square",
            Self::MdlDynCommonVertica => "mdl_dyn_common_vertica",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "mdl_dyn_common_none" => Some(Self::MdlDynCommonNone),
            "mdl_dyn_common_square" => Some(Self::MdlDynCommonSquare),
            "mdl_dyn_common_vertica" => Some(Self::MdlDynCommonVertica),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MdlDynDrawTagType {
    ///
    MdlDrawTagNone = 0,
    ///
    MdlDrawTagCommon = 1,
    ///
    MdlDrawTagGoods = 2,
    ///
    MdlDrawTagUser = 3,
    ///
    MdlDrawTagTopic = 4,
    ///
    MdlDrawTagLbs = 5,
}
impl MdlDynDrawTagType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MdlDrawTagNone => "mdl_draw_tag_none",
            Self::MdlDrawTagCommon => "mdl_draw_tag_common",
            Self::MdlDrawTagGoods => "mdl_draw_tag_goods",
            Self::MdlDrawTagUser => "mdl_draw_tag_user",
            Self::MdlDrawTagTopic => "mdl_draw_tag_topic",
            Self::MdlDrawTagLbs => "mdl_draw_tag_lbs",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "mdl_draw_tag_none" => Some(Self::MdlDrawTagNone),
            "mdl_draw_tag_common" => Some(Self::MdlDrawTagCommon),
            "mdl_draw_tag_goods" => Some(Self::MdlDrawTagGoods),
            "mdl_draw_tag_user" => Some(Self::MdlDrawTagUser),
            "mdl_draw_tag_topic" => Some(Self::MdlDrawTagTopic),
            "mdl_draw_tag_lbs" => Some(Self::MdlDrawTagLbs),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MdlDynSubscriptionNewStyle {
    ///
    Nont = 0,
    ///
    Live = 1,
    ///
    Draw = 2,
}
impl MdlDynSubscriptionNewStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Nont => "mdl_dyn_subscription_new_style_nont",
            Self::Live => "mdl_dyn_subscription_new_style_live",
            Self::Draw => "mdl_dyn_subscription_new_style_draw",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "mdl_dyn_subscription_new_style_nont" => Some(Self::Nont),
            "mdl_dyn_subscription_new_style_live" => Some(Self::Live),
            "mdl_dyn_subscription_new_style_draw" => Some(Self::Draw),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MediaType {
    ///
    None = 0,
    ///
    Ugc = 1,
    ///
    Pgc = 2,
    ///
    Live = 3,
    ///
    Vcs = 4,
}
impl MediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MediaTypeNone",
            Self::Ugc => "MediaTypeUGC",
            Self::Pgc => "MediaTypePGC",
            Self::Live => "MediaTypeLive",
            Self::Vcs => "MediaTypeVCS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MediaTypeNone" => Some(Self::None),
            "MediaTypeUGC" => Some(Self::Ugc),
            "MediaTypePGC" => Some(Self::Pgc),
            "MediaTypeLive" => Some(Self::Live),
            "MediaTypeVCS" => Some(Self::Vcs),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModuleAuthorBadgeType {
    ///
    None = 0,
    ///
    ThreePoint = 1,
    ///
    Button = 2,
    ///
    Weight = 3,
}
impl ModuleAuthorBadgeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "module_author_badge_type_none",
            Self::ThreePoint => "module_author_badge_type_threePoint",
            Self::Button => "module_author_badge_type_button",
            Self::Weight => "module_author_badge_type_weight",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "module_author_badge_type_none" => Some(Self::None),
            "module_author_badge_type_threePoint" => Some(Self::ThreePoint),
            "module_author_badge_type_button" => Some(Self::Button),
            "module_author_badge_type_weight" => Some(Self::Weight),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModuleBannerType {
    ///
    None = 0,
    ///
    User = 1,
}
impl ModuleBannerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "module_banner_type_none",
            Self::User => "module_banner_type_user",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "module_banner_type_none" => Some(Self::None),
            "module_banner_type_user" => Some(Self::User),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModuleDynamicType {
    ///
    MdlDynArchive = 0,
    ///
    MdlDynPgc = 1,
    ///
    MdlDynCourSeason = 2,
    ///
    MdlDynCourBatch = 3,
    ///
    MdlDynForward = 4,
    ///
    MdlDynDraw = 5,
    ///
    MdlDynArticle = 6,
    ///
    MdlDynMusic = 7,
    ///
    MdlDynCommon = 8,
    ///
    MdlDynLive = 9,
    ///
    MdlDynMedialist = 10,
    ///
    MdlDynApplet = 11,
    ///
    MdlDynSubscription = 12,
    ///
    MdlDynLiveRcmd = 13,
    ///
    MdlDynUgcSeason = 14,
    ///
    MdlDynSubscriptionNew = 15,
    ///
    MdlDynCourUp = 16,
    ///
    MdlDynTopicSet = 17,
    ///
    MdlDynChargingArchive = 18,
    ///
    MdlDynShareChargingQa = 19,
}
impl ModuleDynamicType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MdlDynArchive => "mdl_dyn_archive",
            Self::MdlDynPgc => "mdl_dyn_pgc",
            Self::MdlDynCourSeason => "mdl_dyn_cour_season",
            Self::MdlDynCourBatch => "mdl_dyn_cour_batch",
            Self::MdlDynForward => "mdl_dyn_forward",
            Self::MdlDynDraw => "mdl_dyn_draw",
            Self::MdlDynArticle => "mdl_dyn_article",
            Self::MdlDynMusic => "mdl_dyn_music",
            Self::MdlDynCommon => "mdl_dyn_common",
            Self::MdlDynLive => "mdl_dyn_live",
            Self::MdlDynMedialist => "mdl_dyn_medialist",
            Self::MdlDynApplet => "mdl_dyn_applet",
            Self::MdlDynSubscription => "mdl_dyn_subscription",
            Self::MdlDynLiveRcmd => "mdl_dyn_live_rcmd",
            Self::MdlDynUgcSeason => "mdl_dyn_ugc_season",
            Self::MdlDynSubscriptionNew => "mdl_dyn_subscription_new",
            Self::MdlDynCourUp => "mdl_dyn_cour_up",
            Self::MdlDynTopicSet => "mdl_dyn_topic_set",
            Self::MdlDynChargingArchive => "mdl_dyn_charging_archive",
            Self::MdlDynShareChargingQa => "mdl_dyn_share_charging_qa",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "mdl_dyn_archive" => Some(Self::MdlDynArchive),
            "mdl_dyn_pgc" => Some(Self::MdlDynPgc),
            "mdl_dyn_cour_season" => Some(Self::MdlDynCourSeason),
            "mdl_dyn_cour_batch" => Some(Self::MdlDynCourBatch),
            "mdl_dyn_forward" => Some(Self::MdlDynForward),
            "mdl_dyn_draw" => Some(Self::MdlDynDraw),
            "mdl_dyn_article" => Some(Self::MdlDynArticle),
            "mdl_dyn_music" => Some(Self::MdlDynMusic),
            "mdl_dyn_common" => Some(Self::MdlDynCommon),
            "mdl_dyn_live" => Some(Self::MdlDynLive),
            "mdl_dyn_medialist" => Some(Self::MdlDynMedialist),
            "mdl_dyn_applet" => Some(Self::MdlDynApplet),
            "mdl_dyn_subscription" => Some(Self::MdlDynSubscription),
            "mdl_dyn_live_rcmd" => Some(Self::MdlDynLiveRcmd),
            "mdl_dyn_ugc_season" => Some(Self::MdlDynUgcSeason),
            "mdl_dyn_subscription_new" => Some(Self::MdlDynSubscriptionNew),
            "mdl_dyn_cour_up" => Some(Self::MdlDynCourUp),
            "mdl_dyn_topic_set" => Some(Self::MdlDynTopicSet),
            "mdl_dyn_charging_archive" => Some(Self::MdlDynChargingArchive),
            "mdl_dyn_share_charging_qa" => Some(Self::MdlDynShareChargingQa),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NftRegionType {
    ///
    NftRegionDefault = 0,
    ///
    NftRegionMainlang = 1,
    ///
    NftRegionGat = 2,
}
impl NftRegionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NftRegionDefault => "nft_region_default",
            Self::NftRegionMainlang => "nft_region_mainlang",
            Self::NftRegionGat => "nft_region_gat",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "nft_region_default" => Some(Self::NftRegionDefault),
            "nft_region_mainlang" => Some(Self::NftRegionMainlang),
            "nft_region_gat" => Some(Self::NftRegionGat),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NftShowStatus {
    ///
    NftShowDefault = 0,
    ///
    NftShowZoominmainlang = 1,
    ///
    NftShowRaw = 2,
}
impl NftShowStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NftShowDefault => "nft_show_default",
            Self::NftShowZoominmainlang => "nft_show_zoominmainlang",
            Self::NftShowRaw => "nft_show_raw",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "nft_show_default" => Some(Self::NftShowDefault),
            "nft_show_zoominmainlang" => Some(Self::NftShowZoominmainlang),
            "nft_show_raw" => Some(Self::NftShowRaw),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetworkType {
    ///
    NtUnknown = 0,
    ///
    Wifi = 1,
    ///
    Cellular = 2,
    ///
    Offline = 3,
    ///
    Othernet = 4,
    ///
    Ethernet = 5,
}
impl NetworkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NtUnknown => "NT_UNKNOWN",
            Self::Wifi => "WIFI",
            Self::Cellular => "CELLULAR",
            Self::Offline => "OFFLINE",
            Self::Othernet => "OTHERNET",
            Self::Ethernet => "ETHERNET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NT_UNKNOWN" => Some(Self::NtUnknown),
            "WIFI" => Some(Self::Wifi),
            "CELLULAR" => Some(Self::Cellular),
            "OFFLINE" => Some(Self::Offline),
            "OTHERNET" => Some(Self::Othernet),
            "ETHERNET" => Some(Self::Ethernet),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpusType {
    ///
    Dyn = 0,
    ///
    Article = 1,
    ///
    Note = 2,
    ///
    Word = 3,
    ///
    Repost = 4,
    ///
    MangaEp = 5,
}
impl OpusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Dyn => "OPUS_TYPE_DYN",
            Self::Article => "OPUS_TYPE_ARTICLE",
            Self::Note => "OPUS_TYPE_NOTE",
            Self::Word => "OPUS_TYPE_WORD",
            Self::Repost => "OPUS_TYPE_REPOST",
            Self::MangaEp => "OPUS_TYPE_MANGA_EP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPUS_TYPE_DYN" => Some(Self::Dyn),
            "OPUS_TYPE_ARTICLE" => Some(Self::Article),
            "OPUS_TYPE_NOTE" => Some(Self::Note),
            "OPUS_TYPE_WORD" => Some(Self::Word),
            "OPUS_TYPE_REPOST" => Some(Self::Repost),
            "OPUS_TYPE_MANGA_EP" => Some(Self::MangaEp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RcmdReasonStyle {
    ///
    None = 0,
    ///
    CampusNearby = 1,
    ///
    CampusUp = 2,
    ///
    CampusNearUpMix = 3,
}
impl RcmdReasonStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "rcmd_reason_style_none",
            Self::CampusNearby => "rcmd_reason_style_campus_nearby",
            Self::CampusUp => "rcmd_reason_style_campus_up",
            Self::CampusNearUpMix => "rcmd_reason_style_campus_near_up_mix",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "rcmd_reason_style_none" => Some(Self::None),
            "rcmd_reason_style_campus_nearby" => Some(Self::CampusNearby),
            "rcmd_reason_style_campus_up" => Some(Self::CampusUp),
            "rcmd_reason_style_campus_near_up_mix" => Some(Self::CampusNearUpMix),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RcmdType {
    ///
    RcmdArchive = 0,
    ///
    RcmdDynamic = 1,
}
impl RcmdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RcmdArchive => "rcmd_archive",
            Self::RcmdDynamic => "rcmd_dynamic",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "rcmd_archive" => Some(Self::RcmdArchive),
            "rcmd_dynamic" => Some(Self::RcmdDynamic),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Refresh {
    ///
    New = 0,
    ///
    History = 1,
}
impl Refresh {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::New => "refresh_new",
            Self::History => "refresh_history",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "refresh_new" => Some(Self::New),
            "refresh_history" => Some(Self::History),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RelationStatus {
    ///
    None = 0,
    ///
    Nofollow = 1,
    ///
    Follow = 2,
    ///
    Followed = 3,
    ///
    MutualConcern = 4,
    ///
    Special = 5,
}
impl RelationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "relation_status_none",
            Self::Nofollow => "relation_status_nofollow",
            Self::Follow => "relation_status_follow",
            Self::Followed => "relation_status_followed",
            Self::MutualConcern => "relation_status_mutual_concern",
            Self::Special => "relation_status_special",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "relation_status_none" => Some(Self::None),
            "relation_status_nofollow" => Some(Self::Nofollow),
            "relation_status_follow" => Some(Self::Follow),
            "relation_status_followed" => Some(Self::Followed),
            "relation_status_mutual_concern" => Some(Self::MutualConcern),
            "relation_status_special" => Some(Self::Special),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RepostType {
    ///
    RepostHot = 0,
    ///
    RepostGeneral = 1,
}
impl RepostType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RepostHot => "repost_hot",
            Self::RepostGeneral => "repost_general",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "repost_hot" => Some(Self::RepostHot),
            "repost_general" => Some(Self::RepostGeneral),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReserveRelationLotteryType {
    ///
    Default = 0,
    ///
    Cron = 1,
}
impl ReserveRelationLotteryType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "reserve_relation_lottery_type_default",
            Self::Cron => "reserve_relation_lottery_type_cron",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "reserve_relation_lottery_type_default" => Some(Self::Default),
            "reserve_relation_lottery_type_cron" => Some(Self::Cron),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReserveType {
    ///
    ReserveNone = 0,
    ///
    ReserveRecall = 1,
}
impl ReserveType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReserveNone => "reserve_none",
            Self::ReserveRecall => "reserve_recall",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "reserve_none" => Some(Self::ReserveNone),
            "reserve_recall" => Some(Self::ReserveRecall),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RouterAction {
    ///
    Open = 0,
    ///
    Embed = 1,
}
impl RouterAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Open => "OPEN",
            Self::Embed => "EMBED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPEN" => Some(Self::Open),
            "EMBED" => Some(Self::Embed),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShowType {
    ///
    None = 0,
    ///
    Backup = 1,
}
impl ShowType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "show_type_none",
            Self::Backup => "show_type_backup",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "show_type_none" => Some(Self::None),
            "show_type_backup" => Some(Self::Backup),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StyleType {
    ///
    None = 0,
    ///
    Live = 1,
    ///
    DynUp = 2,
}
impl StyleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "STYLE_TYPE_NONE",
            Self::Live => "STYLE_TYPE_LIVE",
            Self::DynUp => "STYLE_TYPE_DYN_UP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STYLE_TYPE_NONE" => Some(Self::None),
            "STYLE_TYPE_LIVE" => Some(Self::Live),
            "STYLE_TYPE_DYN_UP" => Some(Self::DynUp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TfType {
    ///
    TfUnknown = 0,
    ///
    UCard = 1,
    ///
    UPkg = 2,
    ///
    CCard = 3,
    ///
    CPkg = 4,
    ///
    TCard = 5,
    ///
    TPkg = 6,
}
impl TfType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TfUnknown => "TF_UNKNOWN",
            Self::UCard => "U_CARD",
            Self::UPkg => "U_PKG",
            Self::CCard => "C_CARD",
            Self::CPkg => "C_PKG",
            Self::TCard => "T_CARD",
            Self::TPkg => "T_PKG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TF_UNKNOWN" => Some(Self::TfUnknown),
            "U_CARD" => Some(Self::UCard),
            "U_PKG" => Some(Self::UPkg),
            "C_CARD" => Some(Self::CCard),
            "C_PKG" => Some(Self::CPkg),
            "T_CARD" => Some(Self::TCard),
            "T_PKG" => Some(Self::TPkg),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreePointAttentionStatus {
    ///
    TpNotAttention = 0,
    ///
    TpAttention = 1,
}
impl ThreePointAttentionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TpNotAttention => "tp_not_attention",
            Self::TpAttention => "tp_attention",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "tp_not_attention" => Some(Self::TpNotAttention),
            "tp_attention" => Some(Self::TpAttention),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreePointType {
    ///
    TpNone = 0,
    ///
    Background = 1,
    ///
    AutoPlay = 2,
    ///
    Share = 3,
    ///
    Wait = 4,
    ///
    Attention = 5,
    ///
    Report = 6,
    ///
    Delete = 7,
    ///
    Dislike = 8,
    ///
    Favorite = 9,
    ///
    Top = 10,
    ///
    Comment = 11,
    ///
    Hide = 12,
    ///
    CampusDelete = 13,
    ///
    TopicIrrelevant = 14,
    ///
    BatchCancel = 15,
    ///
    TopicSetCancel = 16,
    ///
    DynamicEdit = 17,
    ///
    CreateVideo = 18,
    ///
    Coin = 19,
    ///
    OgvSubscribe = 20,
    ///
    VisibilityChange = 21,
    ///
    TopicTop = 22,
}
impl ThreePointType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TpNone => "tp_none",
            Self::Background => "background",
            Self::AutoPlay => "auto_play",
            Self::Share => "share",
            Self::Wait => "wait",
            Self::Attention => "attention",
            Self::Report => "report",
            Self::Delete => "delete",
            Self::Dislike => "dislike",
            Self::Favorite => "favorite",
            Self::Top => "top",
            Self::Comment => "comment",
            Self::Hide => "hide",
            Self::CampusDelete => "campus_delete",
            Self::TopicIrrelevant => "topic_irrelevant",
            Self::BatchCancel => "batch_cancel",
            Self::TopicSetCancel => "topic_set_cancel",
            Self::DynamicEdit => "dynamic_edit",
            Self::CreateVideo => "create_video",
            Self::Coin => "coin",
            Self::OgvSubscribe => "ogv_subscribe",
            Self::VisibilityChange => "visibility_change",
            Self::TopicTop => "topic_top",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "tp_none" => Some(Self::TpNone),
            "background" => Some(Self::Background),
            "auto_play" => Some(Self::AutoPlay),
            "share" => Some(Self::Share),
            "wait" => Some(Self::Wait),
            "attention" => Some(Self::Attention),
            "report" => Some(Self::Report),
            "delete" => Some(Self::Delete),
            "dislike" => Some(Self::Dislike),
            "favorite" => Some(Self::Favorite),
            "top" => Some(Self::Top),
            "comment" => Some(Self::Comment),
            "hide" => Some(Self::Hide),
            "campus_delete" => Some(Self::CampusDelete),
            "topic_irrelevant" => Some(Self::TopicIrrelevant),
            "batch_cancel" => Some(Self::BatchCancel),
            "topic_set_cancel" => Some(Self::TopicSetCancel),
            "dynamic_edit" => Some(Self::DynamicEdit),
            "create_video" => Some(Self::CreateVideo),
            "coin" => Some(Self::Coin),
            "ogv_subscribe" => Some(Self::OgvSubscribe),
            "visibility_change" => Some(Self::VisibilityChange),
            "topic_top" => Some(Self::TopicTop),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThumbType {
    ///
    Cancel = 0,
    ///
    Thumb = 1,
}
impl ThumbType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Cancel => "cancel",
            Self::Thumb => "thumb",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "cancel" => Some(Self::Cancel),
            "thumb" => Some(Self::Thumb),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TopType {
    ///
    TopNone = 0,
    ///
    TopCancel = 1,
}
impl TopType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TopNone => "top_none",
            Self::TopCancel => "top_cancel",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "top_none" => Some(Self::TopNone),
            "top_cancel" => Some(Self::TopCancel),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserItemType {
    ///
    None = 0,
    ///
    Live = 1,
    ///
    LiveCustom = 2,
    ///
    Normal = 3,
    ///
    Extend = 4,
    ///
    PremiereReserve = 5,
    ///
    Premiere = 6,
    ///
    LiveCard = 7,
    ///
    OgvSeason = 8,
    ///
    UgcSeason = 9,
}
impl UserItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "user_item_type_none",
            Self::Live => "user_item_type_live",
            Self::LiveCustom => "user_item_type_live_custom",
            Self::Normal => "user_item_type_normal",
            Self::Extend => "user_item_type_extend",
            Self::PremiereReserve => "user_item_type_premiere_reserve",
            Self::Premiere => "user_item_type_premiere",
            Self::LiveCard => "user_item_type_live_card",
            Self::OgvSeason => "user_item_type_ogv_season",
            Self::UgcSeason => "user_item_type_ugc_season",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "user_item_type_none" => Some(Self::None),
            "user_item_type_live" => Some(Self::Live),
            "user_item_type_live_custom" => Some(Self::LiveCustom),
            "user_item_type_normal" => Some(Self::Normal),
            "user_item_type_extend" => Some(Self::Extend),
            "user_item_type_premiere_reserve" => Some(Self::PremiereReserve),
            "user_item_type_premiere" => Some(Self::Premiere),
            "user_item_type_live_card" => Some(Self::LiveCard),
            "user_item_type_ogv_season" => Some(Self::OgvSeason),
            "user_item_type_ugc_season" => Some(Self::UgcSeason),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VideoSubType {
    ///
    None = 0,
    ///
    Bangumi = 1,
    ///
    Movie = 2,
    ///
    Documentary = 3,
    ///
    Domestic = 4,
    ///
    Teleplay = 5,
}
impl VideoSubType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "VideoSubTypeNone",
            Self::Bangumi => "VideoSubTypeBangumi",
            Self::Movie => "VideoSubTypeMovie",
            Self::Documentary => "VideoSubTypeDocumentary",
            Self::Domestic => "VideoSubTypeDomestic",
            Self::Teleplay => "VideoSubTypeTeleplay",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VideoSubTypeNone" => Some(Self::None),
            "VideoSubTypeBangumi" => Some(Self::Bangumi),
            "VideoSubTypeMovie" => Some(Self::Movie),
            "VideoSubTypeDocumentary" => Some(Self::Documentary),
            "VideoSubTypeDomestic" => Some(Self::Domestic),
            "VideoSubTypeTeleplay" => Some(Self::Teleplay),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VideoType {
    ///
    General = 0,
    ///
    Dynamic = 1,
    ///
    Playback = 2,
    ///
    Story = 3,
}
impl VideoType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::General => "video_type_general",
            Self::Dynamic => "video_type_dynamic",
            Self::Playback => "video_type_playback",
            Self::Story => "video_type_story",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "video_type_general" => Some(Self::General),
            "video_type_dynamic" => Some(Self::Dynamic),
            "video_type_playback" => Some(Self::Playback),
            "video_type_story" => Some(Self::Story),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VoteStatus {
    ///
    Normal = 0,
    ///
    Anonymous = 1,
}
impl VoteStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "normal",
            Self::Anonymous => "anonymous",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "normal" => Some(Self::Normal),
            "anonymous" => Some(Self::Anonymous),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WfItemType {
    ///
    WaterFlowTypeNone = 0,
    ///
    WaterFlowTypeArchive = 1,
    ///
    WaterFlowTypeDynamic = 2,
}
impl WfItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::WaterFlowTypeNone => "WATER_FLOW_TYPE_NONE",
            Self::WaterFlowTypeArchive => "WATER_FLOW_TYPE_ARCHIVE",
            Self::WaterFlowTypeDynamic => "WATER_FLOW_TYPE_DYNAMIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WATER_FLOW_TYPE_NONE" => Some(Self::WaterFlowTypeNone),
            "WATER_FLOW_TYPE_ARCHIVE" => Some(Self::WaterFlowTypeArchive),
            "WATER_FLOW_TYPE_DYNAMIC" => Some(Self::WaterFlowTypeDynamic),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WeightType {
    ///
    WeightNone = 0,
    ///
    WeightDislike = 1,
    ///
    WeightJump = 2,
}
impl WeightType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::WeightNone => "weight_none",
            Self::WeightDislike => "weight_dislike",
            Self::WeightJump => "weight_jump",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "weight_none" => Some(Self::WeightNone),
            "weight_dislike" => Some(Self::WeightDislike),
            "weight_jump" => Some(Self::WeightJump),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod campus_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct CampusClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> CampusClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CampusClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CampusClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn water_flow_rcmd(
            &mut self,
            request: impl tonic::IntoRequest<super::WaterFlowRcmdReq>,
        ) -> std::result::Result<
            tonic::Response<super::WaterFlowRcmdResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Campus/WaterFlowRcmd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Campus", "WaterFlowRcmd"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod dynamic_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct DynamicClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DynamicClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DynamicClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DynamicClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn alumni_dynamics(
            &mut self,
            request: impl tonic::IntoRequest<super::AlumniDynamicsReq>,
        ) -> std::result::Result<
            tonic::Response<super::AlumniDynamicsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/AlumniDynamics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "AlumniDynamics"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_billboard(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusBillBoardReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusBillBoardReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusBillboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusBillboard"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_billboard_internal(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusBillboardInternalReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusBillBoardReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusBillboardInternal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "CampusBillboardInternal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_entry_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusEntryTabReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusEntryTabResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusEntryTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusEntryTab"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_feedback(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusFeedbackReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusFeedbackReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusFeedback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusFeedback"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_home_pages(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusHomePagesReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusHomePagesReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusHomePages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusHomePages"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_mate_like_list(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusMateLikeListReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMateLikeListReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusMateLikeList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "CampusMateLikeList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_mng_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusMngDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMngDetailReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusMngDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusMngDetail"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_mng_quiz_operate(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusMngQuizOperateReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMngQuizOperateReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusMngQuizOperate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "CampusMngQuizOperate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_mng_submit(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusMngSubmitReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMngSubmitReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusMngSubmit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusMngSubmit"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_rcmd(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusRcmdReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRcmdReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusRcmd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusRcmd"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_rcmd_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusRcmdFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRcmdFeedReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusRcmdFeed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusRcmdFeed"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_recommend(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusRecommendReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRecommendReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusRecommend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusRecommend"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_red_dot(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusRedDotReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRedDotReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusRedDot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusRedDot"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_square(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusSquareReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusSquareReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusSquare",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "CampusSquare"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn campus_topic_rcmd_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::CampusTopicRcmdFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusTopicRcmdFeedReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CampusTopicRcmdFeed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "CampusTopicRcmdFeed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn cooperation_staff_list(
            &mut self,
            request: impl tonic::IntoRequest<super::CooperationStaffListReq>,
        ) -> std::result::Result<
            tonic::Response<super::CooperationStaffListResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/CooperationStaffList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "CooperationStaffList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_addition_common_follow(
            &mut self,
            request: impl tonic::IntoRequest<super::DynAdditionCommonFollowReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynAdditionCommonFollowReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynAdditionCommonFollow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynAdditionCommonFollow",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_all(
            &mut self,
            request: impl tonic::IntoRequest<super::DynAllReq>,
        ) -> std::result::Result<tonic::Response<super::DynAllReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynAll"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_all_personal(
            &mut self,
            request: impl tonic::IntoRequest<super::DynAllPersonalReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynAllPersonalReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynAllPersonal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynAllPersonal"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_all_upd_offset(
            &mut self,
            request: impl tonic::IntoRequest<super::DynAllUpdOffsetReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynAllUpdOffset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynAllUpdOffset"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::DynDetailReq>,
        ) -> std::result::Result<tonic::Response<super::DynDetailReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynDetail"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_details(
            &mut self,
            request: impl tonic::IntoRequest<super::DynDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynDetailsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_fake_card(
            &mut self,
            request: impl tonic::IntoRequest<super::DynFakeCardReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynFakeCardReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynFakeCard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynFakeCard"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_friend(
            &mut self,
            request: impl tonic::IntoRequest<super::DynFriendReq>,
        ) -> std::result::Result<tonic::Response<super::DynFriendReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynFriend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynFriend"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_light(
            &mut self,
            request: impl tonic::IntoRequest<super::DynLightReq>,
        ) -> std::result::Result<tonic::Response<super::DynLightReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynLight",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynLight"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_mix_up_list_search(
            &mut self,
            request: impl tonic::IntoRequest<super::DynMixUpListSearchReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListSearchReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynMixUpListSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynMixUpListSearch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_mix_up_list_view_more(
            &mut self,
            request: impl tonic::IntoRequest<super::DynMixUpListViewMoreReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListViewMoreReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynMixUpListViewMore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynMixUpListViewMore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_rcmd_up_exchange(
            &mut self,
            request: impl tonic::IntoRequest<super::DynRcmdUpExchangeReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynRcmdUpExchangeReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynRcmdUpExchange",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynRcmdUpExchange",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_search(
            &mut self,
            request: impl tonic::IntoRequest<super::DynSearchReq>,
        ) -> std::result::Result<tonic::Response<super::DynSearchReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynSearch"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_server_details(
            &mut self,
            request: impl tonic::IntoRequest<super::DynServerDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynServerDetailsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynServerDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynServerDetails",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_space(
            &mut self,
            request: impl tonic::IntoRequest<super::DynSpaceReq>,
        ) -> std::result::Result<tonic::Response<super::DynSpaceRsp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynSpace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynSpace"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_space_search_details(
            &mut self,
            request: impl tonic::IntoRequest<super::DynSpaceSearchDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynSpaceSearchDetailsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynSpaceSearchDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynSpaceSearchDetails",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::DynTabReq>,
        ) -> std::result::Result<tonic::Response<super::DynTabReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynTab"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_thumb(
            &mut self,
            request: impl tonic::IntoRequest<super::DynThumbReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynThumb",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynThumb"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_un_login_rcmd(
            &mut self,
            request: impl tonic::IntoRequest<super::DynRcmdReq>,
        ) -> std::result::Result<tonic::Response<super::DynRcmdReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynUnLoginRcmd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynUnLoginRcmd"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_video(
            &mut self,
            request: impl tonic::IntoRequest<super::DynVideoReq>,
        ) -> std::result::Result<tonic::Response<super::DynVideoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynVideo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynVideo"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_video_personal(
            &mut self,
            request: impl tonic::IntoRequest<super::DynVideoPersonalReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynVideoPersonalReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynVideoPersonal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynVideoPersonal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_video_upd_offset(
            &mut self,
            request: impl tonic::IntoRequest<super::DynVideoUpdOffsetReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynVideoUpdOffset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "DynVideoUpdOffset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_vote(
            &mut self,
            request: impl tonic::IntoRequest<super::DynVoteReq>,
        ) -> std::result::Result<tonic::Response<super::DynVoteReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/DynVote",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "DynVote"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn feed_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::FeedFilterReq>,
        ) -> std::result::Result<
            tonic::Response<super::FeedFilterReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/FeedFilter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "FeedFilter"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fetch_tab_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::NoReq>,
        ) -> std::result::Result<
            tonic::Response<super::FetchTabSettingReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/FetchTabSetting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "FetchTabSetting"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn home_subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::HomeSubscribeReq>,
        ) -> std::result::Result<
            tonic::Response<super::HomeSubscribeReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/HomeSubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "HomeSubscribe"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn lbs_poi(
            &mut self,
            request: impl tonic::IntoRequest<super::LbsPoiReq>,
        ) -> std::result::Result<tonic::Response<super::LbsPoiReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/LbsPoi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "LbsPoi"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn legacy_topic_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::LegacyTopicFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::LegacyTopicFeedReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/LegacyTopicFeed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "LegacyTopicFeed"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn like_list(
            &mut self,
            request: impl tonic::IntoRequest<super::LikeListReq>,
        ) -> std::result::Result<tonic::Response<super::LikeListReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/LikeList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "LikeList"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn official_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::OfficialAccountsReq>,
        ) -> std::result::Result<
            tonic::Response<super::OfficialAccountsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/OfficialAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "OfficialAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn official_dynamics(
            &mut self,
            request: impl tonic::IntoRequest<super::OfficialDynamicsReq>,
        ) -> std::result::Result<
            tonic::Response<super::OfficialDynamicsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/OfficialDynamics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "OfficialDynamics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn quick_consume_more_avatar_list(
            &mut self,
            request: impl tonic::IntoRequest<super::QuickConsumeMoreAvatarListReq>,
        ) -> std::result::Result<
            tonic::Response<super::QuickConsumeMoreAvatarListReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/QuickConsumeMoreAvatarList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "QuickConsumeMoreAvatarList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn reaction_list(
            &mut self,
            request: impl tonic::IntoRequest<super::ReactionListReq>,
        ) -> std::result::Result<
            tonic::Response<super::ReactionListReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/ReactionList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "ReactionList"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn repost_list(
            &mut self,
            request: impl tonic::IntoRequest<super::RepostListReq>,
        ) -> std::result::Result<tonic::Response<super::RepostListRsp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/RepostList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "RepostList"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn school_recommend(
            &mut self,
            request: impl tonic::IntoRequest<super::SchoolRecommendReq>,
        ) -> std::result::Result<
            tonic::Response<super::SchoolRecommendReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/SchoolRecommend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "SchoolRecommend"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn school_search(
            &mut self,
            request: impl tonic::IntoRequest<super::SchoolSearchReq>,
        ) -> std::result::Result<
            tonic::Response<super::SchoolSearchReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/SchoolSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "SchoolSearch"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn set_decision(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDecisionReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/SetDecision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "SetDecision"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn set_recent_campus(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRecentCampusReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/SetRecentCampus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "SetRecentCampus"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn subscribe_campus(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeCampusReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/SubscribeCampus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "SubscribeCampus"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn subscription_click(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscriptionClickReq>,
        ) -> std::result::Result<
            tonic::Response<super::SubscriptionClickResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/SubscriptionClick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "SubscriptionClick",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn topic_list(
            &mut self,
            request: impl tonic::IntoRequest<super::TopicListReq>,
        ) -> std::result::Result<tonic::Response<super::TopicListReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/TopicList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "TopicList"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn topic_square(
            &mut self,
            request: impl tonic::IntoRequest<super::TopicSquareReq>,
        ) -> std::result::Result<
            tonic::Response<super::TopicSquareReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/TopicSquare",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "TopicSquare"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn unfollow_match(
            &mut self,
            request: impl tonic::IntoRequest<super::UnfollowMatchReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/UnfollowMatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Dynamic", "UnfollowMatch"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn update_tab_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTabSettingReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Dynamic/UpdateTabSetting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Dynamic",
                        "UpdateTabSetting",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod opus_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct OpusClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> OpusClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OpusClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OpusClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn list_creation(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCreationReq>,
        ) -> std::result::Result<
            tonic::Response<super::ListCreationResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Opus/ListCreation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Opus", "ListCreation"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn list_fav(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFavReq>,
        ) -> std::result::Result<tonic::Response<super::ListFavResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Opus/ListFav",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Opus", "ListFav"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn opus_collection_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::OpusCollectionDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::OpusCollectionDetailResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Opus/OpusCollectionDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v2.Opus",
                        "OpusCollectionDetail",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn opus_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::OpusDetailReq>,
        ) -> std::result::Result<tonic::Response<super::OpusDetailResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Opus/OpusDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v2.Opus", "OpusDetail"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn opus_space_flow(
            &mut self,
            request: impl tonic::IntoRequest<super::OpusSpaceFlowReq>,
        ) -> std::result::Result<
            tonic::Response<super::OpusSpaceFlowResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Opus/OpusSpaceFlow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Opus", "OpusSpaceFlow"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn sign_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::SignResourcesReq>,
        ) -> std::result::Result<
            tonic::Response<super::SignResourcesResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v2.Opus/SignResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v2.Opus", "SignResources"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod campus_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CampusServer.
    #[async_trait]
    pub trait Campus: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn water_flow_rcmd(
            &self,
            request: tonic::Request<super::WaterFlowRcmdReq>,
        ) -> std::result::Result<
            tonic::Response<super::WaterFlowRcmdResp>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct CampusServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CampusServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CampusServer<T>
    where
        T: Campus,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.dynamic.v2.Campus/WaterFlowRcmd" => {
                    #[allow(non_camel_case_types)]
                    struct WaterFlowRcmdSvc<T: Campus>(pub Arc<T>);
                    impl<T: Campus> tonic::server::UnaryService<super::WaterFlowRcmdReq>
                    for WaterFlowRcmdSvc<T> {
                        type Response = super::WaterFlowRcmdResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WaterFlowRcmdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Campus>::water_flow_rcmd(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WaterFlowRcmdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CampusServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.dynamic.v2.Campus";
    impl<T> tonic::server::NamedService for CampusServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod dynamic_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DynamicServer.
    #[async_trait]
    pub trait Dynamic: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn alumni_dynamics(
            &self,
            request: tonic::Request<super::AlumniDynamicsReq>,
        ) -> std::result::Result<
            tonic::Response<super::AlumniDynamicsReply>,
            tonic::Status,
        >;
        ///
        async fn campus_billboard(
            &self,
            request: tonic::Request<super::CampusBillBoardReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusBillBoardReply>,
            tonic::Status,
        >;
        ///
        async fn campus_billboard_internal(
            &self,
            request: tonic::Request<super::CampusBillboardInternalReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusBillBoardReply>,
            tonic::Status,
        >;
        ///
        async fn campus_entry_tab(
            &self,
            request: tonic::Request<super::CampusEntryTabReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusEntryTabResp>,
            tonic::Status,
        >;
        ///
        async fn campus_feedback(
            &self,
            request: tonic::Request<super::CampusFeedbackReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusFeedbackReply>,
            tonic::Status,
        >;
        ///
        async fn campus_home_pages(
            &self,
            request: tonic::Request<super::CampusHomePagesReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusHomePagesReply>,
            tonic::Status,
        >;
        ///
        async fn campus_mate_like_list(
            &self,
            request: tonic::Request<super::CampusMateLikeListReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMateLikeListReply>,
            tonic::Status,
        >;
        ///
        async fn campus_mng_detail(
            &self,
            request: tonic::Request<super::CampusMngDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMngDetailReply>,
            tonic::Status,
        >;
        ///
        async fn campus_mng_quiz_operate(
            &self,
            request: tonic::Request<super::CampusMngQuizOperateReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMngQuizOperateReply>,
            tonic::Status,
        >;
        ///
        async fn campus_mng_submit(
            &self,
            request: tonic::Request<super::CampusMngSubmitReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusMngSubmitReply>,
            tonic::Status,
        >;
        ///
        async fn campus_rcmd(
            &self,
            request: tonic::Request<super::CampusRcmdReq>,
        ) -> std::result::Result<tonic::Response<super::CampusRcmdReply>, tonic::Status>;
        ///
        async fn campus_rcmd_feed(
            &self,
            request: tonic::Request<super::CampusRcmdFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRcmdFeedReply>,
            tonic::Status,
        >;
        ///
        async fn campus_recommend(
            &self,
            request: tonic::Request<super::CampusRecommendReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRecommendReply>,
            tonic::Status,
        >;
        ///
        async fn campus_red_dot(
            &self,
            request: tonic::Request<super::CampusRedDotReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusRedDotReply>,
            tonic::Status,
        >;
        ///
        async fn campus_square(
            &self,
            request: tonic::Request<super::CampusSquareReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusSquareReply>,
            tonic::Status,
        >;
        ///
        async fn campus_topic_rcmd_feed(
            &self,
            request: tonic::Request<super::CampusTopicRcmdFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::CampusTopicRcmdFeedReply>,
            tonic::Status,
        >;
        ///
        async fn cooperation_staff_list(
            &self,
            request: tonic::Request<super::CooperationStaffListReq>,
        ) -> std::result::Result<
            tonic::Response<super::CooperationStaffListResp>,
            tonic::Status,
        >;
        ///
        async fn dyn_addition_common_follow(
            &self,
            request: tonic::Request<super::DynAdditionCommonFollowReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynAdditionCommonFollowReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_all(
            &self,
            request: tonic::Request<super::DynAllReq>,
        ) -> std::result::Result<tonic::Response<super::DynAllReply>, tonic::Status>;
        ///
        async fn dyn_all_personal(
            &self,
            request: tonic::Request<super::DynAllPersonalReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynAllPersonalReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_all_upd_offset(
            &self,
            request: tonic::Request<super::DynAllUpdOffsetReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn dyn_detail(
            &self,
            request: tonic::Request<super::DynDetailReq>,
        ) -> std::result::Result<tonic::Response<super::DynDetailReply>, tonic::Status>;
        ///
        async fn dyn_details(
            &self,
            request: tonic::Request<super::DynDetailsReq>,
        ) -> std::result::Result<tonic::Response<super::DynDetailsReply>, tonic::Status>;
        ///
        async fn dyn_fake_card(
            &self,
            request: tonic::Request<super::DynFakeCardReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynFakeCardReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_friend(
            &self,
            request: tonic::Request<super::DynFriendReq>,
        ) -> std::result::Result<tonic::Response<super::DynFriendReply>, tonic::Status>;
        ///
        async fn dyn_light(
            &self,
            request: tonic::Request<super::DynLightReq>,
        ) -> std::result::Result<tonic::Response<super::DynLightReply>, tonic::Status>;
        ///
        async fn dyn_mix_up_list_search(
            &self,
            request: tonic::Request<super::DynMixUpListSearchReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListSearchReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_mix_up_list_view_more(
            &self,
            request: tonic::Request<super::DynMixUpListViewMoreReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListViewMoreReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_rcmd_up_exchange(
            &self,
            request: tonic::Request<super::DynRcmdUpExchangeReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynRcmdUpExchangeReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_search(
            &self,
            request: tonic::Request<super::DynSearchReq>,
        ) -> std::result::Result<tonic::Response<super::DynSearchReply>, tonic::Status>;
        ///
        async fn dyn_server_details(
            &self,
            request: tonic::Request<super::DynServerDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynServerDetailsReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_space(
            &self,
            request: tonic::Request<super::DynSpaceReq>,
        ) -> std::result::Result<tonic::Response<super::DynSpaceRsp>, tonic::Status>;
        ///
        async fn dyn_space_search_details(
            &self,
            request: tonic::Request<super::DynSpaceSearchDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynSpaceSearchDetailsReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_tab(
            &self,
            request: tonic::Request<super::DynTabReq>,
        ) -> std::result::Result<tonic::Response<super::DynTabReply>, tonic::Status>;
        ///
        async fn dyn_thumb(
            &self,
            request: tonic::Request<super::DynThumbReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn dyn_un_login_rcmd(
            &self,
            request: tonic::Request<super::DynRcmdReq>,
        ) -> std::result::Result<tonic::Response<super::DynRcmdReply>, tonic::Status>;
        ///
        async fn dyn_video(
            &self,
            request: tonic::Request<super::DynVideoReq>,
        ) -> std::result::Result<tonic::Response<super::DynVideoReply>, tonic::Status>;
        ///
        async fn dyn_video_personal(
            &self,
            request: tonic::Request<super::DynVideoPersonalReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynVideoPersonalReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_video_upd_offset(
            &self,
            request: tonic::Request<super::DynVideoUpdOffsetReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn dyn_vote(
            &self,
            request: tonic::Request<super::DynVoteReq>,
        ) -> std::result::Result<tonic::Response<super::DynVoteReply>, tonic::Status>;
        ///
        async fn feed_filter(
            &self,
            request: tonic::Request<super::FeedFilterReq>,
        ) -> std::result::Result<tonic::Response<super::FeedFilterReply>, tonic::Status>;
        ///
        async fn fetch_tab_setting(
            &self,
            request: tonic::Request<super::NoReq>,
        ) -> std::result::Result<
            tonic::Response<super::FetchTabSettingReply>,
            tonic::Status,
        >;
        ///
        async fn home_subscribe(
            &self,
            request: tonic::Request<super::HomeSubscribeReq>,
        ) -> std::result::Result<
            tonic::Response<super::HomeSubscribeReply>,
            tonic::Status,
        >;
        ///
        async fn lbs_poi(
            &self,
            request: tonic::Request<super::LbsPoiReq>,
        ) -> std::result::Result<tonic::Response<super::LbsPoiReply>, tonic::Status>;
        ///
        async fn legacy_topic_feed(
            &self,
            request: tonic::Request<super::LegacyTopicFeedReq>,
        ) -> std::result::Result<
            tonic::Response<super::LegacyTopicFeedReply>,
            tonic::Status,
        >;
        ///
        async fn like_list(
            &self,
            request: tonic::Request<super::LikeListReq>,
        ) -> std::result::Result<tonic::Response<super::LikeListReply>, tonic::Status>;
        ///
        async fn official_accounts(
            &self,
            request: tonic::Request<super::OfficialAccountsReq>,
        ) -> std::result::Result<
            tonic::Response<super::OfficialAccountsReply>,
            tonic::Status,
        >;
        ///
        async fn official_dynamics(
            &self,
            request: tonic::Request<super::OfficialDynamicsReq>,
        ) -> std::result::Result<
            tonic::Response<super::OfficialDynamicsReply>,
            tonic::Status,
        >;
        ///
        async fn quick_consume_more_avatar_list(
            &self,
            request: tonic::Request<super::QuickConsumeMoreAvatarListReq>,
        ) -> std::result::Result<
            tonic::Response<super::QuickConsumeMoreAvatarListReply>,
            tonic::Status,
        >;
        ///
        async fn reaction_list(
            &self,
            request: tonic::Request<super::ReactionListReq>,
        ) -> std::result::Result<
            tonic::Response<super::ReactionListReply>,
            tonic::Status,
        >;
        ///
        async fn repost_list(
            &self,
            request: tonic::Request<super::RepostListReq>,
        ) -> std::result::Result<tonic::Response<super::RepostListRsp>, tonic::Status>;
        ///
        async fn school_recommend(
            &self,
            request: tonic::Request<super::SchoolRecommendReq>,
        ) -> std::result::Result<
            tonic::Response<super::SchoolRecommendReply>,
            tonic::Status,
        >;
        ///
        async fn school_search(
            &self,
            request: tonic::Request<super::SchoolSearchReq>,
        ) -> std::result::Result<
            tonic::Response<super::SchoolSearchReply>,
            tonic::Status,
        >;
        ///
        async fn set_decision(
            &self,
            request: tonic::Request<super::SetDecisionReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn set_recent_campus(
            &self,
            request: tonic::Request<super::SetRecentCampusReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn subscribe_campus(
            &self,
            request: tonic::Request<super::SubscribeCampusReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn subscription_click(
            &self,
            request: tonic::Request<super::SubscriptionClickReq>,
        ) -> std::result::Result<
            tonic::Response<super::SubscriptionClickResp>,
            tonic::Status,
        >;
        ///
        async fn topic_list(
            &self,
            request: tonic::Request<super::TopicListReq>,
        ) -> std::result::Result<tonic::Response<super::TopicListReply>, tonic::Status>;
        ///
        async fn topic_square(
            &self,
            request: tonic::Request<super::TopicSquareReq>,
        ) -> std::result::Result<
            tonic::Response<super::TopicSquareReply>,
            tonic::Status,
        >;
        ///
        async fn unfollow_match(
            &self,
            request: tonic::Request<super::UnfollowMatchReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn update_tab_setting(
            &self,
            request: tonic::Request<super::UpdateTabSettingReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct DynamicServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> DynamicServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for DynamicServer<T>
    where
        T: Dynamic,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.dynamic.v2.Dynamic/AlumniDynamics" => {
                    #[allow(non_camel_case_types)]
                    struct AlumniDynamicsSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::AlumniDynamicsReq>
                    for AlumniDynamicsSvc<T> {
                        type Response = super::AlumniDynamicsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AlumniDynamicsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::alumni_dynamics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AlumniDynamicsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusBillboard" => {
                    #[allow(non_camel_case_types)]
                    struct CampusBillboardSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusBillBoardReq>
                    for CampusBillboardSvc<T> {
                        type Response = super::CampusBillBoardReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusBillBoardReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_billboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusBillboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusBillboardInternal" => {
                    #[allow(non_camel_case_types)]
                    struct CampusBillboardInternalSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusBillboardInternalReq>
                    for CampusBillboardInternalSvc<T> {
                        type Response = super::CampusBillBoardReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusBillboardInternalReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_billboard_internal(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusBillboardInternalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusEntryTab" => {
                    #[allow(non_camel_case_types)]
                    struct CampusEntryTabSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusEntryTabReq>
                    for CampusEntryTabSvc<T> {
                        type Response = super::CampusEntryTabResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusEntryTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_entry_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusEntryTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusFeedback" => {
                    #[allow(non_camel_case_types)]
                    struct CampusFeedbackSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusFeedbackReq>
                    for CampusFeedbackSvc<T> {
                        type Response = super::CampusFeedbackReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusFeedbackReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_feedback(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusFeedbackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusHomePages" => {
                    #[allow(non_camel_case_types)]
                    struct CampusHomePagesSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusHomePagesReq>
                    for CampusHomePagesSvc<T> {
                        type Response = super::CampusHomePagesReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusHomePagesReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_home_pages(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusHomePagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusMateLikeList" => {
                    #[allow(non_camel_case_types)]
                    struct CampusMateLikeListSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusMateLikeListReq>
                    for CampusMateLikeListSvc<T> {
                        type Response = super::CampusMateLikeListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusMateLikeListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_mate_like_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusMateLikeListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusMngDetail" => {
                    #[allow(non_camel_case_types)]
                    struct CampusMngDetailSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusMngDetailReq>
                    for CampusMngDetailSvc<T> {
                        type Response = super::CampusMngDetailReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusMngDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_mng_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusMngDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusMngQuizOperate" => {
                    #[allow(non_camel_case_types)]
                    struct CampusMngQuizOperateSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusMngQuizOperateReq>
                    for CampusMngQuizOperateSvc<T> {
                        type Response = super::CampusMngQuizOperateReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusMngQuizOperateReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_mng_quiz_operate(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusMngQuizOperateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusMngSubmit" => {
                    #[allow(non_camel_case_types)]
                    struct CampusMngSubmitSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusMngSubmitReq>
                    for CampusMngSubmitSvc<T> {
                        type Response = super::CampusMngSubmitReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusMngSubmitReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_mng_submit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusMngSubmitSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusRcmd" => {
                    #[allow(non_camel_case_types)]
                    struct CampusRcmdSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::CampusRcmdReq>
                    for CampusRcmdSvc<T> {
                        type Response = super::CampusRcmdReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusRcmdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_rcmd(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusRcmdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusRcmdFeed" => {
                    #[allow(non_camel_case_types)]
                    struct CampusRcmdFeedSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusRcmdFeedReq>
                    for CampusRcmdFeedSvc<T> {
                        type Response = super::CampusRcmdFeedReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusRcmdFeedReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_rcmd_feed(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusRcmdFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusRecommend" => {
                    #[allow(non_camel_case_types)]
                    struct CampusRecommendSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusRecommendReq>
                    for CampusRecommendSvc<T> {
                        type Response = super::CampusRecommendReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusRecommendReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_recommend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusRecommendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusRedDot" => {
                    #[allow(non_camel_case_types)]
                    struct CampusRedDotSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::CampusRedDotReq>
                    for CampusRedDotSvc<T> {
                        type Response = super::CampusRedDotReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusRedDotReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_red_dot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusRedDotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusSquare" => {
                    #[allow(non_camel_case_types)]
                    struct CampusSquareSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::CampusSquareReq>
                    for CampusSquareSvc<T> {
                        type Response = super::CampusSquareReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusSquareReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_square(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusSquareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CampusTopicRcmdFeed" => {
                    #[allow(non_camel_case_types)]
                    struct CampusTopicRcmdFeedSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CampusTopicRcmdFeedReq>
                    for CampusTopicRcmdFeedSvc<T> {
                        type Response = super::CampusTopicRcmdFeedReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CampusTopicRcmdFeedReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::campus_topic_rcmd_feed(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CampusTopicRcmdFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/CooperationStaffList" => {
                    #[allow(non_camel_case_types)]
                    struct CooperationStaffListSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::CooperationStaffListReq>
                    for CooperationStaffListSvc<T> {
                        type Response = super::CooperationStaffListResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CooperationStaffListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::cooperation_staff_list(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CooperationStaffListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynAdditionCommonFollow" => {
                    #[allow(non_camel_case_types)]
                    struct DynAdditionCommonFollowSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynAdditionCommonFollowReq>
                    for DynAdditionCommonFollowSvc<T> {
                        type Response = super::DynAdditionCommonFollowReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynAdditionCommonFollowReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_addition_common_follow(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynAdditionCommonFollowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynAll" => {
                    #[allow(non_camel_case_types)]
                    struct DynAllSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynAllReq>
                    for DynAllSvc<T> {
                        type Response = super::DynAllReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynAllReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynAllSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynAllPersonal" => {
                    #[allow(non_camel_case_types)]
                    struct DynAllPersonalSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynAllPersonalReq>
                    for DynAllPersonalSvc<T> {
                        type Response = super::DynAllPersonalReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynAllPersonalReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_all_personal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynAllPersonalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynAllUpdOffset" => {
                    #[allow(non_camel_case_types)]
                    struct DynAllUpdOffsetSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynAllUpdOffsetReq>
                    for DynAllUpdOffsetSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynAllUpdOffsetReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_all_upd_offset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynAllUpdOffsetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynDetail" => {
                    #[allow(non_camel_case_types)]
                    struct DynDetailSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynDetailReq>
                    for DynDetailSvc<T> {
                        type Response = super::DynDetailReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynDetails" => {
                    #[allow(non_camel_case_types)]
                    struct DynDetailsSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynDetailsReq>
                    for DynDetailsSvc<T> {
                        type Response = super::DynDetailsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynDetailsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynFakeCard" => {
                    #[allow(non_camel_case_types)]
                    struct DynFakeCardSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynFakeCardReq>
                    for DynFakeCardSvc<T> {
                        type Response = super::DynFakeCardReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynFakeCardReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_fake_card(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynFakeCardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynFriend" => {
                    #[allow(non_camel_case_types)]
                    struct DynFriendSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynFriendReq>
                    for DynFriendSvc<T> {
                        type Response = super::DynFriendReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynFriendReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_friend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynFriendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynLight" => {
                    #[allow(non_camel_case_types)]
                    struct DynLightSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynLightReq>
                    for DynLightSvc<T> {
                        type Response = super::DynLightReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynLightReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_light(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynLightSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynMixUpListSearch" => {
                    #[allow(non_camel_case_types)]
                    struct DynMixUpListSearchSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynMixUpListSearchReq>
                    for DynMixUpListSearchSvc<T> {
                        type Response = super::DynMixUpListSearchReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynMixUpListSearchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_mix_up_list_search(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynMixUpListSearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynMixUpListViewMore" => {
                    #[allow(non_camel_case_types)]
                    struct DynMixUpListViewMoreSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynMixUpListViewMoreReq>
                    for DynMixUpListViewMoreSvc<T> {
                        type Response = super::DynMixUpListViewMoreReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynMixUpListViewMoreReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_mix_up_list_view_more(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynMixUpListViewMoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynRcmdUpExchange" => {
                    #[allow(non_camel_case_types)]
                    struct DynRcmdUpExchangeSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynRcmdUpExchangeReq>
                    for DynRcmdUpExchangeSvc<T> {
                        type Response = super::DynRcmdUpExchangeReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynRcmdUpExchangeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_rcmd_up_exchange(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynRcmdUpExchangeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynSearch" => {
                    #[allow(non_camel_case_types)]
                    struct DynSearchSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynSearchReq>
                    for DynSearchSvc<T> {
                        type Response = super::DynSearchReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynSearchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_search(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynSearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynServerDetails" => {
                    #[allow(non_camel_case_types)]
                    struct DynServerDetailsSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynServerDetailsReq>
                    for DynServerDetailsSvc<T> {
                        type Response = super::DynServerDetailsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynServerDetailsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_server_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynServerDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynSpace" => {
                    #[allow(non_camel_case_types)]
                    struct DynSpaceSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynSpaceReq>
                    for DynSpaceSvc<T> {
                        type Response = super::DynSpaceRsp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynSpaceReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_space(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynSpaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynSpaceSearchDetails" => {
                    #[allow(non_camel_case_types)]
                    struct DynSpaceSearchDetailsSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynSpaceSearchDetailsReq>
                    for DynSpaceSearchDetailsSvc<T> {
                        type Response = super::DynSpaceSearchDetailsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynSpaceSearchDetailsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_space_search_details(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynSpaceSearchDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynTab" => {
                    #[allow(non_camel_case_types)]
                    struct DynTabSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynTabReq>
                    for DynTabSvc<T> {
                        type Response = super::DynTabReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynThumb" => {
                    #[allow(non_camel_case_types)]
                    struct DynThumbSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynThumbReq>
                    for DynThumbSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynThumbReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_thumb(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynThumbSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynUnLoginRcmd" => {
                    #[allow(non_camel_case_types)]
                    struct DynUnLoginRcmdSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynRcmdReq>
                    for DynUnLoginRcmdSvc<T> {
                        type Response = super::DynRcmdReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynRcmdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_un_login_rcmd(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynUnLoginRcmdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynVideo" => {
                    #[allow(non_camel_case_types)]
                    struct DynVideoSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynVideoReq>
                    for DynVideoSvc<T> {
                        type Response = super::DynVideoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynVideoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_video(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynVideoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynVideoPersonal" => {
                    #[allow(non_camel_case_types)]
                    struct DynVideoPersonalSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynVideoPersonalReq>
                    for DynVideoPersonalSvc<T> {
                        type Response = super::DynVideoPersonalReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynVideoPersonalReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_video_personal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynVideoPersonalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynVideoUpdOffset" => {
                    #[allow(non_camel_case_types)]
                    struct DynVideoUpdOffsetSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynVideoUpdOffsetReq>
                    for DynVideoUpdOffsetSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynVideoUpdOffsetReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_video_upd_offset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynVideoUpdOffsetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/DynVote" => {
                    #[allow(non_camel_case_types)]
                    struct DynVoteSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynVoteReq>
                    for DynVoteSvc<T> {
                        type Response = super::DynVoteReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynVoteReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_vote(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynVoteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/FeedFilter" => {
                    #[allow(non_camel_case_types)]
                    struct FeedFilterSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::FeedFilterReq>
                    for FeedFilterSvc<T> {
                        type Response = super::FeedFilterReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FeedFilterReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::feed_filter(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FeedFilterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/FetchTabSetting" => {
                    #[allow(non_camel_case_types)]
                    struct FetchTabSettingSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::NoReq>
                    for FetchTabSettingSvc<T> {
                        type Response = super::FetchTabSettingReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::fetch_tab_setting(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FetchTabSettingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/HomeSubscribe" => {
                    #[allow(non_camel_case_types)]
                    struct HomeSubscribeSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::HomeSubscribeReq>
                    for HomeSubscribeSvc<T> {
                        type Response = super::HomeSubscribeReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HomeSubscribeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::home_subscribe(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HomeSubscribeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/LbsPoi" => {
                    #[allow(non_camel_case_types)]
                    struct LbsPoiSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::LbsPoiReq>
                    for LbsPoiSvc<T> {
                        type Response = super::LbsPoiReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LbsPoiReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::lbs_poi(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LbsPoiSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/LegacyTopicFeed" => {
                    #[allow(non_camel_case_types)]
                    struct LegacyTopicFeedSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::LegacyTopicFeedReq>
                    for LegacyTopicFeedSvc<T> {
                        type Response = super::LegacyTopicFeedReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LegacyTopicFeedReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::legacy_topic_feed(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LegacyTopicFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/LikeList" => {
                    #[allow(non_camel_case_types)]
                    struct LikeListSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::LikeListReq>
                    for LikeListSvc<T> {
                        type Response = super::LikeListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LikeListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::like_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LikeListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/OfficialAccounts" => {
                    #[allow(non_camel_case_types)]
                    struct OfficialAccountsSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::OfficialAccountsReq>
                    for OfficialAccountsSvc<T> {
                        type Response = super::OfficialAccountsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OfficialAccountsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::official_accounts(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OfficialAccountsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/OfficialDynamics" => {
                    #[allow(non_camel_case_types)]
                    struct OfficialDynamicsSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::OfficialDynamicsReq>
                    for OfficialDynamicsSvc<T> {
                        type Response = super::OfficialDynamicsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OfficialDynamicsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::official_dynamics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OfficialDynamicsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/QuickConsumeMoreAvatarList" => {
                    #[allow(non_camel_case_types)]
                    struct QuickConsumeMoreAvatarListSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::QuickConsumeMoreAvatarListReq>
                    for QuickConsumeMoreAvatarListSvc<T> {
                        type Response = super::QuickConsumeMoreAvatarListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QuickConsumeMoreAvatarListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::quick_consume_more_avatar_list(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QuickConsumeMoreAvatarListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/ReactionList" => {
                    #[allow(non_camel_case_types)]
                    struct ReactionListSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::ReactionListReq>
                    for ReactionListSvc<T> {
                        type Response = super::ReactionListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReactionListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::reaction_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReactionListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/RepostList" => {
                    #[allow(non_camel_case_types)]
                    struct RepostListSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::RepostListReq>
                    for RepostListSvc<T> {
                        type Response = super::RepostListRsp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RepostListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::repost_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RepostListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/SchoolRecommend" => {
                    #[allow(non_camel_case_types)]
                    struct SchoolRecommendSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::SchoolRecommendReq>
                    for SchoolRecommendSvc<T> {
                        type Response = super::SchoolRecommendReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SchoolRecommendReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::school_recommend(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SchoolRecommendSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/SchoolSearch" => {
                    #[allow(non_camel_case_types)]
                    struct SchoolSearchSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::SchoolSearchReq>
                    for SchoolSearchSvc<T> {
                        type Response = super::SchoolSearchReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SchoolSearchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::school_search(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SchoolSearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/SetDecision" => {
                    #[allow(non_camel_case_types)]
                    struct SetDecisionSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::SetDecisionReq>
                    for SetDecisionSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetDecisionReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::set_decision(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetDecisionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/SetRecentCampus" => {
                    #[allow(non_camel_case_types)]
                    struct SetRecentCampusSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::SetRecentCampusReq>
                    for SetRecentCampusSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetRecentCampusReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::set_recent_campus(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetRecentCampusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/SubscribeCampus" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeCampusSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::SubscribeCampusReq>
                    for SubscribeCampusSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeCampusReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::subscribe_campus(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeCampusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/SubscriptionClick" => {
                    #[allow(non_camel_case_types)]
                    struct SubscriptionClickSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::SubscriptionClickReq>
                    for SubscriptionClickSvc<T> {
                        type Response = super::SubscriptionClickResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscriptionClickReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::subscription_click(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscriptionClickSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/TopicList" => {
                    #[allow(non_camel_case_types)]
                    struct TopicListSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::TopicListReq>
                    for TopicListSvc<T> {
                        type Response = super::TopicListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TopicListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::topic_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TopicListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/TopicSquare" => {
                    #[allow(non_camel_case_types)]
                    struct TopicSquareSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::TopicSquareReq>
                    for TopicSquareSvc<T> {
                        type Response = super::TopicSquareReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TopicSquareReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::topic_square(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TopicSquareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/UnfollowMatch" => {
                    #[allow(non_camel_case_types)]
                    struct UnfollowMatchSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::UnfollowMatchReq>
                    for UnfollowMatchSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnfollowMatchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::unfollow_match(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnfollowMatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Dynamic/UpdateTabSetting" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateTabSettingSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::UpdateTabSettingReq>
                    for UpdateTabSettingSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateTabSettingReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::update_tab_setting(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateTabSettingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for DynamicServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.dynamic.v2.Dynamic";
    impl<T> tonic::server::NamedService for DynamicServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod opus_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with OpusServer.
    #[async_trait]
    pub trait Opus: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn list_creation(
            &self,
            request: tonic::Request<super::ListCreationReq>,
        ) -> std::result::Result<
            tonic::Response<super::ListCreationResp>,
            tonic::Status,
        >;
        ///
        async fn list_fav(
            &self,
            request: tonic::Request<super::ListFavReq>,
        ) -> std::result::Result<tonic::Response<super::ListFavResp>, tonic::Status>;
        ///
        async fn opus_collection_detail(
            &self,
            request: tonic::Request<super::OpusCollectionDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::OpusCollectionDetailResp>,
            tonic::Status,
        >;
        ///
        async fn opus_detail(
            &self,
            request: tonic::Request<super::OpusDetailReq>,
        ) -> std::result::Result<tonic::Response<super::OpusDetailResp>, tonic::Status>;
        ///
        async fn opus_space_flow(
            &self,
            request: tonic::Request<super::OpusSpaceFlowReq>,
        ) -> std::result::Result<
            tonic::Response<super::OpusSpaceFlowResp>,
            tonic::Status,
        >;
        ///
        async fn sign_resources(
            &self,
            request: tonic::Request<super::SignResourcesReq>,
        ) -> std::result::Result<
            tonic::Response<super::SignResourcesResp>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct OpusServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> OpusServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for OpusServer<T>
    where
        T: Opus,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.dynamic.v2.Opus/ListCreation" => {
                    #[allow(non_camel_case_types)]
                    struct ListCreationSvc<T: Opus>(pub Arc<T>);
                    impl<T: Opus> tonic::server::UnaryService<super::ListCreationReq>
                    for ListCreationSvc<T> {
                        type Response = super::ListCreationResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListCreationReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Opus>::list_creation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListCreationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Opus/ListFav" => {
                    #[allow(non_camel_case_types)]
                    struct ListFavSvc<T: Opus>(pub Arc<T>);
                    impl<T: Opus> tonic::server::UnaryService<super::ListFavReq>
                    for ListFavSvc<T> {
                        type Response = super::ListFavResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListFavReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Opus>::list_fav(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListFavSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Opus/OpusCollectionDetail" => {
                    #[allow(non_camel_case_types)]
                    struct OpusCollectionDetailSvc<T: Opus>(pub Arc<T>);
                    impl<
                        T: Opus,
                    > tonic::server::UnaryService<super::OpusCollectionDetailReq>
                    for OpusCollectionDetailSvc<T> {
                        type Response = super::OpusCollectionDetailResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OpusCollectionDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Opus>::opus_collection_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OpusCollectionDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Opus/OpusDetail" => {
                    #[allow(non_camel_case_types)]
                    struct OpusDetailSvc<T: Opus>(pub Arc<T>);
                    impl<T: Opus> tonic::server::UnaryService<super::OpusDetailReq>
                    for OpusDetailSvc<T> {
                        type Response = super::OpusDetailResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OpusDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Opus>::opus_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OpusDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Opus/OpusSpaceFlow" => {
                    #[allow(non_camel_case_types)]
                    struct OpusSpaceFlowSvc<T: Opus>(pub Arc<T>);
                    impl<T: Opus> tonic::server::UnaryService<super::OpusSpaceFlowReq>
                    for OpusSpaceFlowSvc<T> {
                        type Response = super::OpusSpaceFlowResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OpusSpaceFlowReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Opus>::opus_space_flow(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OpusSpaceFlowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v2.Opus/SignResources" => {
                    #[allow(non_camel_case_types)]
                    struct SignResourcesSvc<T: Opus>(pub Arc<T>);
                    impl<T: Opus> tonic::server::UnaryService<super::SignResourcesReq>
                    for SignResourcesSvc<T> {
                        type Response = super::SignResourcesResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignResourcesReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Opus>::sign_resources(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignResourcesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for OpusServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.dynamic.v2.Opus";
    impl<T> tonic::server::NamedService for OpusServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
